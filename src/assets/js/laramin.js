/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(5);
var isBuffer = __webpack_require__(16);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

!function(n,t){ true?module.exports=t():"function"==typeof define&&define.amd?define(t):n.Qoob=t()}(this,function(){"use strict";function n(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,e=[];if(d(n,function(n,o){null===t?e.push(n.innerHTML):n.innerHTML=t}),null===t)return e}function t(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,e=[];if(d(n,function(n,o){null===t?e.push(n.textContent||n.innerText):void 0!==n.textContent?n.textContent=t:n.innerText=t}),null===t)return e}function e(n){return null===n?null:n==window||n.type?[n]:n.constructor===Array||!0===f(n)?n:"object"===(void 0===n?"undefined":U(n))?[n]:document.querySelectorAll(n)}function o(n){for(var t=[],o=0;o<n.length;o++)for(var u=e(n[o]),i=0;i<u.length;i++)t.push(u[i]);return t}function u(n,t){d(n,function(n,e){d(t,function(t,e){n.appendChild(t)})})}function i(n,t){d(n,function(n,e){n.insertBefore(t,n.firstChild)})}function r(n){d(n,function(n,t){n.parentNode.removeChild(n)})}function l(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=document.createElement(t);return null!==e&&n(o,e),o}function c(n){var t=[];return d(n,function(n,e){t.push(n.cloneNode(!0))}),t}function f(n){return void 0!==n.length&&void 0!==n.item}function a(n){return n.filter(function(n,t,e){return e.indexOf(n)===t})}function s(n){return n.replace(/-([a-z])/g,function(n,t){return t.toUpperCase()})}function d(n,t){var o=e(n);if(null!==o)for(var u=0;u<o.length;u++)t(o[u],u)}function v(n){return null===n?null:n.length>0?n[0]:null}function p(n){return v(n)}function h(n){return function(t){return t[n]}}function m(n){return function(t){return t[n]()}}function g(n){var t=e(n);return t.length>0?t[0]:null}function y(n){return function(){return p(n.apply(void 0,arguments))}}function b(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=[];if(d(n,function(n,u){null===e?o.push(n.getAttribute(t)):n.setAttribute(t,e)}),null===e)return o}function L(n,t){d(n,function(n,e){n.removeAttribute(t)})}function S(n,t){b(n,t,t)}function C(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,e=[];if(d(n,function(n,o){null===t?e.push(n.value):n.value=t}),null===t)return e}function E(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=[];if(d(n,function(n,u){null===e?n.dataset?o.push(n.dataset[s(t)]):o.push(n.getAttribute("data-"+t)):n.dataset?n.dataset[s(t)]=e:n.setAttribute("data-"+t,e)}),null===e)return o}function x(n,t){if("string"==typeof t){var e=[];return d(n,function(n,o){var u=window.getComputedStyle(n);e.push(u.getPropertyValue(t))}),e}d(n,function(n,e){for(var o in t)n.style[o]=t[o]})}function A(n,t,e){d(n,function(n,o){"off"===(p(E(n,"toggler-state"))||"off")?!0!==t(n)&&E(n,"toggler-state","on"):!0!==e(n)&&E(n,"toggler-state","off")})}function N(n,t,e){d(n,function(n,o){n.addEventListener?n.addEventListener(t,e):n.attachEvent("on"+t,function(){e.call(n)})})}function w(n,t,e){d(n,function(n,o){n.removeEventListener?n.removeEventListener(t,e):n.detachEvent("on"+t,e)})}function M(n){"loading"!=document.readyState?n():document.addEventListener?document.addEventListener("DOMContentLoaded",n):document.attachEvent("onreadystatechange",function(){"loading"!=document.readyState&&n()})}function k(n){d(n,function(n,t){n.style.display="none"})}function T(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"block";d(n,function(n,e){n.style.display=t})}function j(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"block";d(n,function(n,e){"none"===n.style.display?T(n,t):k(n)})}function q(n,t){var o=e(t),u=[],i=function(n,t){var e=null;return d(t,function(t,o){null===e&&t===n&&(e=t)}),e};return d(n,function(n,t){for(var e=n.parentNode;null!==e;){var r=i(e,o);if(null!==r){u.push(r);break}e=e.parentNode}}),a(u)}function z(n){var t=[];return d(n,function(n,e){t.push(n.parentNode)}),t}function O(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,e=[];return d(n,function(n,o){if(null!==t){d(n.querySelectorAll(t),function(n,t){e.push(n)})}else d(n.children,function(n,t){8!=n.nodeType&&e.push(n)})}),e}function R(n){var t=[];return d(n,function(n,e){d(Array.prototype.slice.call(n.parentNode.children),function(e,o){n!==e&&t.push(e)})}),t}function H(n,t){d(n,function(n,e){n.classList?n.classList.add(t):n.className+=" "+t})}function $(n,t){d(n,function(n,e){d(t,function(t,e){H(n,t)})})}function B(n,t){d(n,function(n,e){n.classList?n.classList.remove(t):n.className=n.className.replace(new RegExp("(^|\\b)"+t.split(" ").join("|")+"(\\b|$)","gi")," ")})}function D(n,t){d(n,function(n,e){d(t,function(t,e){B(n,t)})})}function P(n,t){var e=!1;return d(n,function(n,o){e=n.classList?!0===n.classList.contains(t)||e:!0===new RegExp("(^| )"+t+"( |$)","gi").test(n.className)||e}),e}function Q(n,t){var o=!1,u=this;return d(n,function(n,i){var r=n.matches||n.matchesSelector||n.msMatchesSelector||n.mozMatchesSelector||n.webkitMatchesSelector||n.oMatchesSelector;if(r)o=!!r.call(n,t)||o;else{var l=e(t);u.each(l,function(t,e){t===n&&(o=!0)})}}),o}var U="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n};return{addClass:H,addClasses:$,ancestor:q,append:u,attr:b,camelize:s,children:O,clone:c,css:x,data:E,documentReady:M,each:d,find:e,findAll:o,first:g,firstOf:y,func:m,hasClass:P,head:p,hide:k,html:n,is:Q,isNodeList:f,make:l,on:N,off:w,parent:z,prepend:i,prop:h,remove:r,removeAttr:L,removeClass:B,removeClasses:D,show:T,siblings:R,state:S,strip:v,text:t,toggle:j,toggler:A,uniques:a,val:C}});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var normalizeHeaderName = __webpack_require__(18);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(7);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(7);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 6 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var settle = __webpack_require__(19);
var buildURL = __webpack_require__(21);
var parseHeaders = __webpack_require__(22);
var isURLSameOrigin = __webpack_require__(23);
var createError = __webpack_require__(8);
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(24);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ("development" !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(25);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(20);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__errors__ = __webpack_require__(48);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var Form = function () {
    /**
     * Create a new Form instance.
     *
     * @param {object} data
     */
    function Form(data) {
        _classCallCheck(this, Form);

        this.originalData = data;

        for (var field in data) {
            this[field] = data[field];
        }

        this.errors = new __WEBPACK_IMPORTED_MODULE_0__errors__["a" /* default */]();
    }

    /**
     * Fetch all relevant data for the form.
     */


    _createClass(Form, [{
        key: 'data',
        value: function data() {
            var data = {};

            for (var property in this.originalData) {
                data[property] = this[property];
            }

            return data;
        }

        /**
         * Reset the form fields.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var field in this.originalData) {
                this[field] = '';
            }

            this.errors.clear();
        }

        /**
         * Send a POST request to the given URL.
         * .
         * @param {string} url
         */

    }, {
        key: 'post',
        value: function post(url) {
            return this.submit('post', url);
        }

        /**
         * Send a PUT request to the given URL.
         * .
         * @param {string} url
         */

    }, {
        key: 'put',
        value: function put(url) {
            return this.submit('put', url);
        }

        /**
         * Send a PATCH request to the given URL.
         * .
         * @param {string} url
         */

    }, {
        key: 'patch',
        value: function patch(url) {
            return this.submit('patch', url);
        }

        /**
         * Send a DELETE request to the given URL.
         * .
         * @param {string} url
         */

    }, {
        key: 'delete',
        value: function _delete(url) {
            return this.submit('delete', url);
        }

        /**
         * Submit the form.
         *
         * @param {string} requestType
         * @param {string} url
         */

    }, {
        key: 'submit',
        value: function submit(requestType, url) {
            var _this = this;

            return new Promise(function (resolve, reject) {
                axios[requestType](url, _this.data()).then(function (response) {
                    _this.onSuccess(response.data);

                    resolve(response.data);
                }).catch(function (error) {
                    _this.onFail(error.response.data);

                    reject(error.response.data);
                });
            });
        }

        /**
         * Handle a successful form submission.
         *
         * @param {object} data
         */

    }, {
        key: 'onSuccess',
        value: function onSuccess(data) {
            this.reset();
        }

        /**
         * Handle a failed form submission.
         *
         * @param {object} errors
         */

    }, {
        key: 'onFail',
        value: function onFail(errors) {
            this.errors.record(errors);
        }
    }]);

    return Form;
}();

/* harmony default export */ __webpack_exports__["a"] = (Form);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(13);
module.exports = __webpack_require__(83);


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vanilla_index__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_index__ = __webpack_require__(43);
window.axios = __webpack_require__(14);
window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
window.axios.defaults.headers.common['X-CSRF-TOKEN'] = document.head.querySelector('meta[name="csrf-token"]').content;




Object(__WEBPACK_IMPORTED_MODULE_0__vanilla_index__["a" /* default */])();
Object(__WEBPACK_IMPORTED_MODULE_1__vue_index__["a" /* default */])();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(15);

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var bind = __webpack_require__(5);
var Axios = __webpack_require__(17);
var defaults = __webpack_require__(3);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(10);
axios.CancelToken = __webpack_require__(31);
axios.isCancel = __webpack_require__(9);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(32);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(3);
var utils = __webpack_require__(0);
var InterceptorManager = __webpack_require__(26);
var dispatchRequest = __webpack_require__(27);
var isAbsoluteURL = __webpack_require__(29);
var combineURLs = __webpack_require__(30);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(8);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var transformData = __webpack_require__(28);
var isCancel = __webpack_require__(9);
var defaults = __webpack_require__(3);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(10);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_qoob__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_pre__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_form_index__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_sortable__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_crop__ = __webpack_require__(41);






var module = function module() {
  __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.documentReady(function () {
    Object(__WEBPACK_IMPORTED_MODULE_2__components_form_index__["a" /* default */])();
    Object(__WEBPACK_IMPORTED_MODULE_1__components_pre__["a" /* default */])();
    Object(__WEBPACK_IMPORTED_MODULE_3__components_sortable__["a" /* default */])();
    Object(__WEBPACK_IMPORTED_MODULE_4__components_crop__["a" /* default */])();
  });
};

/* harmony default export */ __webpack_exports__["a"] = (module);

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var bootstrap = function bootstrap() {
	var pre = document.getElementsByTagName('pre'),
	    pl = pre.length;
	for (var i = 0; i < pl; i++) {
		pre[i].innerHTML = '<span class="Pre__line"></span>' + pre[i].innerHTML;
		var num = pre[i].innerHTML.split(/\n/).length;
		for (var j = 0; j < num; j++) {
			var line_num = pre[i].getElementsByTagName('span')[0];
			line_num.innerHTML += '<span class="Pre__line-number">' + (j + 1) + '</span>';
		}
	}
};

/* harmony default export */ __webpack_exports__["a"] = (bootstrap);

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__form__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__wysiwyg__ = __webpack_require__(37);



var bootstrap = function bootstrap() {
	Object(__WEBPACK_IMPORTED_MODULE_0__form__["a" /* default */])();
	Object(__WEBPACK_IMPORTED_MODULE_1__wysiwyg__["a" /* default */])();
};

/* harmony default export */ __webpack_exports__["a"] = (bootstrap);

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_qoob__);


var bootstrap = function bootstrap() {
	var inputs = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.find('.Form__input');
	queInputs(inputs);
};

var queInputs = function inputs(inputs) {
	if (inputs.legnth < 1) return;
	__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.each(inputs, function (input) {
		if (__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--file')) return fileInput(input);
		if (__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--text') || __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--textarea') || __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--tel') || __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--number') || __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--search') || __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--url') || __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--email') || __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.hasClass(input, 'Form__input--password')) return textInput(input);
	});
};

var fileInput = function fileInput(input) {
	var label = input.nextElementSibling,
	    labelVal = label.innerHTML;

	input.addEventListener('change', function (e) {
		var fileName = '';
		if (this.files && this.files.length > 1) fileName = (this.getAttribute('data-multiple-caption') || '').replace('{count}', this.files.length);else fileName = e.target.value.split('\\').pop();

		if (fileName) label.querySelector('span').innerHTML = fileName;else label.innerHTML = labelVal;
	});

	// Firefox bug fix
	input.addEventListener('focus', function () {
		input.classList.add('has-focus');
	});
	input.addEventListener('blur', function () {
		input.classList.remove('has-focus');
	});
};

var textInput = function textInput(input) {
	var span = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.make('span');
	__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.addClass(span, 'Form__input-span');
	__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.append(__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.parent(input), span);
};

/* harmony default export */ __webpack_exports__["a"] = (bootstrap);

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_qoob__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_build_classic__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_build_classic___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_build_classic__);



var bootstrap = function bootstrap() {
	var editors = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.find('.Form__wysiwyg');
	if (editors.length <= 0) return;
	__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.each(editors, function (editorContainer) {
		editorContainer.height = 500;
		__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_build_classic___default.a.create(editorContainer, {
			height: '600px'
		}).then(function (editor) {
			console.log(editor);
		}).catch(function (error) {
			console.error(error);
		});
	});
};

/* harmony default export */ __webpack_exports__["a"] = (bootstrap);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function(e,t){ true?module.exports=t():'function'==typeof define&&define.amd?define([],t):'object'==typeof exports?exports.ClassicEditor=t():e.ClassicEditor=t()})(this,function(){var e=Number.POSITIVE_INFINITY,t=Math.floor,o=Math.max,n=Math.min;return function(e){function t(n){if(a[n])return a[n].exports;var o=a[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var a={};return t.m=e,t.c=a,t.d=function(e,a,n){t.o(e,a)||Object.defineProperty(e,a,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var a=e&&e.__esModule?function(){return e['default']}:function(){return e};return t.d(a,'a',a),a},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p='',t(t.s=279)}([function(e,t){'use strict';function a(e){const t=e.match(/^([^:]+):/);return t?e+` Read more: ${n}#${t[1]}.\n`:e}t.a=a;const n='https://ckeditor5.github.io/docs/nightly/ckeditor5/latest/framework/guides/support/error-codes.html';class o extends Error{constructor(e,t){e=a(e),t&&(e+=' '+JSON.stringify(t)),super(e),this.name='CKEditorError',this.data=t}static isCKEditorError(e){return e instanceof o}}t.b=o},function(e,t,a){'use strict';var o=a(54),i=a(18),r=a(55),s=a(0),l=a(26);class d{constructor(e,t){if(!e.is('element')&&!e.is('documentFragment'))throw new s.b('model-position-root-invalid: Position root invalid.');if(!(t instanceof Array)||0===t.length)throw new s.b('model-position-path-incorrect: Position path must be an array with at least one item.',{path:t});t=e.getPath().concat(t),e=e.root,this.root=e,this.path=t}get offset(){return Object(i.a)(this.path)}set offset(e){this.path[this.path.length-1]=e}get parent(){let e=this.root;for(let t=0;t<this.path.length-1;t++)e=e.getChild(e.offsetToIndex(this.path[t]));return e}get index(){return this.parent.offsetToIndex(this.offset)}get textNode(){const e=this.parent.getChild(this.index);return e instanceof l.a&&e.startOffset<this.offset?e:null}get nodeAfter(){return null===this.textNode?this.parent.getChild(this.index):null}get nodeBefore(){return null===this.textNode?this.parent.getChild(this.index-1):null}get isAtStart(){return 0===this.offset}get isAtEnd(){return this.offset==this.parent.maxOffset}compareWith(e){if(this.root!=e.root)return'different';const t=Object(r.a)(this.path,e.path);return'same'===t?'same':'prefix'===t?'before':'extension'===t?'after':this.path[t]<e.path[t]?'before':'after'}getLastMatchingPosition(e,t={}){t.startPosition=this;const a=new o.a(t);return a.skip(e),a.position}getParentPath(){return this.path.slice(0,-1)}getAncestors(){return this.parent.is('documentFragment')?[this.parent]:this.parent.getAncestors({includeSelf:!0})}getCommonPath(e){if(this.root!=e.root)return[];const t=Object(r.a)(this.path,e.path),a='string'==typeof t?n(this.path.length,e.path.length):t;return this.path.slice(0,a)}getCommonAncestor(e){const t=this.getAncestors(),a=e.getAncestors();let n=0;for(;t[n]==a[n]&&t[n];)n++;return 0==n?null:t[n-1]}getShiftedBy(e){const t=d.createFromPosition(this),a=t.offset+e;return t.offset=0>a?0:a,t}isAfter(e){return'after'==this.compareWith(e)}isBefore(e){return'before'==this.compareWith(e)}isEqual(e){return'same'==this.compareWith(e)}isTouching(e){let t=null,a=null;const n=this.compareWith(e);switch(n){case'same':return!0;case'before':t=d.createFromPosition(this),a=d.createFromPosition(e);break;case'after':t=d.createFromPosition(e),a=d.createFromPosition(this);break;default:return!1;}for(let n=t.parent;t.path.length+a.path.length;){if(t.isEqual(a))return!0;if(t.path.length>a.path.length){if(t.offset!==n.maxOffset)return!1;t.path=t.path.slice(0,-1),n=n.parent,t.offset++}else{if(0!==a.offset)return!1;a.path=a.path.slice(0,-1)}}}_getTransformedByDeletion(e,t){const a=d.createFromPosition(this);if(this.root!=e.root)return a;if('same'==Object(r.a)(e.getParentPath(),this.getParentPath())){if(e.offset<this.offset){if(e.offset+t>this.offset)return null;a.offset-=t}}else if('prefix'==Object(r.a)(e.getParentPath(),this.getParentPath())){const n=e.path.length-1;if(e.offset<=this.path[n]){if(e.offset+t>this.path[n])return null;a.path[n]-=t}}return a}_getTransformedByInsertion(e,t,a){const n=d.createFromPosition(this);if(this.root!=e.root)return n;if('same'==Object(r.a)(e.getParentPath(),this.getParentPath()))(e.offset<this.offset||e.offset==this.offset&&a)&&(n.offset+=t);else if('prefix'==Object(r.a)(e.getParentPath(),this.getParentPath())){const a=e.path.length-1;e.offset<=this.path[a]&&(n.path[a]+=t)}return n}_getTransformedByMove(e,t,a,n,o){let i=this._getTransformedByDeletion(e,a);return t=t._getTransformedByDeletion(e,a),i=null===i||o&&i.isEqual(e)?this._getCombined(e,t):i._getTransformedByInsertion(t,a,n),i}_getCombined(e,t){const a=e.path.length-1,n=d.createFromPosition(t);return n.offset=n.offset+this.path[a]-e.offset,n.path=n.path.concat(this.path.slice(a+1)),n}static createAt(e,t){if(e instanceof d)return this.createFromPosition(e);else{const a=e;if('end'==t)t=a.maxOffset;else{if('before'==t)return this.createBefore(a);if('after'==t)return this.createAfter(a);t||(t=0)}return this.createFromParentAndOffset(a,t)}}static createAfter(e){if(!e.parent)throw new s.b('model-position-after-root: You cannot make a position after root.',{root:e});return this.createFromParentAndOffset(e.parent,e.endOffset)}static createBefore(e){if(!e.parent)throw new s.b('model-position-before-root: You cannot make a position before root.',{root:e});return this.createFromParentAndOffset(e.parent,e.startOffset)}static createFromParentAndOffset(e,t){if(!e.is('element')&&!e.is('documentFragment'))throw new s.b('model-position-parent-incorrect: Position parent have to be a element or document fragment.');const a=e.getPath();return a.push(t),new this(e.root,a)}static createFromPosition(e){return new this(e.root,e.path.slice())}static fromJSON(e,t){if('$graveyard'===e.root)return new d(t.graveyard,e.path);if(!t.hasRoot(e.root))throw new s.b('model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.',{rootName:e.root});return new d(t.getRoot(e.root),e.path)}}t.a=d},function(e,t,a){'use strict';var n=a(12),o=a(4);class i{constructor(e){this.editor=e}destroy(){this.stopListening()}}t.a=i,Object(o.a)(i,n.a)},function(e,t,a){'use strict';var n=a(1),o=a(54),i=a(0);class r{constructor(e,t=null){this.start=n.a.createFromPosition(e),this.end=t?n.a.createFromPosition(t):n.a.createFromPosition(e)}*[Symbol.iterator](){yield*new o.a({boundaries:this,ignoreElementEnd:!0})}get isCollapsed(){return this.start.isEqual(this.end)}get isFlat(){return this.start.parent===this.end.parent}get root(){return this.start.root}containsPosition(e){return e.isAfter(this.start)&&e.isBefore(this.end)}containsRange(e,t=!1){e.isCollapsed&&(t=!1);const a=this.containsPosition(e.start)||t&&this.start.isEqual(e.start),n=this.containsPosition(e.end)||t&&this.end.isEqual(e.end);return a&&n}containsItem(e){const t=n.a.createBefore(e);return this.containsPosition(t)||this.start.isEqual(t)}isEqual(e){return this.start.isEqual(e.start)&&this.end.isEqual(e.end)}isIntersecting(e){return this.start.isBefore(e.end)&&this.end.isAfter(e.start)}getDifference(e){const t=[];return this.isIntersecting(e)?(this.containsPosition(e.start)&&t.push(new r(this.start,e.start)),this.containsPosition(e.end)&&t.push(new r(e.end,this.end))):t.push(r.createFromRange(this)),t}getIntersection(e){if(this.isIntersecting(e)){let t=this.start,a=this.end;return this.containsPosition(e.start)&&(t=e.start),this.containsPosition(e.end)&&(a=e.end),new r(t,a)}return null}getMinimalFlatRanges(){const e=[],t=this.start.getCommonPath(this.end).length,a=n.a.createFromPosition(this.start);for(let n=a.parent;a.path.length>t+1;){const t=n.maxOffset-a.offset;0!=t&&e.push(new r(a,a.getShiftedBy(t))),a.path=a.path.slice(0,-1),a.offset++,n=n.parent}for(;a.path.length<=this.end.path.length;){const t=this.end.path[a.path.length-1],n=t-a.offset;0!=n&&e.push(new r(a,a.getShiftedBy(n))),a.offset=t,a.path.push(0)}return e}getWalker(e={}){return e.boundaries=this,new o.a(e)}*getItems(e={}){e.boundaries=this,e.ignoreElementEnd=!0;const t=new o.a(e);for(const a of t)yield a.item}*getPositions(e={}){e.boundaries=this;const t=new o.a(e);yield t.position;for(const a of t)yield a.nextPosition}getTransformedByDelta(e){const t=[r.createFromRange(this)],a=new Set(['insert','move','remove','reinsert']);for(const n of e.operations)if(a.has(n.type))for(let a=0;a<t.length;a++){const o=t[a]._getTransformedByDocumentChange(n.type,e.type,n.targetPosition||n.position,n.howMany||n.nodes.maxOffset,n.sourcePosition);t.splice(a,1,...o),a+=o.length-1}return t}getTransformedByDeltas(e){const t=[r.createFromRange(this)];for(const a of e)for(let e=0;e<t.length;e++){const n=t[e].getTransformedByDelta(a);t.splice(e,1,...n),e+=n.length-1}for(let a=0;a<t.length;a++){const e=t[a];for(let n=a+1;n<t.length;n++){const a=t[n];(e.containsRange(a)||a.containsRange(e)||e.isEqual(a))&&t.splice(n,1)}}return t}getCommonAncestor(){return this.start.getCommonAncestor(this.end)}_getTransformedByDocumentChange(e,t,a,n,o){if('insert'==e)return this._getTransformedByInsertion(a,n,!1,!1);else{const e=r.createFromPositionAndShift(o,n);if('merge'==t&&this.isCollapsed&&(this.start.isEqual(e.start)||this.start.isEqual(e.end))){const t=this.start.offset-e.start.offset;return[new r(a.getShiftedBy(t))]}if('split'==t&&this.isCollapsed&&this.end.isEqual(e.end))return[new r(a.getShiftedBy(n))];if((e.containsPosition(this.start)||e.start.isEqual(this.start))&&this.containsPosition(e.end)&&this.end.isAfter(a)){const e=this.start._getCombined(o,a._getTransformedByDeletion(o,n)),t=this.end._getTransformedByMove(o,a,n,!1,!1);return[new r(e,t)]}if((e.containsPosition(this.end)||e.end.isEqual(this.end))&&this.containsPosition(e.start)&&this.start.isBefore(a)){const e=this.start._getTransformedByMove(o,a,n,!0,!1),t=this.end._getCombined(o,a._getTransformedByDeletion(o,n));return[new r(e,t)]}return this._getTransformedByMove(o,a,n)}}_getTransformedByInsertion(e,t,a=!1,n=!1){if(a&&this.containsPosition(e))return[new r(this.start,e),new r(e._getTransformedByInsertion(e,t,!0),this.end._getTransformedByInsertion(e,t,this.isCollapsed))];else{const a=r.createFromRange(this),o=!!a.isCollapsed||!n,i=!!a.isCollapsed||n;return a.start=a.start._getTransformedByInsertion(e,t,o),a.end=a.end._getTransformedByInsertion(e,t,i),[a]}}_getTransformedByMove(e,t,a){if(this.isCollapsed){const n=this.start._getTransformedByMove(e,t,a,!0,!1);return[new r(n)]}let n;const o=new r(e,e.getShiftedBy(a)),i=this.getDifference(o);let s=null;const l=this.getIntersection(o);1==i.length?s=new r(i[0].start._getTransformedByDeletion(e,a),i[0].end._getTransformedByDeletion(e,a)):2==i.length&&(s=new r(this.start,this.end._getTransformedByDeletion(e,a)));const d=t._getTransformedByDeletion(e,a);return n=s?s._getTransformedByInsertion(d,a,null!==l):[],l&&n.push(new r(l.start._getCombined(o.start,d),l.end._getCombined(o.start,d))),n}static createFromPositionAndShift(e,t){const a=e,n=e.getShiftedBy(t);return 0<t?new this(a,n):new this(n,a)}static createFromParentsAndOffsets(e,t,a,o){return new this(n.a.createFromParentAndOffset(e,t),n.a.createFromParentAndOffset(a,o))}static createFromRange(e){return new this(e.start,e.end)}static createIn(e){return this.createFromParentsAndOffsets(e,0,e,e.maxOffset)}static createOn(e){return this.createFromPositionAndShift(n.a.createBefore(e),e.offsetSize)}static createCollapsedAt(e,t){const a=n.a.createAt(e,t),o=n.a.createFromPosition(a);return new r(a,o)}static createFromRanges(e){if(0===e.length)throw new i.b('range-create-from-ranges-empty-array: At least one range has to be passed.');else if(1==e.length)return this.createFromRange(e[0]);const t=e[0];e.sort((e,t)=>e.start.isAfter(t.start)?1:-1);const a=e.indexOf(t),o=new this(t.start,t.end);for(let t=a-1;0<=t&&e[t].end.isEqual(o.start);t++)o.start=n.a.createFromPosition(e[t].start);for(let t=a+1;t<e.length&&e[t].start.isEqual(o.end);t++)o.end=n.a.createFromPosition(e[t].end);return o}static fromJSON(e,t){return new this(n.a.fromJSON(e.start,t),n.a.fromJSON(e.end,t))}}t.a=r},function(e,t){'use strict';t.a=function(e,...t){t.forEach((t)=>{Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t)).forEach((a)=>{if(!(a in e.prototype)){const n=Object.getOwnPropertyDescriptor(t,a);n.enumerable=!1,Object.defineProperty(e.prototype,a,n)}})})}},function(e,t,a){'use strict';function n(e){return'string'==typeof e?[new r.a(e)]:(Object(s.a)(e)||(e=[e]),Array.from(e).map((e)=>'string'==typeof e?new r.a(e):e))}var o=a(66),i=a(83),r=a(26),s=a(34);class l extends o.a{constructor(e,t,a){super(t),this.name=e,this._children=new i.a,a&&this.insertChildren(0,a)}get childCount(){return this._children.length}get maxOffset(){return this._children.maxOffset}get isEmpty(){return 0===this.childCount}is(e,t=null){return t?'element'==e&&t==this.name:'element'==e||e==this.name}getChild(e){return this._children.getNode(e)}getChildren(){return this._children[Symbol.iterator]()}getChildIndex(e){return this._children.getNodeIndex(e)}getChildStartOffset(e){return this._children.getNodeStartOffset(e)}clone(e=!1){const t=e?Array.from(this._children).map((e)=>e.clone(!0)):null;return new l(this.name,this.getAttributes(),t)}offsetToIndex(e){return this._children.offsetToIndex(e)}appendChildren(e){this.insertChildren(this.childCount,e)}insertChildren(e,t){t=n(t);for(const a of t)null!==a.parent&&a.remove(),a.parent=this;this._children.insertNodes(e,t)}removeChildren(e,t=1){const a=this._children.removeNodes(e,t);for(const n of a)n.parent=null;return a}getNodeByPath(e){let t=this;for(const a of e)t=t.getChild(t.offsetToIndex(a));return t}toJSON(){const e=super.toJSON();if(e.name=this.name,0<this._children.length){e.children=[];for(const t of this._children)e.children.push(t.toJSON())}return e}static fromJSON(e){let t=null;if(e.children){t=[];for(const a of e.children)a.name?t.push(l.fromJSON(a)):t.push(r.a.fromJSON(a))}return new l(e.name,e.attributes,t)}}t.a=l},function(e,t,a){'use strict';function n(e){return!!e&&((e.value&&(e=e.value),Array.isArray(e))?e.some(n):!!(e instanceof I))}function o(e,t){return e.map((e)=>e instanceof I?e.getValue(t):e)}function i(e,t,{node:a}){let n=o(e,a);n=1==e.length&&e[0]instanceof B?n[0]:n.reduce(h,''),k(n)?t.remove():t.set(n)}function r(e){return{set(t){e.textContent=t},remove(){e.textContent=''}}}function s(e,t,a){return{set(n){e.setAttributeNS(a,t,n)},remove(){e.removeAttributeNS(a,t)}}}function l(e,t){return{set(a){e.style[t]=a},remove(){e.style[t]=null}}}function d(e){const t=Object(O.a)(e,(e)=>{if(e&&(e instanceof I||w(e)||y(e)||v(e)))return e});return t}function c(e){if('string'==typeof e?e=p(e):e.text&&g(e),e.on&&(e.eventListeners=u(e.on),delete e.on),!e.text){e.attributes&&m(e.attributes);const t=new S.a;if(e.children)if(v(e.children))t.add(e.children);else for(const a of e.children)w(a)||y(a)?t.add(a):t.add(new F(a));e.children=t}return e}function m(e){for(const t in e)e[t].value&&(e[t].value=[].concat(e[t].value)),f(e,t)}function u(e){for(const t in e)f(e,t);return e}function p(e){return{text:[e]}}function g(e){Array.isArray(e.text)||(e.text=[e.text])}function f(e,t){Array.isArray(e[t])||(e[t]=[e[t]])}function h(e,t){return k(t)?e:k(e)?t:`${e} ${t}`}function b(e,t){for(const n in t)e[n]?e[n].push(...t[n]):e[n]=t[n]}function _(e,t){if(t.attributes&&(!e.attributes&&(e.attributes={}),b(e.attributes,t.attributes)),t.eventListeners&&(!e.eventListeners&&(e.eventListeners={}),b(e.eventListeners,t.eventListeners)),t.text&&e.text.push(...t.text),t.children&&t.children.length){if(e.children.length!=t.children.length)throw new C.b('ui-template-extend-children-mismatch: The number of children in extended definition does not match.');let a=0;for(const n of t.children)_(e.children.get(a++),n)}}function k(e){return!e&&0!==e}function y(e){return e instanceof E.a}function w(e){return e instanceof F}function v(e){return e instanceof S.a}function x(){return{children:[],bindings:[],attributes:{}}}function A(e){return'class'==e||'style'==e}var C=a(0),T=a(4),P=a(8),E=a(7),S=a(112),O=a(435),V=a(17),R=a(16);class F{constructor(e){Object.assign(this,c(d(e))),this._isRendered=!1,this._revertData=null}render(){const e=this._renderNode({intoFragment:!0});return this._isRendered=!0,e}apply(e){return this._revertData=x(),this._renderNode({node:e,isApplying:!0,revertData:this._revertData}),e}revert(e){if(!this._revertData)throw new C.b('ui-template-revert-not-applied: Attempting reverting a template which has not been applied yet.');this._revertTemplateFromNode(e,this._revertData)}static bind(e,t){return{to(a,n){return new N({eventNameOrFunction:a,attribute:a,observable:e,emitter:t,callback:n})},if(a,n,o){return new B({observable:e,emitter:t,attribute:a,valueIfTrue:n,callback:o})}}}static extend(e,t){e._isRendered&&R.a.warn('template-extend-render: Attempting to extend a template which has already been rendered.'),_(e,c(d(t)))}_renderNode(e){let t;if(t=e.node?this.tag&&this.text:this.tag?this.text:!this.text,t)throw new C.b('ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering new Node.');return this.text?this._renderText(e):this._renderElement(e)}_renderElement(e){let t=e.node;return t||(t=e.node=document.createElementNS(this.ns||'http://www.w3.org/1999/xhtml',this.tag)),this._renderAttributes(e),this._renderElementChildren(e),this._setUpListeners(e),t}_renderText(e){let t=e.node;return t?e.revertData.text=t.textContent:t=e.node=document.createTextNode(''),n(this.text)?this._bindToObservable({schema:this.text,updater:r(t),data:e}):t.textContent=this.text.join(''),t}_renderAttributes(e){let t,a,o,i;if(this.attributes){const r=e.node,l=e.revertData;for(t in this.attributes)if(o=r.getAttribute(t),a=this.attributes[t],l&&(l.attributes[t]=o),i=Object(V.a)(a[0])&&a[0].ns?a[0].ns:null,n(a)){const n=i?a[0].value:a;l&&A(t)&&n.unshift(o),this._bindToObservable({schema:n,updater:s(r,t,i),data:e})}else'style'==t&&'string'!=typeof a[0]?this._renderStyleAttribute(a[0],e):(l&&o&&A(t)&&a.unshift(o),a=a.map((e)=>e?e.value||e:e).reduce((e,t)=>e.concat(t),[]).reduce(h,''),k(a)||r.setAttributeNS(i,t,a))}}_renderStyleAttribute(e,t){const a=t.node;for(const o in e){const i=e[o];n(i)?this._bindToObservable({schema:[i],updater:l(a,o),data:t}):a.style[o]=i}}_renderElementChildren(e){const t=e.node,a=e.intoFragment?document.createDocumentFragment():t,n=e.isApplying;let o=0;for(const i of this.children)if(v(i)){if(!n){i.setParent(t);for(const e of i)a.appendChild(e.element)}}else if(y(i))n||a.appendChild(i.element);else if(n){const t=e.revertData,n=x();t.children.push(n),i._renderNode({node:a.childNodes[o++],isApplying:!0,revertData:n})}else a.appendChild(i.render());e.intoFragment&&t.appendChild(a)}_setUpListeners(e){if(this.eventListeners)for(const t in this.eventListeners){const a=this.eventListeners[t].map((a)=>{const[n,o]=t.split('@');return a.activateDomEventListener(n,o,e)});e.revertData&&e.revertData.bindings.push(a)}}_bindToObservable({schema:e,updater:t,data:a}){const n=a.revertData;i(e,t,a);const o=e.filter((e)=>!k(e)).filter((e)=>e.observable).map((n)=>n.activateAttributeListener(e,t,a));n&&n.bindings.push(o)}_revertTemplateFromNode(e,t){for(const a of t.bindings)for(const e of a)e();if(t.text)return void(e.textContent=t.text);for(const a in t.attributes){const n=t.attributes[a];null===n?e.removeAttribute(a):e.setAttribute(a,n)}for(let a=0;a<t.children.length;++a)this._revertTemplateFromNode(e.childNodes[a],t.children[a])}}t.a=F,Object(T.a)(F,P.c);class I{constructor(e){Object.assign(this,e)}getValue(e){const t=this.observable[this.attribute];return this.callback?this.callback(t,e):t}activateAttributeListener(e,t,a){const n=()=>i(e,t,a);return this.emitter.listenTo(this.observable,'change:'+this.attribute,n),()=>{this.emitter.stopListening(this.observable,'change:'+this.attribute,n)}}}class N extends I{activateDomEventListener(e,t,a){const n=(e,a)=>{(!t||a.target.matches(t))&&('function'==typeof this.eventNameOrFunction?this.eventNameOrFunction(a):this.observable.fire(this.eventNameOrFunction,a))};return this.emitter.listenTo(a.node,e,n),()=>{this.emitter.stopListening(a.node,e,n)}}}class B extends I{getValue(e){const t=super.getValue(e);return!k(t)&&(this.valueIfTrue||!0)}}},function(e,t,a){'use strict';var n=a(0),o=a(112),i=a(6),r=a(110),s=a(12),l=a(113),d=a(4),c=a(34);class m{constructor(e){this.locale=e,this.t=e&&e.t,this.set('ready',!1),this._viewCollections=new l.a,this._unboundChildren=this.createCollection(),this._viewCollections.on('add',(t,a)=>{a.locale=e})}get element(){return this._element?this._element:this.template?(this._addTemplateChildren(),this._element=this.template.render()):null}set element(e){this._element=e}get bindTemplate(){return this._bindTemplate?this._bindTemplate:this._bindTemplate=i.a.bind(this,this)}createCollection(){const e=new o.a;return this._viewCollections.add(e),e}addChildren(e){Object(c.a)(e)||(e=[e]),e.map((e)=>this._unboundChildren.add(e))}removeChildren(e){Object(c.a)(e)||(e=[e]),e.map((e)=>this._unboundChildren.remove(e))}init(){if(this.ready)throw new n.b('ui-view-init-reinit: This View has already been initialized.');this._viewCollections.map((e)=>e.init()),this.ready=!0}destroy(){this.stopListening(),this._viewCollections.map((e)=>e.destroy())}_addTemplateChildren(){const e=(t)=>{if(t.children)for(const a of t.children)a instanceof m?this.addChildren(a):e(a)};e(this.template)}}t.a=m,Object(d.a)(m,r.a),Object(d.a)(m,s.a)},function(e,t,a){'use strict';function n(e,t){e[f]||(e[f]=t||Object(u.a)())}function o(e){return e[f]}function i(e){return e._events||Object.defineProperty(e,'_events',{value:{}}),e._events}function r(){return{callbacks:[],childEvents:[]}}function s(e,t){const a=i(e);if(a[t])return;let n=t,o=null;const s=[];for(;''!==n&&!a[n];)a[n]=r(),s.push(a[n]),o&&a[n].childEvents.push(o),o=n,n=n.substr(0,n.lastIndexOf(':'));if(''!==n){for(const e of s)e.callbacks=a[n].callbacks.slice();a[n].childEvents.push(o)}}function l(e,t){const a=i(e)[t];if(!a)return[];let n=[a.callbacks];for(let o=0;o<a.childEvents.length;o++){const t=l(e,a.childEvents[o]);n=n.concat(t)}return n}function d(e,t){let a;return e._events&&(a=e._events[t])&&a.callbacks.length?a.callbacks:-1<t.indexOf(':')?d(e,t.substr(0,t.lastIndexOf(':'))):null}function c(e,t,a){for(let[n,o]of e){o?'function'==typeof o&&(o=o(t.name)):o=t.name;const e=new m.a(t.source,o);e.path=[...t.path],n.fire(e,...a)}}t.a=function(e,t){return e[g]&&e[g][t]?e[g][t].emitter:null},t.b=n;var m=a(289),u=a(52),p=a(291);const g=Symbol('listeningTo'),f=Symbol('emitterId'),h={on(e,t,a={}){s(this,e);const n=l(this,e),o=p.a.get(a.priority);t={callback:t,context:a.context||this,priority:o};for(const r of n){let e=!1;for(let a=0;a<r.length;a++)if(r[a].priority<o){r.splice(a,0,t),e=!0;break}e||r.push(t)}},once(e,t,a){this.on(e,function(e,...a){e.off(),t.call(this,e,...a)},a)},off(e,t,a){const n=l(this,e);for(const o of n)for(let e=0;e<o.length;e++)o[e].callback==t&&(a&&a!=o[e].context||(o.splice(e,1),e--))},listenTo(e,t,a,i){let r,s;this[g]||(this[g]={});const l=this[g];o(e)||n(e);const d=o(e);(r=l[d])||(r=l[d]={emitter:e,callbacks:{}}),(s=r.callbacks[t])||(s=r.callbacks[t]=[]),s.push(a),e.on(t,a,i)},stopListening(e,t,a){const n=this[g];let i=e&&o(e);const r=n&&i&&n[i],s=r&&t&&r.callbacks[t];if(n&&(!e||r)&&(!t||s))if(a)e.off(t,a);else if(s){for(;a=s.pop();)e.off(t,a);delete r.callbacks[t]}else if(r){for(t in r.callbacks)this.stopListening(e,t);delete n[i]}else{for(i in n)this.stopListening(n[i].emitter);delete this[g]}},fire(e,...t){const a=e instanceof m.a?e:new m.a(this,e),n=a.name;let o=d(this,n);if(a.path.push(this),o){const e=[a,...t];o=Array.from(o);for(let t=0;t<o.length&&(o[t].callback.apply(o[t].context,e),a.off.called&&(delete a.off.called,this.off(n,o[t].callback,o[t].context)),!a.stop.called);t++);}if(this._delegations){const e=this._delegations.get(n),o=this._delegations.get('*');e&&c(e,a,t),o&&c(o,a,t)}return a.return},delegate(...e){return{to:(t,a)=>{this._delegations||(this._delegations=new Map);for(const n of e){const e=this._delegations.get(n);e?e.set(t,a):this._delegations.set(n,new Map([[t,a]]))}}}},stopDelegating(e,t){if(this._delegations)if(!e)this._delegations.clear();else if(!t)this._delegations.delete(e);else{const a=this._delegations.get(e);a&&a.delete(t)}}};t.c=h},function(e,t,a){'use strict';var n=a(158),i=a(13),r=o;t.a=function(e,t){if('function'!=typeof e)throw new TypeError('Expected a function');return t=r(void 0===t?e.length-1:Object(i.a)(t),0),function(){for(var a=arguments,o=-1,i=r(a.length-t,0),s=Array(i);++o<i;)s[o]=a[t+o];switch(t){case 0:return e.call(this,s);case 1:return e.call(this,a[0],s);case 2:return e.call(this,a[0],a[1],s);}var l=Array(t+1);for(o=-1;++o<t;)l[o]=a[o];return l[t]=s,Object(n.a)(e,this,l)}}},function(e,t,a){'use strict';var n=a(373),o=a(380),i=a(192),r=a(15),s=a(388);t.a=function(e){return'function'==typeof e?e:null==e?i.a:'object'==typeof e?Object(r.a)(e)?Object(o.a)(e[0],e[1]):Object(n.a)(e):Object(s.a)(e)}},function(e,t,a){'use strict';var n=a(12),o=a(4);class i{constructor(e){function t(){this.isEnabled=!1}this.editor=e,this.set('value',void 0),this.set('isEnabled',!1),this.decorate('execute'),this.listenTo(this.editor.document,'changesDone',()=>{this.refresh()}),this.on('execute',(e)=>{this.isEnabled||e.stop()},{priority:'high'}),this.listenTo(e,'change:isReadOnly',(e,a,n)=>{n?(this.on('change:isEnabled',t,{priority:'lowest'}),this.isEnabled=!1):(this.off('change:isEnabled',t),this.refresh())})}refresh(){this.isEnabled=!0}execute(){}destroy(){this.stopListening()}}t.a=i,Object(o.a)(i,n.a)},function(e,t,a){'use strict';function n(e){f in e||(Object.defineProperty(e,f,{value:new Map}),Object.defineProperty(e,h,{value:new Map}),Object.defineProperty(e,b,{value:new Map}))}function o(...e){const t=r(...e),a=Array.from(this._bindings.keys()),n=a.length;if(!t.callback&&1<t.to.length)throw new u.b('observable-bind-to-no-callback: Binding multiple observables only possible with callback.');if(1<n&&t.callback)throw new u.b('observable-bind-to-extra-callback: Cannot bind multiple attributes and use a callback in one binding.');t.to.forEach((e)=>{if(e.attrs.length&&e.attrs.length!==n)throw new u.b('observable-bind-to-attrs-length: The number of attributes must match.');e.attrs.length||(e.attrs=this._bindAttrs)}),this._to=t.to,t.callback&&(this._bindings.get(a[0]).callback=t.callback),c(this._observable,this._to),l(this),this._bindAttrs.forEach((e)=>{d(this._observable,e)})}function i(e){return e.every((e)=>'string'==typeof e)}function r(...e){if(!e.length)throw new u.b('observable-bind-to-parse-error: Invalid argument syntax in `to()`.');const t={to:[]};let n;return'function'==typeof e[e.length-1]&&(t.callback=e.pop()),e.forEach((e)=>{if('string'==typeof e)n.attrs.push(e);else if('object'==typeof e)n={observable:e,attrs:[]},t.to.push(n);else throw new u.b('observable-bind-to-parse-error: Invalid argument syntax in `to()`.')}),t}function s(e,t,a,n){const o=e[h],i=o.get(a),r=i||{};r[n]||(r[n]=new Set),r[n].add(t),i||o.set(a,r)}function l(e){let t;e._bindings.forEach((a,n)=>{e._to.forEach((o)=>{t=o.attrs[a.callback?0:e._bindAttrs.indexOf(n)],a.to.push([o.observable,t]),s(e._observable,a,o.observable,t)})})}function d(e,t){const a=e[b],n=a.get(t);let o;n.callback?o=n.callback.apply(e,n.to.map((e)=>e[0][e[1]])):(o=n.to[0],o=o[0][o[1]]),e.hasOwnProperty(t)?e[t]=o:e.set(t,o)}function c(e,t){t.forEach((t)=>{const a=e[h];let n;a.get(t.observable)||e.listenTo(t.observable,'change',(o,i)=>{n=a.get(t.observable)[i],n&&n.forEach((t)=>{d(e,t.attr)})})})}var m=a(8),u=a(0),p=a(45),g=a(17);const f=Symbol('attributes'),h=Symbol('boundObservables'),b=Symbol('boundAttributes'),_={set(e,t){if(Object(g.a)(e))return void Object.keys(e).forEach((t)=>{this.set(t,e[t])},this);n(this);const a=this[f];if(e in this&&!a.has(e))throw new u.b('observable-set-cannot-override: Cannot override an existing property.');Object.defineProperty(this,e,{enumerable:!0,configurable:!0,get(){return a.get(e)},set(t){const n=a.get(e);n===t&&a.has(e)||(a.set(e,t),this.fire('change:'+e,e,t,n))}}),this[e]=t},bind(...e){if(!e.length||!i(e))throw new u.b('observable-bind-wrong-attrs: All attributes must be strings.');if(new Set(e).size!==e.length)throw new u.b('observable-bind-duplicate-attrs: Attributes must be unique.');n(this);const t=this[b];e.forEach((e)=>{if(t.has(e))throw new u.b('observable-bind-rebind: Cannot bind the same attribute more that once.')});const r=new Map;return e.forEach((e)=>{const n={attr:e,to:[]};t.set(e,n),r.set(e,n)}),{to:o,_observable:this,_bindAttrs:e,_to:[],_bindings:r}},unbind(...e){if(!(f in this))return;const t=this[b],a=this[h];if(e.length){if(!i(e))throw new u.b('observable-unbind-wrong-attrs: Attributes must be strings.');e.forEach((e)=>{const n=t.get(e);let o,i,r,s;n.to.forEach((e)=>{o=e[0],i=e[1],r=a.get(o),s=r[i],s.delete(n),s.size||delete r[i],Object.keys(r).length||(a.delete(o),this.stopListening(o,'change'))}),t.delete(e)})}else a.forEach((e,t)=>{this.stopListening(t,'change')}),a.clear(),t.clear()},decorate(e){const t=this[e];if(!t)throw new u.b('observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.',{object:this,methodName:e});this.on(e,(e,a)=>{e.return=t.apply(this,a)}),this[e]=function(...t){return this.fire(e,t)}}};t.a=_,Object(p.a)(_,m.c)},function(e,t,a){'use strict';var n=a(295);t.a=function(e){var t=Object(n.a)(e),a=t%1;return t===t?a?t-a:t:0}},function(e,t,a){'use strict';var n=a(80),o=a(44);t.a=function(e){return Object(o.a)(e)&&Object(n.a)(e)}},function(e,t){'use strict';var a=Array.isArray;t.a=a},function(e,t,a){'use strict';var n=a(0);const o={error(e,t){console.error(Object(n.a)(e),t)},warn(e,t){console.warn(Object(n.a)(e),t)}};t.a=o},function(e,t){'use strict';t.a=function(e){var t=typeof e;return!!e&&('object'==t||'function'==t)}},function(e,t){'use strict';t.a=function(e){var t=e?e.length:0;return t?e[t-1]:void 0}},function(e,t,a){'use strict';var n=a(0),o=a(360);const i=new Map;t.a=class{static fromJSON(e,t){if(!i.has(e.__className))throw new n.b('delta-fromjson-no-deserializer: This delta has no defined deserializer',{name:e.__className});const a=i.get(e.__className),r=new a;for(const a of e.operations)r.addOperation(o.a.fromJSON(a,t));for(const a in e)'__className'!=a&&void 0===r[a]&&(r[a]=e[a]);return r}static register(e){i.set(e.className,e)}}},function(e,t,a){'use strict';t.b=function(e,t){if(o.prototype[e])throw new n.b('model-batch-register-taken: This batch method name is already taken.',{name:e});o.prototype[e]=t};var n=a(0);class o{constructor(e,t='default'){this.document=e,this.deltas=[],this.type=t}get baseVersion(){return 0<this.deltas.length?this.deltas[0].baseVersion:null}addDelta(e){return e.batch=this,this.deltas.push(e),e}*getOperations(){for(const e of this.deltas)yield*e.operations}}t.a=o},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(466),r=a(467),s=a(28);class l extends n.a{constructor(e){super(e),this.set('label'),this.set('keystroke'),this.set('tooltip'),this.set('tooltipPosition','s'),this.set('type','button'),this.set('isOn',!1),this.set('isEnabled',!0),this.set('isVisible',!0),this.set('withText',!1),this.set('icon'),this.set('tabindex',-1),this.bind('_tooltipString').to(this,'tooltip',this,'label',this,'keystroke',this._getTooltipString.bind(this)),this.tooltipView=this._createTooltipView();const t=this.bindTemplate;this.template=new o.a({tag:'button',attributes:{class:['ck-button',t.to('isEnabled',(e)=>e?'ck-enabled':'ck-disabled'),t.if('isVisible','ck-hidden',(e)=>!e),t.to('isOn',(e)=>e?'ck-on':'ck-off'),t.if('withText','ck-button_with-text')],type:t.to('type',(e)=>e?e:'button'),tabindex:t.to('tabindex')},children:[{tag:'span',attributes:{class:['ck-button__label']},children:[{text:t.to('label')}]},this.tooltipView],on:{mousedown:t.to((e)=>{e.preventDefault()}),click:t.to((e)=>{this.isEnabled?this.fire('execute'):e.preventDefault()})}})}init(){if(this.icon){const e=this.iconView=new i.a;e.bind('content').to(this,'icon'),this.element.insertBefore(e.element,this.element.firstChild),this.addChildren(e)}super.init()}focus(){this.element.focus()}_createTooltipView(){const e=new r.a;return e.bind('text').to(this,'_tooltipString'),e.bind('position').to(this,'tooltipPosition'),e}_getTooltipString(e,t,a){return e?'string'==typeof e?e:(a&&(a=Object(s.b)(a)),e instanceof Function?e(t,a):`${t}${a?` (${a})`:''}`):''}}t.a=l},function(e,t,a){'use strict';var n=a(68),o=a(55),i=a(0),r=a(91);class s{constructor(e,t){this.parent=e,this.offset=t}get nodeAfter(){return this.parent.is('text')?null:this.parent.getChild(this.offset)||null}get nodeBefore(){return this.parent.is('text')?null:this.parent.getChild(this.offset-1)||null}get isAtStart(){return 0===this.offset}get isAtEnd(){const e=this.parent.is('text')?this.parent.data.length:this.parent.childCount;return this.offset===e}get root(){return this.parent.root}get editableElement(){let e=this.parent;for(;!(e instanceof r.a);)if(e.parent)e=e.parent;else return null;return e}getShiftedBy(e){const t=s.createFromPosition(this),a=t.offset+e;return t.offset=0>a?0:a,t}getLastMatchingPosition(e,t={}){t.startPosition=this;const a=new n.a(t);return a.skip(e),a.position}getAncestors(){return this.parent.is('documentFragment')?[this.parent]:this.parent.getAncestors({includeSelf:!0})}getCommonAncestor(e){const t=this.getAncestors(),a=e.getAncestors();let n=0;for(;t[n]==a[n]&&t[n];)n++;return 0==n?null:t[n-1]}isEqual(e){return this.parent==e.parent&&this.offset==e.offset}isBefore(e){return'before'==this.compareWith(e)}isAfter(e){return'after'==this.compareWith(e)}compareWith(e){if(this.isEqual(e))return'same';if(this.parent===e.parent)return 0>this.offset-e.offset?'before':'after';const t=this.getAncestors(),a=e.getAncestors(),n=Object(o.a)(t,a);let i;switch(n){case 0:return'different';case'prefix':i=t.length-1;break;case'extension':i=a.length-1;break;default:i=n-1;}const r=t[i],s=t[i+1],l=a[i+1];if(r===this.parent){const e=this.offset-l.index;return 0>=e?'before':'after'}if(r===e.parent){const t=s.index-e.offset;return 0>t?'before':'after'}const d=s.index-l.index;return 0>d?'before':'after'}static createAt(e,t){if(e instanceof s)return this.createFromPosition(e);else{const a=e;if('end'==t)t=a.is('text')?a.data.length:a.childCount;else{if('before'==t)return this.createBefore(a);if('after'==t)return this.createAfter(a);t||(t=0)}return new s(a,t)}}static createAfter(e){if(e.is('textProxy'))return new s(e.textNode,e.offsetInText+e.data.length);if(!e.parent)throw new i.b('view-position-after-root: You can not make position after root.',{root:e});return new s(e.parent,e.index+1)}static createBefore(e){if(e.is('textProxy'))return new s(e.textNode,e.offsetInText);if(!e.parent)throw new i.b('view-position-before-root: You can not make position before root.',{root:e});return new s(e.parent,e.index)}static createFromPosition(e){return new this(e.parent,e.offset)}}t.a=s},function(e,t,a){'use strict';function n(e,t){t=i(t);const a=t.reduce((e,t)=>e+t.offsetSize,0),n=e.parent;s(e);const o=e.index;return n.insertChildren(o,t),r(n,o+t.length),r(n,o),new u.a(e,e.getShiftedBy(a))}function o(e){if(!e.isFlat)throw new f.b('model-writer-remove-range-not-flat: Trying to remove a range which starts and ends in different element.');const t=e.start.parent;s(e.start),s(e.end);const a=t.removeChildren(e.start.index,e.end.index-e.start.index);return r(t,e.start.index),a}function i(e){const t=[];e instanceof Array||(e=[e]);for(let a=0;a<e.length;a++)if('string'==typeof e[a])t.push(new c.a(e[a]));else if(e[a]instanceof m.a)t.push(new c.a(e[a].data,e[a].getAttributes()));else if(e[a]instanceof p.a||e[a]instanceof g.a)for(const n of e[a])t.push(n);else e[a]instanceof d.a&&t.push(e[a]);for(let a=1;a<t.length;a++){const e=t[a],n=t[a-1];e instanceof c.a&&n instanceof c.a&&l(e,n)&&(t.splice(a-1,2,new c.a(n.data+e.data,n.getAttributes())),a--)}return t}function r(e,t){const a=e.getChild(t-1),n=e.getChild(t);if(a&&n&&a.is('text')&&n.is('text')&&l(a,n)){const o=new c.a(a.data+n.data,a.getAttributes());e.removeChildren(t-1,2),e.insertChildren(t-1,o)}}function s(e){const t=e.textNode,a=e.parent;if(t){const n=e.offset-t.startOffset,o=t.index;a.removeChildren(o,1);const i=new c.a(t.data.substr(0,n),t.getAttributes()),r=new c.a(t.data.substr(n),t.getAttributes());a.insertChildren(o,[i,r])}}function l(e,t){const a=e.getAttributes(),n=t.getAttributes();for(const o of a){if(o[1]!==t.getAttribute(o[0]))return!1;n.next()}return n.next().done}t.b=n,t.d=o,t.c=i;var d=a(66),c=a(26),m=a(67),u=a(3),p=a(39),g=a(83),f=a(0);t.a={insert:n,remove:o,move:function(e,t){if(!e.isFlat)throw new f.b('model-writer-move-range-not-flat: Trying to move a range which starts and ends in different element.');const a=this.remove(e);return t=t._getTransformedByDeletion(e.start,e.end.offset-e.start.offset),this.insert(t,a)},setAttribute:function(e,t,a){s(e.start),s(e.end);for(const n of e.getItems()){const e=n.is('textProxy')?n.textNode:n;null===a?e.removeAttribute(t):e.setAttribute(t,a),r(e.parent,e.index)}r(e.end.parent,e.end.index)},removeAttribute:function(e,t){this.setAttribute(e,t,null)},normalizeNodes:i}},function(e,t,a){'use strict';var n=a(69),o=a(19);class i{constructor(){this.batch=null,this.operations=[]}get baseVersion(){return 0<this.operations.length?this.operations[0].baseVersion:null}set baseVersion(e){for(const t of this.operations)t.baseVersion=e++}get _reverseDeltaClass(){return i}addOperation(e){return e.delta=this,this.operations.push(e),e}clone(){const e=new this.constructor;for(const t of this.operations)e.addOperation(t.clone());return e}getReversed(){const e=new this._reverseDeltaClass;for(const t of this.operations)e.addOperation(t.getReversed());e.operations.reverse();for(let t=0;t<e.operations.length;t++)e.operations[t].baseVersion=this.operations[this.operations.length-1].baseVersion+t+1;return e}toJSON(){const e=Object(n.a)(this);return e.__className=this.constructor.className,delete e.batch,e}static get className(){return'engine.model.delta.Delta'}}t.a=i,o.a.register(i)},function(e,t,a){'use strict';function n(e,t,a,r,s){var l=-1,d=e.length;for(a||(a=i.a),s||(s=[]);++l<d;){var c=e[l];0<t&&a(c)?1<t?n(c,t-1,a,r,s):Object(o.a)(s,c):!r&&(s[s.length]=c)}return s}var o=a(89),i=a(372);t.a=n},function(e,t,a){'use strict';var n=a(66);class o extends n.a{constructor(e,t){super(t),this.data=e||''}get offsetSize(){return this.data.length}is(e){return'text'==e}clone(){return new o(this.data,this.getAttributes())}toJSON(){const e=super.toJSON();return e.data=this.data,e}static fromJSON(e){return new o(e.data,e.attributes)}}t.a=o},function(e,t,a){'use strict';function n(e,t){let a=null,n=0,o=0,r=null;if(e.clear(),''!==t){';'!=t.charAt(t.length-1)&&(t+=';');for(let s=0;s<t.length;s++){const i=t.charAt(s);if(null==a)switch(i){case':':r||(r=t.substr(n,s-n),o=s+1);break;case'"':case'\'':a=i;break;case';':const l=t.substr(o,s-o);r&&e.set(r.trim(),l.trim()),r=null,n=s+1;}else i===a&&(a=null)}}}function o(e,t){const a=t.split(/\s+/);e.clear(),a.forEach((t)=>e.add(t))}function i(e){return'string'==typeof e?[new s.a(e)]:(Object(d.a)(e)||(e=[e]),Array.from(e).map((e)=>'string'==typeof e?new s.a(e):e))}var r=a(84),s=a(35),l=a(164),d=a(34),c=a(77),m=a(175);class u extends r.a{constructor(e,t,a){if(super(),this.name=e,this._attrs=Object(c.a)(t)?Object(l.a)(t):new Map(t),this._children=[],a&&this.insertChildren(0,a),this._classes=new Set,this._attrs.has('class')){const e=this._attrs.get('class');o(this._classes,e),this._attrs.delete('class')}this._styles=new Map,this._attrs.has('style')&&(n(this._styles,this._attrs.get('style')),this._attrs.delete('style')),this._customProperties=new Map}get childCount(){return this._children.length}get isEmpty(){return 0===this._children.length}is(e,t=null){return t?'element'==e&&t==this.name:'element'==e||e==this.name}clone(e=!1){const t=[];if(e)for(const a of this.getChildren())t.push(a.clone(e));const a=new this.constructor(this.name,this._attrs,t);return a._classes=new Set(this._classes),a._styles=new Map(this._styles),a._customProperties=new Map(this._customProperties),a.getFillerOffset=this.getFillerOffset,a}appendChildren(e){return this.insertChildren(this.childCount,e)}getChild(e){return this._children[e]}getChildIndex(e){return this._children.indexOf(e)}getChildren(){return this._children[Symbol.iterator]()}*getAttributeKeys(){0<this._classes.size&&(yield'class'),0<this._styles.size&&(yield'style');for(const e of this._attrs.keys())yield e}*getAttributes(){yield*this._attrs.entries(),0<this._classes.size&&(yield['class',this.getAttribute('class')]),0<this._styles.size&&(yield['style',this.getAttribute('style')])}getAttribute(e){if('class'==e)return 0<this._classes.size?[...this._classes].join(' '):void 0;if('style'==e){if(0<this._styles.size){let e='';for(const[t,a]of this._styles)e+=`${t}:${a};`;return e}return}return this._attrs.get(e)}hasAttribute(e){return'class'==e?0<this._classes.size:'style'==e?0<this._styles.size:this._attrs.has(e)}setAttribute(e,t){this._fireChange('attributes',this),'class'==e?o(this._classes,t):'style'==e?n(this._styles,t):this._attrs.set(e,t)}insertChildren(e,t){this._fireChange('children',this);let a=0;t=i(t);for(const n of t)null!==n.parent&&n.remove(),n.parent=this,this._children.splice(e,0,n),e++,a++;return a}removeAttribute(e){return this._fireChange('attributes',this),'class'==e?!!(0<this._classes.size)&&(this._classes.clear(),!0):'style'==e?!!(0<this._styles.size)&&(this._styles.clear(),!0):this._attrs.delete(e)}removeChildren(e,t=1){this._fireChange('children',this);for(let a=e;a<e+t;a++)this._children[a].parent=null;return this._children.splice(e,t)}isSimilar(e){if(!(e instanceof u))return!1;if(this===e)return!0;if(this.name!=e.name)return!1;if(this._attrs.size!==e._attrs.size||this._classes.size!==e._classes.size||this._styles.size!==e._styles.size)return!1;for(const[t,a]of this._attrs)if(!e._attrs.has(t)||e._attrs.get(t)!==a)return!1;for(const t of this._classes)if(!e._classes.has(t))return!1;for(const[t,a]of this._styles)if(!e._styles.has(t)||e._styles.get(t)!==a)return!1;return!0}addClass(...e){this._fireChange('attributes',this),e.forEach((e)=>this._classes.add(e))}removeClass(...e){this._fireChange('attributes',this),e.forEach((e)=>this._classes.delete(e))}hasClass(...e){for(const t of e)if(!this._classes.has(t))return!1;return!0}getClassNames(){return this._classes.keys()}setStyle(e,t){if(this._fireChange('attributes',this),Object(c.a)(e)){const t=Object.keys(e);for(const a of t)this._styles.set(a,e[a])}else this._styles.set(e,t)}getStyle(e){return this._styles.get(e)}getStyleNames(){return this._styles.keys()}hasStyle(...e){for(const t of e)if(!this._styles.has(t))return!1;return!0}removeStyle(...e){this._fireChange('attributes',this),e.forEach((e)=>this._styles.delete(e))}findAncestor(...e){const t=new m.a(...e);for(let a=this.parent;a;){if(t.match(a))return a;a=a.parent}return null}setCustomProperty(e,t){this._customProperties.set(e,t)}getCustomProperty(e){return this._customProperties.get(e)}removeCustomProperty(e){return this._customProperties.delete(e)}*getCustomProperties(){yield*this._customProperties.entries()}getIdentity(){const e=Array.from(this._classes).sort().join(','),t=Array.from(this._styles).map((e)=>`${e[0]}:${e[1]}`).sort().join(';'),a=Array.from(this._attrs).map((e)=>`${e[0]}="${e[1]}"`).sort().join(' ');return this.name+(''==e?'':` class="${e}"`)+(''==t?'':` style="${t}"`)+(''==a?'':` ${a}`)}}t.a=u},function(e,t,a){'use strict';function n(e){let t;if('string'!=typeof e)t=e.keyCode+(e.altKey?s.alt:0)+(e.ctrlKey?s.ctrl:0)+(e.shiftKey?s.shift:0);else if(t=s[e.toLowerCase()],!t)throw new i.b('keyboard-unknown-key: Unknown key name.',{key:e});return t}function o(e){return e.split(/\s*\+\s*/)}t.a=n,t.d=function(e){return'string'==typeof e&&(e=o(e)),e.map((e)=>'string'==typeof e?n(e):e).reduce((e,t)=>t+e,0)},t.b=function(e){const t=o(e);return r.a.mac&&'ctrl'==t[0].toLowerCase()?'\u2318'+(t[1]||''):e};var i=a(0),r=a(350);const s=function(){const e={arrowleft:37,arrowup:38,arrowright:39,arrowdown:40,backspace:8,delete:46,enter:13,space:32,esc:27,tab:9,ctrl:1114112,cmd:1114112,shift:2228224,alt:4456448};for(let t=65;90>=t;t++){const a=String.fromCharCode(t);e[a.toLowerCase()]=t}for(let t=48;57>=t;t++)e[t-48]=t;for(let t=112;123>=t;t++)e['f'+(t-111)]=t;return e}();t.c=s},function(e,t,a){'use strict';var n=a(40),o=a(1),i=a(3),r=a(0),s=a(55),l=a(23);class d extends n.a{constructor(e,t,a,n){super(n),this.sourcePosition=o.a.createFromPosition(e),this.howMany=t,this.targetPosition=o.a.createFromPosition(a),this.isSticky=!1}get type(){return'move'}clone(){const e=new this.constructor(this.sourcePosition,this.howMany,this.targetPosition,this.baseVersion);return e.isSticky=this.isSticky,e}getMovedRangeStart(){return this.targetPosition._getTransformedByDeletion(this.sourcePosition,this.howMany)}getReversed(){const e=this.sourcePosition._getTransformedByInsertion(this.targetPosition,this.howMany),t=new this.constructor(this.getMovedRangeStart(),this.howMany,e,this.baseVersion+1);return t.isSticky=this.isSticky,t}_execute(){const e=this.sourcePosition.parent,t=this.targetPosition.parent,a=this.sourcePosition.offset,n=this.targetPosition.offset;if(!e||!t)throw new r.b('move-operation-position-invalid: Source position or target position is invalid.');else if(a+this.howMany>e.maxOffset)throw new r.b('move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.');else if(e===t&&a<n&&n<a+this.howMany)throw new r.b('move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.');else if(this.sourcePosition.root==this.targetPosition.root&&'prefix'==Object(s.a)(this.sourcePosition.getParentPath(),this.targetPosition.getParentPath())){const e=this.sourcePosition.path.length-1;if(this.targetPosition.path[e]>=a&&this.targetPosition.path[e]<a+this.howMany)throw new r.b('move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.')}const o=l.a.move(i.a.createFromPositionAndShift(this.sourcePosition,this.howMany),this.targetPosition);return{sourcePosition:this.sourcePosition,range:o}}static get className(){return'engine.model.operation.MoveOperation'}static fromJSON(e,t){const a=o.a.fromJSON(e.sourcePosition,t),n=o.a.fromJSON(e.targetPosition,t),i=new this(a,e.howMany,n,e.baseVersion);return e.isSticky&&(i.isSticky=!0),i}}t.a=d},function(e,t){'use strict';t.a=function(e,t){for(var a=-1,n=e.length,o=Array(n);++a<n;)o[a]=t(e[a],a,e);return o}},function(e){function t(e,t){var n=e[1]||'',o=e[3];if(!o)return n;if(t&&'function'==typeof btoa){var i=a(o),r=o.sources.map(function(e){return'/*# sourceURL='+o.sourceRoot+e+' */'});return[n].concat(r).concat([i]).join('\n')}return[n].join('\n')}function a(e){var t=btoa(unescape(encodeURIComponent(JSON.stringify(e))));return'/*# '+('sourceMappingURL=data:application/json;charset=utf-8;base64,'+t)+' */'}e.exports=function(e){var a=[];return a.toString=function(){return this.map(function(a){var n=t(a,e);return a[2]?'@media '+a[2]+'{'+n+'}':n}).join('')},a.i=function(e,t){'string'==typeof e&&(e=[[null,e,'']]);for(var n={},o=0,i;o<this.length;o++)i=this[o][0],'number'==typeof i&&(n[i]=!0);for(o=0;o<e.length;o++){var r=e[o];'number'==typeof r[0]&&n[r[0]]||(t&&!r[2]?r[2]=t:t&&(r[2]='('+r[2]+') and ('+t+')'),a.push(r))}},a}},function(e,t,a){function n(e,t){for(var a=0;a<e.length;a++){var n=e[a],o=g[n.id];if(o){o.refs++;for(var i=0;i<o.parts.length;i++)o.parts[i](n.parts[i]);for(;i<n.parts.length;i++)o.parts.push(c(n.parts[i],t))}else{for(var r=[],i=0;i<n.parts.length;i++)r.push(c(n.parts[i],t));g[n.id]={id:n.id,refs:1,parts:r}}}}function o(e,t){for(var a=[],n={},o=0;o<e.length;o++){var i=e[o],r=t.base?i[0]+t.base:i[0],s=i[1],l=i[2],d=i[3],c={css:s,media:l,sourceMap:d};n[r]?n[r].parts.push(c):a.push(n[r]={id:r,parts:[c]})}return a}function i(e,t){var a=h(e.insertInto);if(!a)throw new Error('Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.');var n=k[k.length-1];if('top'===e.insertAt)n?n.nextSibling?a.insertBefore(t,n.nextSibling):a.appendChild(t):a.insertBefore(t,a.firstChild),k.push(t);else if('bottom'===e.insertAt)a.appendChild(t);else throw new Error('Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.')}function r(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var t=k.indexOf(e);0<=t&&k.splice(t,1)}function s(e){var t=document.createElement('style');return e.attrs.type='text/css',d(t,e.attrs),i(e,t),t}function l(e){var t=document.createElement('link');return e.attrs.type='text/css',e.attrs.rel='stylesheet',d(t,e.attrs),i(e,t),t}function d(e,t){Object.keys(t).forEach(function(a){e.setAttribute(a,t[a])})}function c(e,t){var a,n,o,i;if(t.transform&&e.css)if(i=t.transform(e.css),i)e.css=i;else return function(){};if(t.singleton){var d=_++;a=b||(b=s(t)),n=m.bind(null,a,d,!1),o=m.bind(null,a,d,!0)}else e.sourceMap&&'function'==typeof URL&&'function'==typeof URL.createObjectURL&&'function'==typeof URL.revokeObjectURL&&'function'==typeof Blob&&'function'==typeof btoa?(a=l(t),n=p.bind(null,a,t),o=function(){r(a),a.href&&URL.revokeObjectURL(a.href)}):(a=s(t),n=u.bind(null,a),o=function(){r(a)});return n(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;n(e=t)}else o()}}function m(e,t,a,n){var o=a?'':n.css;if(e.styleSheet)e.styleSheet.cssText=w(t,o);else{var i=document.createTextNode(o),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(i,r[t]):e.appendChild(i)}}function u(e,t){var a=t.css,n=t.media;if(n&&e.setAttribute('media',n),e.styleSheet)e.styleSheet.cssText=a;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(a))}}function p(e,t,a){var n=a.css,o=a.sourceMap,i=t.convertToAbsoluteUrls===void 0&&o;(t.convertToAbsoluteUrls||i)&&(n=y(n)),o&&(n+='\n/*# sourceMappingURL=data:application/json;base64,'+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+' */');var r=new Blob([n],{type:'text/css'}),s=e.href;e.href=URL.createObjectURL(r),s&&URL.revokeObjectURL(s)}var g={},f=function(e){var t;return function(){return'undefined'==typeof t&&(t=e.apply(this,arguments)),t}}(function(){return window&&document&&document.all&&!window.atob}),h=function(e){var t={};return function(a){return'undefined'==typeof t[a]&&(t[a]=e.call(this,a)),t[a]}}(function(e){return document.querySelector(e)}),b=null,_=0,k=[],y=a(444);e.exports=function(e,t){if('undefined'!=typeof DEBUG&&DEBUG&&'object'!=typeof document)throw new Error('The style-loader cannot be used in a non-browser environment');t=t||{},t.attrs='object'==typeof t.attrs?t.attrs:{},t.singleton||(t.singleton=f()),t.insertInto||(t.insertInto='head'),t.insertAt||(t.insertAt='bottom');var a=o(e,t);return n(a,t),function(e){for(var r=[],s=0;s<a.length;s++){var i=a[s],l=g[i.id];l.refs--,r.push(l)}if(e){var d=o(e,t);n(d,t)}for(var s=0,l;s<r.length;s++)if(l=r[s],0===l.refs){for(var c=0;c<l.parts.length;c++)l.parts[c]();delete g[l.id]}}};var w=function(){var e=[];return function(t,a){return e[t]=a,e.filter(Boolean).join('\n')}}()},function(e,t,a){'use strict';(function(e,n){var o=a(300),i={function:!0,object:!0},r=i[typeof exports]&&exports&&!exports.nodeType?exports:void 0,s=i[typeof e]&&e&&!e.nodeType?e:void 0,l=Object(o.a)(r&&s&&'object'==typeof n&&n),d=Object(o.a)(i[typeof self]&&self),c=Object(o.a)(i[typeof window]&&window),m=Object(o.a)(i[typeof this]&&this),u=l||c!==(m&&m.window)&&c||d||m||Function('return this')();t.a=u}).call(t,a(160)(e),a(299))},function(e,t){'use strict';t.a=function(e){return!!(e&&e[Symbol.iterator])}},function(e,t,a){'use strict';var n=a(84);class o extends n.a{constructor(e){super(),this._data=e}clone(){return new o(this.data)}is(e){return'text'==e}get data(){return this._data}set data(e){this._fireChange('text',this),this._data=e}isSimilar(e){return!!(e instanceof o)&&(this===e||this.data===e.data)}}t.a=o},function(e,t,a){'use strict';function n(e){return!!e.getCustomProperty(r)&&Object(o.c)(e)}t.c=function(e,t){return e.setCustomProperty(r,!0),Object(o.d)(e,{label:function(){const a=e.getChild(0),n=a.getAttribute('alt');return n?`${n} ${t}`:t}})},t.b=function(e){const t=e.getSelectedElement();return!!(t&&n(t))},t.a=function(e){return e instanceof i.a&&'image'==e.name};var o=a(156),i=a(5);const r=Symbol('isImage')},function(e,t){'use strict';var a=/^(?:0|[1-9]\d*)$/;t.a=function(e,t){return t=null==t?9007199254740991:t,!!t&&('number'==typeof e||a.test(e))&&-1<e&&0==e%1&&e<t}},function(e,t,a){'use strict';function n(e){return e.item.is('attributeElement')||e.item.is('uiElement')}var o=a(22),i=a(68);class r{constructor(e,t=null){this.start=o.a.createFromPosition(e),this.end=t?o.a.createFromPosition(t):o.a.createFromPosition(e)}*[Symbol.iterator](){yield*new i.a({boundaries:this,ignoreElementEnd:!0})}get isCollapsed(){return this.start.isEqual(this.end)}get isFlat(){return this.start.parent===this.end.parent}get root(){return this.start.root}getEnlarged(){let e=this.start.getLastMatchingPosition(n,{direction:'backward'}),t=this.end.getLastMatchingPosition(n);return e.parent.is('text')&&e.isAtStart&&(e=o.a.createBefore(e.parent)),t.parent.is('text')&&t.isAtEnd&&(t=o.a.createAfter(t.parent)),new r(e,t)}getTrimmed(){let e=this.start.getLastMatchingPosition(n);if(e.isAfter(this.end)||e.isEqual(this.end))return new r(e,e);let t=this.end.getLastMatchingPosition(n,{direction:'backward'});const a=e.nodeAfter,i=t.nodeBefore;return a&&a.is('text')&&(e=new o.a(a,0)),i&&i.is('text')&&(t=new o.a(i,i.data.length)),new r(e,t)}isEqual(e){return this==e||this.start.isEqual(e.start)&&this.end.isEqual(e.end)}containsPosition(e){return e.isAfter(this.start)&&e.isBefore(this.end)}containsRange(e,t=!1){e.isCollapsed&&(t=!1);const a=this.containsPosition(e.start)||t&&this.start.isEqual(e.start),n=this.containsPosition(e.end)||t&&this.end.isEqual(e.end);return a&&n}getDifference(e){const t=[];return this.isIntersecting(e)?(this.containsPosition(e.start)&&t.push(new r(this.start,e.start)),this.containsPosition(e.end)&&t.push(new r(e.end,this.end))):t.push(r.createFromRange(this)),t}getIntersection(e){if(this.isIntersecting(e)){let t=this.start,a=this.end;return this.containsPosition(e.start)&&(t=e.start),this.containsPosition(e.end)&&(a=e.end),new r(t,a)}return null}getWalker(e={}){return e.boundaries=this,new i.a(e)}getCommonAncestor(){return this.start.getCommonAncestor(this.end)}*getItems(e={}){e.boundaries=this,e.ignoreElementEnd=!0;const t=new i.a(e);for(const a of t)yield a.item}*getPositions(e={}){e.boundaries=this;const t=new i.a(e);yield t.position;for(const a of t)yield a.nextPosition}isIntersecting(e){return this.start.isBefore(e.end)&&this.end.isAfter(e.start)}static createFromParentsAndOffsets(e,t,a,n){return new this(new o.a(e,t),new o.a(a,n))}static createFromRange(e){return new this(e.start,e.end)}static createFromPositionAndShift(e,t){const a=e,n=e.getShiftedBy(t);return 0<t?new this(a,n):new this(n,a)}static createIn(e){return this.createFromParentsAndOffsets(e,0,e,e.childCount)}static createOn(e){return this.createFromPositionAndShift(o.a.createBefore(e),1)}static createCollapsedAt(e,t){const a=o.a.createAt(e,t),n=o.a.createFromPosition(a);return new r(a,n)}}t.a=r},function(e,t,a){'use strict';function n(e){return'string'==typeof e?[new r.a(e)]:(Object(s.a)(e)||(e=[e]),Array.from(e).map((e)=>'string'==typeof e?new r.a(e):e))}var o=a(83),i=a(5),r=a(26),s=a(34);class l{constructor(e){this.markers=new Map,this._children=new o.a,e&&this.insertChildren(0,e)}[Symbol.iterator](){return this.getChildren()}get childCount(){return this._children.length}get maxOffset(){return this._children.maxOffset}get isEmpty(){return 0===this.childCount}get root(){return this}get parent(){return null}is(e){return'documentFragment'==e}getChild(e){return this._children.getNode(e)}getChildren(){return this._children[Symbol.iterator]()}getChildIndex(e){return this._children.getNodeIndex(e)}getChildStartOffset(e){return this._children.getNodeStartOffset(e)}getPath(){return[]}getNodeByPath(e){let t=this;for(const a of e)t=t.getChild(t.offsetToIndex(a));return t}offsetToIndex(e){return this._children.offsetToIndex(e)}appendChildren(e){this.insertChildren(this.childCount,e)}insertChildren(e,t){t=n(t);for(const a of t)null!==a.parent&&a.remove(),a.parent=this;this._children.insertNodes(e,t)}removeChildren(e,t=1){const a=this._children.removeNodes(e,t);for(const n of a)n.parent=null;return a}toJSON(){const e=[];for(const t of this._children)e.push(t.toJSON());return e}static fromJSON(e){const t=[];for(const a of e)a.name?t.push(i.a.fromJSON(a)):t.push(r.a.fromJSON(a));return new l(t)}}t.a=l},function(e,t,a){'use strict';var n=a(69);class o{constructor(e){this.baseVersion=e}toJSON(){const e=Object(n.a)(this,!0);return e.__className=this.constructor.className,delete e.delta,e}static get className(){return'engine.model.operation.Operation'}static fromJSON(e){return new this(e.baseVersion)}}t.a=o},function(e,t,a){'use strict';var n=a(29),o=a(98);class i extends n.a{get type(){return'remove'}getReversed(){const e=this.sourcePosition._getTransformedByInsertion(this.targetPosition,this.howMany);return new o.a(this.getMovedRangeStart(),this.howMany,e,this.baseVersion+1)}static get className(){return'engine.model.operation.RemoveOperation'}}t.a=i},function(e,t){'use strict';t.a=function(e,t,a){var n=-1,o=e.length;0>t&&(t=-t>o?0:o+t),a=a>o?o:a,0>a&&(a+=o),o=t>a?0:a-t>>>0,t>>>=0;for(var i=Array(o);++n<o;)i[n]=e[n+t];return i}},function(e,t,a){'use strict';function n(e,t,a,o){if(Object(d.a)(e)){for(const i of e)n(i,t,a,o);return}const i=Array.from(e.getAttributeKeys());i.push(t.key);const r={name:e.name||'$text',attributes:i,inside:a.context};o.schema.check(r)&&e.setAttribute(t.key,t.value)}t.a=function(){return new c};var o=a(175),i=a(5),r=a(1),s=a(23),l=a(0),d=a(34);class c{constructor(){this._dispatchers=[],this._from=[]}for(...e){return this._dispatchers=e,this}fromElement(e){return this.from({name:e})}fromAttribute(e,t=/.*/){const a={};'style'===e||'class'===e?a[e]=t:(a.attribute={},a.attribute[e]=t);const n=new o.a(a);return this._from.push({matcher:n,consume:!1,priority:null,attributeKey:e}),this}from(e){return e instanceof o.a||(e=new o.a(e)),this._from.push({matcher:e,consume:!1,priority:null}),this}consuming(e){const t=this._from[this._from.length-1];return t.consume=e,this}withPriority(e){const t=this._from[this._from.length-1];return t.priority=e,this}toElement(e){this._setCallback(function(t){return(a,n,o,l)=>{const d=t.matcher.matchAll(n.input);if(d)for(const a of d){const d=e instanceof Function?e(n.input):new i.a(e);if(!d)continue;const c=Array.from(d.getAttributeKeys());if(!l.schema.check({name:d.name,attributes:c,inside:n.context}))continue;if(!o.consume(n.input,t.consume||a.match))continue;n.context.push(d);const m=l.convertChildren(n.input,o,n),u=r.a.createAt(d,'end');s.a.insert(u,m),n.context.pop(),n.output=d;break}}},'normal')}toAttribute(e,t){this._setCallback(function(a){return(o,i,r,s)=>{const l=a.matcher.matchAll(i.input);if(l)for(const o of l){if(!r.consume(i.input,a.consume||o.match))continue;i.output||(i.output=s.convertChildren(i.input,r,i));let l;if(!(e instanceof Function))l={key:e,value:t?t:i.input.getAttribute(a.attributeKey)};else if(l=e(i.input),!l)return;n(i.output,l,i,s);break}}},'low')}toMarker(e){this._setCallback(function(t){return(a,n,o)=>{const r=t.matcher.matchAll(n.input);if(!r)return;let s;if(s=e instanceof Function?e(n.input):new i.a('$marker',{"data-name":n.input.getAttribute('data-name')}),'$marker'!=s.name||'string'!=typeof s.getAttribute('data-name'))throw new l.b('build-view-converter-invalid-marker: Invalid model element to mark marker range.');for(const e of r)if(o.consume(n.input,t.consume||e.match)){n.output=s;break}}},'normal')}_setCallback(e,t){for(const a of this._from){const n=a.matcher.getElementName(),o=n?'element:'+n:'element',i=e(a),r=null===a.priority?t:a.priority;for(const e of this._dispatchers)e.on(o,i,{priority:r})}}}},function(e,t){'use strict';t.a=function(e){return!!e&&'object'==typeof e}},function(e,t,a){'use strict';var n=a(292);a.d(t,'a',function(){return n.a})},function(e,t,a){'use strict';var n=a(44),o=Object.prototype,i=o.toString;t.a=function(e){return'symbol'==typeof e||Object(n.a)(e)&&i.call(e)=='[object Symbol]'}},function(e,t,a){'use strict';function n(){for(const e of this.getChildren())if(!e.is('uiElement'))return null;return this.childCount}var o=a(27);class i extends o.a{constructor(e,t,a){super(e,t,a),this.getFillerOffset=n}is(e,t=null){return t?'containerElement'==e&&t==this.name||super.is(e,t):'containerElement'==e||super.is(e)}}t.a=i},function(e,t,a){'use strict';var n=a(40),o=a(1),i=a(83),r=a(41),s=a(23),l=a(26),d=a(5);class c extends n.a{constructor(e,t,a){super(a),this.position=o.a.createFromPosition(e),this.nodes=new i.a(Object(s.c)(t))}get type(){return'insert'}clone(){const e=new i.a([...this.nodes].map((e)=>e.clone(!0)));return new c(this.position,e,this.baseVersion)}getReversed(){const e=this.position.root.document.graveyard,t=new o.a(e,[0]);return new r.a(this.position,this.nodes.maxOffset,t,this.baseVersion+1)}_execute(){const e=this.nodes;this.nodes=new i.a([...e].map((e)=>e.clone(!0)));const t=Object(s.b)(this.position,e);return{range:t}}static get className(){return'engine.model.operation.InsertOperation'}static fromJSON(e,t){const a=[];for(const n of e.nodes)n.name?a.push(d.a.fromJSON(n)):a.push(l.a.fromJSON(n));return new c(o.a.fromJSON(e.position,t),a,e.baseVersion)}}t.a=c},function(e,t,a){'use strict';var n=a(97),o=a(135),i=a(137),r=a(139),s=a(398),l=a(90);t.a=function(e,t,a){var d=-1,c=o.a,m=e.length,u=!0,p=[],g=p;if(a)u=!1,c=i.a;else if(m>=200){var f=t?null:Object(s.a)(e);if(f)return Object(l.a)(f);u=!1,c=r.a,g=new n.a}else g=t?[]:p;outer:for(;++d<m;){var h=e[d],b=t?t(h):h;if(h=a||0!==h?h:0,u&&b===b){for(var _=g.length;_--;)if(g[_]===b)continue outer;t&&g.push(b),p.push(h)}else c(g,b,a)||(g!==p&&g.push(b),p.push(h))}return p}},function(e,t,a){'use strict';var n=a(110),o=a(28);t.a=class{constructor(){this._listener=Object.create(n.a)}listenTo(e){this._listener.listenTo(e,'keydown',(e,t)=>{this._listener.fire('_keydown:'+Object(o.a)(t),t)})}set(e,t,a={}){const n=Object(o.d)(e),i=a.priority;this._listener.listenTo(this._listener,'_keydown:'+n,(e,a)=>{t(a,()=>{a.preventDefault(),a.stopPropagation(),e.stop()}),e.return=!0},{priority:i})}press(e){return!!this._listener.fire('_keydown:'+Object(o.a)(e),e)}destroy(){this._listener.stopListening()}}},function(e,t,a){'use strict';t.a=function(){return new d};var n=a(71),o=a(259),i=a(92),r=a(47),s=a(94),l=a(0);class d{constructor(){this._dispatchers=[],this._from=null}for(...e){return this._dispatchers=e,this}fromElement(e){return this._from={type:'element',name:e,priority:null},this}fromAttribute(e){return this._from={type:'attribute',key:e,priority:null},this}fromMarker(e){return this._from={type:'marker',name:e,priority:null},this}withPriority(e){return this._from.priority=e,this}toElement(e){const t=null===this._from.priority?'normal':this._from.priority;for(const a of this._dispatchers)if('element'==this._from.type)e='string'==typeof e?new r.a(e):e,a.on('insert:'+this._from.name,Object(n.e)(e),{priority:t});else if('attribute'==this._from.type)e='string'==typeof e?new i.a(e):e,a.on('addAttribute:'+this._from.key,Object(n.m)(e),{priority:t}),a.on('changeAttribute:'+this._from.key,Object(n.m)(e),{priority:t}),a.on('removeAttribute:'+this._from.key,Object(n.l)(e),{priority:t}),a.on('selectionAttribute:'+this._from.key,Object(o.e)(e),{priority:t});else{const t=null===this._from.priority?'normal':this._from.priority;e='string'==typeof e?new s.a(e):e,a.on('addMarker:'+this._from.name,Object(n.g)(e),{priority:t}),a.on('removeMarker:'+this._from.name,Object(n.j)(e),{priority:t})}}toHighlight(e){const t=null===this._from.priority?'normal':this._from.priority;if('marker'!=this._from.type)throw new l.b('build-model-converter-non-marker-to-highlight: Conversion to a highlight is supported only from model markers.');for(const a of this._dispatchers)a.on('addMarker:'+this._from.name,Object(n.d)(e),{priority:t}),a.on('addMarker:'+this._from.name,Object(n.c)(e),{priority:t}),a.on('removeMarker:'+this._from.name,Object(n.d)(e),{priority:t}),a.on('removeMarker:'+this._from.name,Object(n.c)(e),{priority:t}),a.on('selectionMarker:'+this._from.name,Object(o.f)(e),{priority:t})}toAttribute(e,t){if('attribute'!=this._from.type)throw new l.b('build-model-converter-non-attribute-to-attribute: To-attribute conversion is supported only from model attributes.');let a=e?'string'==typeof e?t?function(){return{key:e,value:t}}:function(t){return{key:e,value:t}}:e:void 0;for(const o of this._dispatchers){const e={priority:this._from.priority||'normal'};o.on('addAttribute:'+this._from.key,Object(n.k)(a),e),o.on('changeAttribute:'+this._from.key,Object(n.k)(a),e),o.on('removeAttribute:'+this._from.key,Object(n.i)(a),e)}}}},function(e,a){'use strict';a.a=function(){let e='e';for(let a=0;8>a;a++)e+=t(65536*(1+Math.random())).toString(16).substring(1);return e}},function(e,t){'use strict';t.a=function(e,t){return e===t||e!==e&&t!==t}},function(e,t,a){'use strict';function n(e,t,a,n,o){return{done:!1,value:{type:e,item:t,previousPosition:a,nextPosition:n,length:o}}}var o=a(26),i=a(67),r=a(5),s=a(1),l=a(0);class d{constructor(e={}){if(!e.boundaries&&!e.startPosition)throw new l.b('model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.');const t=e.direction||'forward';if('forward'!=t&&'backward'!=t)throw new l.b('model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',{direction:t});this.direction=t,this.boundaries=e.boundaries||null,this.position=e.startPosition?s.a.createFromPosition(e.startPosition):s.a.createFromPosition(this.boundaries['backward'==this.direction?'end':'start']),this.singleCharacters=!!e.singleCharacters,this.shallow=!!e.shallow,this.ignoreElementEnd=!!e.ignoreElementEnd,this._boundaryStartParent=this.boundaries?this.boundaries.start.parent:null,this._boundaryEndParent=this.boundaries?this.boundaries.end.parent:null,this._visitedParent=this.position.parent}[Symbol.iterator](){return this}skip(e){let t,a,n,o;do n=this.position,o=this._visitedParent,({done:t,value:a}=this.next());while(!t&&e(a));t||(this.position=n,this._visitedParent=o)}next(){return'forward'==this.direction?this._next():this._previous()}_next(){const e=this.position,t=s.a.createFromPosition(this.position),a=this._visitedParent;if(null===a.parent&&t.offset===a.maxOffset)return{done:!0};if(a===this._boundaryEndParent&&t.offset==this.boundaries.end.offset)return{done:!0};const l=t.textNode?t.textNode:t.nodeAfter;if(l instanceof r.a)return this.shallow?t.offset++:(t.path.push(0),this._visitedParent=l),this.position=t,n('elementStart',l,e,t,1);if(l instanceof o.a){let o;if(this.singleCharacters)o=1;else{let e=l.endOffset;this._boundaryEndParent==a&&this.boundaries.end.offset<e&&(e=this.boundaries.end.offset),o=e-t.offset}const r=t.offset-l.startOffset,s=new i.a(l,r,o);return t.offset+=o,this.position=t,n('text',s,e,t,o)}return t.path.pop(),t.offset++,this.position=t,this._visitedParent=a.parent,this.ignoreElementEnd?this._next():n('elementEnd',a,e,t)}_previous(){const e=this.position,t=s.a.createFromPosition(this.position),a=this._visitedParent;if(null===a.parent&&0===t.offset)return{done:!0};if(a==this._boundaryStartParent&&t.offset==this.boundaries.start.offset)return{done:!0};const l=t.textNode?t.textNode:t.nodeBefore;if(l instanceof r.a)return t.offset--,this.shallow?(this.position=t,n('elementStart',l,e,t,1)):(t.path.push(l.maxOffset),this.position=t,this._visitedParent=l,this.ignoreElementEnd?this._previous():n('elementEnd',l,e,t));if(l instanceof o.a){let o;if(this.singleCharacters)o=1;else{let e=l.startOffset;this._boundaryStartParent==a&&this.boundaries.start.offset>e&&(e=this.boundaries.start.offset),o=t.offset-e}const r=t.offset-l.startOffset,s=new i.a(l,r-o,o);return t.offset-=o,this.position=t,n('text',s,e,t,o)}return t.path.pop(),this.position=t,this._visitedParent=a.parent,n('elementStart',a,e,t,1)}}t.a=d},function(e,t){'use strict';t.a=function(e,t){const a=n(e.length,t.length);for(let n=0;n<a;n++)if(e[n]!=t[n])return n;return e.length==t.length?'same':e.length<t.length?'prefix':'extension'}},function(e,t,a){'use strict';var n=a(166);t.a=function(e,t){var a=e[t];return Object(n.a)(a)?a:void 0}},function(e,t,a){'use strict';var n=a(15),o=a(46),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,r=/^\w*$/;t.a=function(e,t){if(Object(n.a)(e))return!1;var a=typeof e;return'number'==a||'symbol'==a||'boolean'==a||null==e||Object(o.a)(e)||r.test(e)||!i.test(e)||null!=t&&e in Object(t)}},function(e,t,a){'use strict';var n=a(46);t.a=function(e){if('string'==typeof e||Object(n.a)(e))return e;var t=e+'';return'0'==t&&1/e==-(1/0)?'-0':t}},function(e,t,a){'use strict';function n(e,t){return!t.has(e)&&(t.add(e),e.document.schema.itemExtends(e.name,'$block')&&e.parent)}function o(e,t){const a=e.parent.getAncestors({parentFirst:!0,includeSelf:!0}),o=a.find((e)=>n(e,t));return a.forEach((e)=>t.add(e)),o}var i=a(1),r=a(5),s=a(3),l=a(8),d=a(0),c=a(4),m=a(121),u=a(405),p=a(34);class g{constructor(e,t){this._lastRangeBackward=!1,this._ranges=[],this._attrs=new Map,e&&this.setRanges(e,t)}get anchor(){if(0<this._ranges.length){const e=this._ranges[this._ranges.length-1];return this._lastRangeBackward?e.end:e.start}return null}get focus(){if(0<this._ranges.length){const e=this._ranges[this._ranges.length-1];return this._lastRangeBackward?e.start:e.end}return null}get isCollapsed(){const e=this._ranges.length;return!(1!==e)&&this._ranges[0].isCollapsed}get rangeCount(){return this._ranges.length}get isBackward(){return!this.isCollapsed&&this._lastRangeBackward}isEqual(e){if(this.rangeCount!=e.rangeCount)return!1;if(0===this.rangeCount)return!0;if(!this.anchor.isEqual(e.anchor)||!this.focus.isEqual(e.focus))return!1;for(const t of this._ranges){let a=!1;for(const n of e._ranges)if(t.isEqual(n)){a=!0;break}if(!a)return!1}return!0}*getRanges(){for(const e of this._ranges)yield s.a.createFromRange(e)}getFirstRange(){let e=null;for(const t of this._ranges)(!e||t.start.isBefore(e.start))&&(e=t);return e?s.a.createFromRange(e):null}getLastRange(){let e=null;for(const t of this._ranges)(!e||t.end.isAfter(e.end))&&(e=t);return e?s.a.createFromRange(e):null}getFirstPosition(){const e=this.getFirstRange();return e?i.a.createFromPosition(e.start):null}getLastPosition(){const e=this.getLastRange();return e?i.a.createFromPosition(e.end):null}addRange(e,t=!1){this._pushRange(e),this._lastRangeBackward=!!t,this.fire('change:range',{directChange:!0})}removeAllRanges(){0<this._ranges.length&&(this._removeAllRanges(),this.fire('change:range',{directChange:!0}))}setRanges(e,t=!1){e=Array.from(e);const a=e.some((e)=>{if(!(e instanceof s.a))throw new d.b('model-selection-added-not-range: Trying to add an object that is not an instance of Range.');return this._ranges.every((t)=>!t.isEqual(e))});if(e.length!==this._ranges.length||a){this._removeAllRanges();for(const t of e)this._pushRange(t);this._lastRangeBackward=!!t,this.fire('change:range',{directChange:!0})}}setTo(e){e instanceof g?this.setRanges(e.getRanges(),e.isBackward):e instanceof s.a?this.setRanges([e]):Object(p.a)(e)?this.setRanges(e):this.setRanges([new s.a(e)])}setIn(e){this.setRanges([s.a.createIn(e)])}setOn(e){this.setRanges([s.a.createOn(e)])}setCollapsedAt(e,t){const a=i.a.createAt(e,t),n=new s.a(a,a);this.setRanges([n])}collapseToStart(){const e=this.getFirstPosition();null!==e&&this.setRanges([new s.a(e,e)])}collapseToEnd(){const e=this.getLastPosition();null!==e&&this.setRanges([new s.a(e,e)])}moveFocusTo(e,t){if(null===this.anchor)throw new d.b('model-selection-moveFocusTo-no-ranges: Cannot set selection focus if there are no ranges in selection.');const a=i.a.createAt(e,t);if('same'!=a.compareWith(this.focus)){const e=this.anchor;this._ranges.length&&this._popRange(),'before'==a.compareWith(e)?this.addRange(new s.a(a,e),!0):this.addRange(new s.a(e,a))}}getAttribute(e){return this._attrs.get(e)}getAttributes(){return this._attrs.entries()}getAttributeKeys(){return this._attrs.keys()}hasAttribute(e){return this._attrs.has(e)}clearAttributes(){if(0<this._attrs.size){const e=Array.from(this._attrs.keys());this._attrs.clear(),this.fire('change:attribute',{attributeKeys:e,directChange:!0})}}removeAttribute(e){this.hasAttribute(e)&&(this._attrs.delete(e),this.fire('change:attribute',{attributeKeys:[e],directChange:!0}))}setAttribute(e,t){this.getAttribute(e)!==t&&(this._attrs.set(e,t),this.fire('change:attribute',{attributeKeys:[e],directChange:!0}))}setAttributesTo(e){if(e=Object(m.a)(e),!Object(u.a)(e,this._attrs)){const t=new Set(Array.from(e.keys()).concat(Array.from(this._attrs.keys())));for(const[a,n]of e)this._attrs.get(a)===n&&t.delete(a);this._attrs=e,this.fire('change:attribute',{attributeKeys:Array.from(t),directChange:!0})}}getSelectedElement(){if(1!==this.rangeCount)return null;const e=this.getFirstRange(),t=e.start.nodeAfter,a=e.end.nodeBefore;return t instanceof r.a&&t==a?t:null}*getSelectedBlocks(){const e=new WeakSet;for(const t of this.getRanges()){const a=o(t.start,e);a&&(yield a);for(const a of t.getWalker())'elementEnd'==a.type&&n(a.item,e)&&(yield a.item);const r=o(t.end,e);r&&!t.end.isTouching(i.a.createAt(r))&&(yield r)}}containsEntireContent(e=this.anchor.root){const t=i.a.createAt(e),a=i.a.createAt(e,'end');return t.isTouching(this.getFirstPosition())&&a.isTouching(this.getLastPosition())}static createFromSelection(e){const t=new this;return t.setTo(e),t}_pushRange(e){if(!(e instanceof s.a))throw new d.b('model-selection-added-not-range: Trying to add an object that is not an instance of Range.');this._checkRange(e),this._ranges.push(s.a.createFromRange(e))}_checkRange(e){for(let t=0;t<this._ranges.length;t++)if(e.isIntersecting(this._ranges[t]))throw new d.b('model-selection-range-intersects: Trying to add a range that intersects with another range from selection.',{addedRange:e,intersectingRange:this._ranges[t]})}_popRange(){this._ranges.pop()}_removeAllRanges(){for(;0<this._ranges.length;)this._popRange()}}t.a=g,Object(c.a)(g,l.c)},function(e,t){'use strict';t.a={window,document}},function(e,t,a){'use strict';var n=a(110),o=a(4);class i{constructor(e){this.document=e,this.isEnabled=!1}enable(){this.isEnabled=!0}disable(){this.isEnabled=!1}destroy(){this.disable(),this.stopListening()}}t.a=i,Object(o.a)(i,n.a)},function(e,t,a){'use strict';var n=a(110),o=a(12),i=a(0),r=a(4);class s{constructor(){this.set('isFocused',!1),this.focusedElement=null,this._elements=new Set,this._nextEventLoopTimeout=null}add(e){if(this._elements.has(e))throw new i.b('focusTracker-add-element-already-exist');this.listenTo(e,'focus',()=>this._focus(e),{useCapture:!0}),this.listenTo(e,'blur',()=>this._blur(),{useCapture:!0}),this._elements.add(e)}remove(e){e===this.focusedElement&&this._blur(e),this._elements.has(e)&&(this.stopListening(e),this._elements.delete(e))}_focus(e){clearTimeout(this._nextEventLoopTimeout),this.focusedElement=e,this.isFocused=!0}_blur(){clearTimeout(this._nextEventLoopTimeout),this._nextEventLoopTimeout=setTimeout(()=>{this.focusedElement=null,this.isFocused=!1},0)}}t.a=s,Object(r.a)(s,n.a),Object(r.a)(s,o.a)},function(e,t){'use strict';t.a=function(e){const t=e.next();return t.done?null:t.value}},function(e,t,a){'use strict';var n=a(53),o=Object.prototype,i=o.hasOwnProperty;t.a=function(e,t,a){var o=e[t];i.call(e,t)&&Object(n.a)(o,a)&&(a!==void 0||t in e)||(e[t]=a)}},function(e,t,a){'use strict';var n=a(17),o=Object.prototype,i=o.toString;t.a=function(e){var t=Object(n.a)(e)?i.call(e):'';return t=='[object Function]'||t=='[object GeneratorFunction]'}},function(e,t,a){'use strict';var n=a(121),o=a(0);class i{constructor(e){this.parent=null,this._attrs=Object(n.a)(e)}get index(){let e;if(!this.parent)return null;if(null===(e=this.parent.getChildIndex(this)))throw new o.b('model-node-not-found-in-parent: The node\'s parent does not contain this node.');return e}get startOffset(){let e;if(!this.parent)return null;if(null===(e=this.parent.getChildStartOffset(this)))throw new o.b('model-node-not-found-in-parent: The node\'s parent does not contain this node.');return e}get offsetSize(){return 1}get endOffset(){return this.parent?this.startOffset+this.offsetSize:null}get nextSibling(){const e=this.index;return null!==e&&this.parent.getChild(e+1)||null}get previousSibling(){const e=this.index;return null!==e&&this.parent.getChild(e-1)||null}get root(){let e=this;for(;e.parent;)e=e.parent;return e}get document(){return this.root==this?null:this.root.document||null}clone(){return new i(this._attrs)}getPath(){const e=[];for(let t=this;t.parent;)e.unshift(t.startOffset),t=t.parent;return e}getAncestors(e={includeSelf:!1,parentFirst:!1}){const t=[];for(let a=e.includeSelf?this:this.parent;a;)t[e.parentFirst?'push':'unshift'](a),a=a.parent;return t}getCommonAncestor(e,t={}){const a=this.getAncestors(t),n=e.getAncestors(t);let o=0;for(;a[o]==n[o]&&a[o];)o++;return 0==o?null:a[o-1]}remove(){this.parent.removeChildren(this.index)}hasAttribute(e){return this._attrs.has(e)}getAttribute(e){return this._attrs.get(e)}getAttributes(){return this._attrs.entries()}getAttributeKeys(){return this._attrs.keys()}setAttribute(e,t){this._attrs.set(e,t)}setAttributesTo(e){this._attrs=Object(n.a)(e)}removeAttribute(e){return this._attrs.delete(e)}clearAttributes(){this._attrs.clear()}toJSON(){const e={};return this._attrs.size&&(e.attributes=[...this._attrs]),e}}t.a=i},function(e,t,a){'use strict';var n=a(0);class o{constructor(e,t,a){if(this.textNode=e,0>t||t>e.offsetSize)throw new n.b('model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.');if(0>a||t+a>e.offsetSize)throw new n.b('model-textproxy-wrong-length: Given length value is incorrect.');this.data=e.data.substring(t,t+a),this.offsetInText=t}get startOffset(){return null===this.textNode.startOffset?null:this.textNode.startOffset+this.offsetInText}get offsetSize(){return this.data.length}get endOffset(){return null===this.startOffset?null:this.startOffset+this.offsetSize}get isPartial(){return this.offsetSize!==this.textNode.offsetSize}get parent(){return this.textNode.parent}get root(){return this.textNode.root}get document(){return this.textNode.document}is(e){return'textProxy'==e}getPath(){const e=this.textNode.getPath();return 0<e.length&&(e[e.length-1]+=this.offsetInText),e}getAncestors(e={includeSelf:!1,parentFirst:!1}){const t=[];for(let a=e.includeSelf?this:this.parent;a;)t[e.parentFirst?'push':'unshift'](a),a=a.parent;return t}hasAttribute(e){return this.textNode.hasAttribute(e)}getAttribute(e){return this.textNode.getAttribute(e)}getAttributes(){return this.textNode.getAttributes()}getAttributeKeys(){return this.textNode.getAttributeKeys()}}t.a=o},function(e,t,a){'use strict';var n=a(27),o=a(35),i=a(348),r=a(22),s=a(0);class l{constructor(e={}){if(!e.boundaries&&!e.startPosition)throw new s.b('view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.');if(e.direction&&'forward'!=e.direction&&'backward'!=e.direction)throw new s.b('view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',{direction:e.direction});this.boundaries=e.boundaries||null,this.position=e.startPosition?r.a.createFromPosition(e.startPosition):r.a.createFromPosition(e.boundaries['backward'==e.direction?'end':'start']),this.direction=e.direction||'forward',this.singleCharacters=!!e.singleCharacters,this.shallow=!!e.shallow,this.ignoreElementEnd=!!e.ignoreElementEnd,this._boundaryStartParent=this.boundaries?this.boundaries.start.parent:null,this._boundaryEndParent=this.boundaries?this.boundaries.end.parent:null}[Symbol.iterator](){return this}skip(e){let t,a,n;do n=this.position,({done:t,value:a}=this.next());while(!t&&e(a));t||(this.position=n)}next(){return'forward'==this.direction?this._next():this._previous()}_next(){let e=r.a.createFromPosition(this.position);const t=this.position,a=e.parent;if(null===a.parent&&e.offset===a.childCount)return{done:!0};if(a===this._boundaryEndParent&&e.offset==this.boundaries.end.offset)return{done:!0};let s;if(a instanceof o.a){if(e.isAtEnd)return this.position=r.a.createAfter(a),this._next();s=a.data[e.offset]}else s=a.getChild(e.offset);if(s instanceof n.a)return this.shallow?e.offset++:e=new r.a(s,0),this.position=e,this._formatReturnValue('elementStart',s,t,e,1);if(!(s instanceof o.a)){if('string'==typeof s){let n;if(this.singleCharacters)n=1;else{const t=a===this._boundaryEndParent?this.boundaries.end.offset:a.data.length;n=t-e.offset}const o=new i.a(a,e.offset,n);return e.offset+=n,this.position=e,this._formatReturnValue('text',o,t,e,n)}return e=r.a.createAfter(a),this.position=e,this.ignoreElementEnd?this._next():this._formatReturnValue('elementEnd',a,t,e)}if(this.singleCharacters)return e=new r.a(s,0),this.position=e,this._next();else{let a=s.data.length,n=s;return s==this._boundaryEndParent?(a=this.boundaries.end.offset,n=new i.a(s,0,a),e=r.a.createAfter(n)):e.offset++,this.position=e,this._formatReturnValue('text',n,t,e,a)}}_previous(){let e=r.a.createFromPosition(this.position);const t=this.position,a=e.parent;if(null===a.parent&&0===e.offset)return{done:!0};if(a==this._boundaryStartParent&&e.offset==this.boundaries.start.offset)return{done:!0};let s;if(a instanceof o.a){if(e.isAtStart)return this.position=r.a.createBefore(a),this._previous();s=a.data[e.offset-1]}else s=a.getChild(e.offset-1);if(s instanceof n.a)return this.shallow?(e.offset--,this.position=e,this._formatReturnValue('elementStart',s,t,e,1)):(e=new r.a(s,s.childCount),this.position=e,this.ignoreElementEnd?this._previous():this._formatReturnValue('elementEnd',s,t,e));if(!(s instanceof o.a)){if('string'==typeof s){let n;if(!this.singleCharacters){const t=a===this._boundaryStartParent?this.boundaries.start.offset:0;n=e.offset-t}else n=1;e.offset-=n;const o=new i.a(a,e.offset,n);return this.position=e,this._formatReturnValue('text',o,t,e,n)}return e=r.a.createBefore(a),this.position=e,this._formatReturnValue('elementStart',a,t,e,1)}if(this.singleCharacters)return e=new r.a(s,s.data.length),this.position=e,this._previous();else{let a=s.data.length,n=s;if(s==this._boundaryStartParent){const t=this.boundaries.start.offset;n=new i.a(s,t,s.data.length-t),a=n.data.length,e=r.a.createBefore(n)}else e.offset--;return this.position=e,this._formatReturnValue('text',n,t,e,a)}}_formatReturnValue(e,t,a,n,o){return t instanceof i.a&&(t.offsetInText+t.data.length==t.textNode.data.length&&('forward'!=this.direction||this.boundaries&&this.boundaries.end.isEqual(this.position)?a=r.a.createAfter(t.textNode):(n=r.a.createAfter(t.textNode),this.position=n)),0===t.offsetInText&&('backward'!=this.direction||this.boundaries&&this.boundaries.start.isEqual(this.position)?a=r.a.createBefore(t.textNode):(n=r.a.createBefore(t.textNode),this.position=n))),{done:!1,value:{type:e,item:t,previousPosition:a,nextPosition:n,length:o}}}}t.a=l},function(e,t,a){'use strict';var n=a(165);t.a=function(e){return Object(n.a)(e,!1,!0)}},function(e,t,a){'use strict';var n=a(169),o=a(326),i=a(161),r=a(80),s=a(37),l=a(82);t.a=function(e){var t=Object(l.a)(e);if(!(t||Object(r.a)(e)))return Object(o.a)(e);var a=Object(i.a)(e),d=a||[],c=d.length;for(var m in e)!Object(n.a)(e,m)||!!a&&('length'==m||Object(s.a)(m,c))||t&&'constructor'==m||d.push(m);return d}},function(e,t,a){'use strict';function n(e){const t=e.split(':');return t[0]+':'+t[1]}function o(e,t){const a=new m.a({startPosition:e,singleCharacters:!0});let n=0;for(const o of a)if('text'==o.type&&(n++,n==t))return a.position}function i(e){const t=new g('span',e.attributes);if(e.class){const a=Array.isArray(e.class)?e.class:[e.class];t.addClass(...a)}return e.priority&&(t.priority=e.priority),t.setCustomProperty('highlightDescriptorId',e.id),t}t.e=function(e){return(t,a,n,o)=>{const i=e instanceof r.a?e.clone(!0):e(a,n,o);if(i&&n.consume(a.item,'insert')){const e=o.mapper.toViewPosition(a.range.start);o.mapper.bindElements(a.item,i),u.a.insert(e,i)}}},t.f=function(){return(e,t,a,n)=>{if(a.consume(t.item,'insert')){const e=n.mapper.toViewPosition(t.range.start),a=new l.a(t.item.data);u.a.insert(e,a)}}},t.g=function(e){return(t,a,n,o)=>{let i,s;if(e instanceof r.a?(i=e.clone(!0),s=e.clone(!0)):(a.isOpening=!0,i=e(a,n,o),a.isOpening=!1,s=e(a,n,o)),i&&s){const e=a.markerRange,r=t.name;if(!e.isCollapsed||n.consume(e,r)){for(const t of e)if(!n.consume(t.item,r))return;const t=o.mapper;u.a.insert(t.toViewPosition(e.start),i),e.isCollapsed||u.a.insert(t.toViewPosition(e.end),s)}}}},t.k=function(e){return e=e||((e,t)=>({value:e,key:t})),(t,a,o,i)=>{if(o.consume(a.item,n(t.name))){const{key:t,value:n}=e(a.attributeNewValue,a.attributeKey,a,o,i);i.mapper.toViewElement(a.item).setAttribute(t,n)}}},t.i=function(e){return e=e||((e,t)=>({key:t})),(t,a,o,i)=>{if(o.consume(a.item,n(t.name))){const{key:t}=e(a.attributeOldValue,a.attributeKey,a,o,i);i.mapper.toViewElement(a.item).removeAttribute(t)}}},t.m=function(e){return(t,a,o,i)=>{const s=e instanceof r.a?e.clone(!0):e(a.attributeNewValue,a,o,i);if(!s)return;if(!o.consume(a.item,n(t.name)))return;let l=i.mapper.toViewRange(a.range);if(null!==a.attributeOldValue&&!(e instanceof r.a)){const t=e(a.attributeOldValue,a,o,i);l=u.a.unwrap(l,t)}u.a.wrap(l,s)}},t.l=function(e){return(t,a,o,i)=>{const s=e instanceof r.a?e.clone(!0):e(a.attributeOldValue,a,o,i);if(s&&o.consume(a.item,n(t.name))){const e=i.mapper.toViewRange(a.range);u.a.unwrap(e,s)}}},t.h=function(){return(e,t,a,n)=>{if(!a.consume(t.item,'remove'))return;let i=n.mapper.toViewPosition(t.sourcePosition),r;if(t.item.is('element'))i=i.getLastMatchingPosition((e)=>!e.item.is('containerElement')),i.parent.is('text')&&i.isAtEnd&&(i=c.a.createAfter(i.parent)),r=d.a.createOn(i.nodeAfter);else{const e=o(i,t.item.offsetSize);r=new d.a(i,e)}u.a.remove(r.getTrimmed()),'$graveyard'==t.item.root.rootName&&n.mapper.unbindModelElement(t.item)}},t.d=function(e){return(t,a,n,o)=>{const r='function'==typeof e?e(a,n,o):e,s=a.item;if(r&&!a.markerRange.isCollapsed&&s.is('textProxy')&&n.consume(s,t.name)){r.id||(r.id=a.markerName);const e=i(r),n=o.mapper.toViewRange(a.range);'addMarker'==t.name.split(':')[0]?u.a.wrap(n,e):u.a.unwrap(n,e)}}},t.c=function(e){return(t,a,n,o)=>{const i='function'==typeof e?e(a,n,o):e,r=a.item;if(i&&!a.markerRange.isCollapsed&&r.is('element')&&n.test(a.item,t.name)){i.priority||(i.priority=10),i.id||(i.id=a.markerName);const e=o.mapper.toViewElement(r),s='addMarker'==t.name.split(':')[0],l=s?'addHighlight':'removeHighlight';if(e&&e.getCustomProperty(l)){n.consume(a.item,t.name);for(const e of p.a.createIn(r))n.consume(e.item,t.name);e.getCustomProperty(l)(e,i)}}}},t.j=function(e){return(t,a,n,o)=>{let i,s;if(e instanceof r.a?(i=e.clone(!0),s=e.clone(!0)):(a.isOpening=!0,i=e(a,n,o),a.isOpening=!1,s=e(a,n,o)),i&&s){const e=a.markerRange,r=t.name;if(!e.isCollapsed||n.consume(e,r)){for(const t of e)if(!n.consume(t.item,r))return;const t=o.mapper.toViewRange(e);u.a.clear(t.getEnlarged(),s),i.isSimilar(s)||u.a.clear(t.getEnlarged(),i)}}}},t.b=n,t.a=i;var r=a(27),s=a(92),l=a(35),d=a(38),c=a(22),m=a(68),u=a(93),p=a(3);class g extends s.a{isSimilar(e){return!!e.is('attributeElement')&&this.getCustomProperty('highlightDescriptorId')===e.getCustomProperty('highlightDescriptorId')}}},function(e,t,a){'use strict';var n=a(40);class o extends n.a{get type(){return'noop'}clone(){return new o(this.baseVersion)}getReversed(){return new o(this.baseVersion+1)}_execute(){return{}}static get className(){return'engine.model.operation.NoOperation'}}t.a=o},function(e,t,a){'use strict';var n=a(97),o=a(135),i=a(137),r=a(30),s=a(138),l=a(139);t.a=function(e,t,a,d){var c=-1,m=o.a,u=!0,p=e.length,g=[],f=t.length;if(!p)return g;a&&(t=Object(r.a)(t,Object(s.a)(a))),d?(m=i.a,u=!1):t.length>=200&&(m=l.a,u=!1,t=new n.a(t));outer:for(;++c<p;){var h=e[c],b=a?a(h):h;if(h=d||0!==h?h:0,u&&b===b){for(var _=f;_--;)if(t[_]===b)continue outer;g.push(h)}else m(t,b,d)||g.push(h)}return g}},function(e,t,a){'use strict';function n(e){return e instanceof Text&&e.data.substr(0,r)===s}function o(e,t){if(t.keyCode==i.c.arrowleft){const e=t.domTarget.ownerDocument.defaultView.getSelection();if(1==e.rangeCount&&e.getRangeAt(0).collapsed){const t=e.getRangeAt(0).startContainer,a=e.getRangeAt(0).startOffset;n(t)&&a<=r&&e.collapse(t,0)}}}a.d(t,'b',function(){return s}),t.i=n,t.h=function(e){return e.data.length==r&&n(e)},t.e=function(e){return n(e)?e.data.slice(r):e.data},t.g=function(e,t){let a=l.get(t);return a||(a=t(window.document),l.set(t,a)),e.isEqualNode(a)},t.f=function(e){e.on('keydown',o)};var i=a(28);t.a=(e)=>{const t=e.createElement('br');return t.dataset.ckeFiller=!0,t};t.d=(e)=>e.createTextNode('\xA0');const r=7;t.c=r;let s='';for(let n=0;n<r;n++)s+='\u200B';const l=new WeakMap},function(e,t,a){'use strict';var n=a(61),o=a(154);class i extends n.a{constructor(e){super(e),this.useCapture=!1}observe(e){const t='string'==typeof this.domEventType?[this.domEventType]:this.domEventType;t.forEach((t)=>{this.listenTo(e,t,(e,t)=>{this.isEnabled&&this.onDomEvent(t)},{useCapture:this.useCapture})})}fire(e,t,a){this.isEnabled&&this.document.fire(e,new o.a(this.document,t,a))}}t.a=i},function(e,t,a){'use strict';var n=a(2),o=a(0),i=a(12),r=a(113),s=a(4),l=a(16),d=a(471),c=a(52);class m extends n.a{static get pluginName(){return'FileRepository'}init(){this.loaders=new r.a,this.set('uploaded',0),this.set('uploadTotal',null),this.bind('uploadedPercent').to(this,'uploaded',this,'uploadTotal',(e,t)=>t?100*(e/t):0)}getLoader(e){for(const t of this.loaders)if(t.file==e)return t;return null}createLoader(e){if(!this.createAdapter)return l.a.error('filerepository-no-adapter: Upload adapter is not defined.'),null;const t=new u(e);return t._adapter=this.createAdapter(t),this.loaders.add(t),t.on('change:uploaded',()=>{let e=0;for(const t of this.loaders)e+=t.uploaded;this.uploaded=e}),t.on('change:uploadTotal',()=>{let e=0;for(const t of this.loaders)t.uploadTotal&&(e+=t.uploadTotal);this.uploadTotal=e}),t}destroyLoader(e){const t=e instanceof u?e:this.getLoader(e);t._destroy(),this.loaders.remove(t)}}t.a=m,Object(s.a)(m,i.a);class u{constructor(e,t){this.id=Object(c.a)(),this.file=e,this._adapter=t,this._reader=new d.a,this.set('status','idle'),this.set('uploaded',0),this.set('uploadTotal',null),this.bind('uploadedPercent').to(this,'uploaded',this,'uploadTotal',(e,t)=>t?100*(e/t):0),this.set('uploadResponse',null)}read(){if('idle'!=this.status)throw new o.b('filerepository-read-wrong-status: You cannot call read if the status is different than idle.');return this.status='reading',this._reader.read(this.file).then((e)=>(this.status='idle',e)).catch((e)=>{if('aborted'===e)throw this.status='aborted','aborted';throw this.status='error',this._reader.error})}upload(){if('idle'!=this.status)throw new o.b('filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.');return this.status='uploading',this._adapter.upload().then((e)=>(this.uploadResponse=e,this.status='idle',e)).catch((e)=>{if('aborted'===this.status)throw'aborted';throw this.status='error',e})}abort(){const e=this.status;this.status='aborted','reading'==e&&this._reader.abort(),'uploading'==e&&this._adapter.abort&&this._adapter.abort(),this._destroy()}_destroy(){this._reader=void 0,this._adapter=void 0,this.data=void 0,this.uploadResponse=void 0,this.file=void 0}}Object(s.a)(u,i.a)},function(e,t,a){'use strict';var n=a(116),o=a(78),i=a(44),r=Object.prototype,s=Function.prototype.toString,l=r.hasOwnProperty,d=s.call(Object),c=r.toString;t.a=function(e){if(!Object(i.a)(e)||c.call(e)!='[object Object]'||Object(o.a)(e))return!1;var t=Object(n.a)(e);if(null===t)return!0;var a=l.call(t,'constructor')&&t.constructor;return'function'==typeof a&&a instanceof a&&s.call(a)==d}},function(e,t){'use strict';t.a=function(e){var t=!1;if(null!=e&&'function'!=typeof e.toString)try{t=!!(e+'')}catch(t){}return t}},function(e,t,a){'use strict';var n=a(53),o=a(80),i=a(37),r=a(17);t.a=function(e,t,a){if(!Object(r.a)(a))return!1;var s=typeof t;return!('number'==s?!(Object(o.a)(a)&&Object(i.a)(t,a.length)):!('string'==s&&t in a))&&Object(n.a)(a[t],e)}},function(e,t,a){'use strict';var n=a(294),o=a(65),i=a(81);t.a=function(e){return null!=e&&Object(i.a)(Object(n.a)(e))&&!Object(o.a)(e)}},function(e,t){'use strict';t.a=function(e){return'number'==typeof e&&-1<e&&0==e%1&&e<=9007199254740991}},function(e,t){'use strict';var a=Object.prototype;t.a=function(e){var t=e&&e.constructor,n='function'==typeof t&&t.prototype||a;return e===n}},function(e,t,a){'use strict';var n=a(66),o=a(0);class i{constructor(e){this._nodes=[],e&&this.insertNodes(0,e)}[Symbol.iterator](){return this._nodes[Symbol.iterator]()}get length(){return this._nodes.length}get maxOffset(){return this._nodes.reduce((e,t)=>e+t.offsetSize,0)}getNode(e){return this._nodes[e]||null}getNodeIndex(e){const t=this._nodes.indexOf(e);return-1==t?null:t}getNodeStartOffset(e){const t=this.getNodeIndex(e);return null===t?null:this._nodes.slice(0,t).reduce((e,t)=>e+t.offsetSize,0)}indexToOffset(e){if(e==this._nodes.length)return this.maxOffset;const t=this._nodes[e];if(!t)throw new o.b('model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.');return this.getNodeStartOffset(t)}offsetToIndex(e){let t=0;for(const a of this._nodes){if(e>=t&&e<t+a.offsetSize)return this.getNodeIndex(a);t+=a.offsetSize}if(t!=e)throw new o.b('model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.');return this.length}insertNodes(e,t){for(const a of t)if(!(a instanceof n.a))throw new o.b('model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.');this._nodes.splice(e,0,...t)}removeNodes(e,t=1){return this._nodes.splice(e,t)}toJSON(){return this._nodes.map((e)=>e.toJSON())}}t.a=i},function(e,t,a){'use strict';var n=a(0),o=a(8),i=a(4),r=a(69);class s{constructor(){this.parent=null}get index(){let e;if(!this.parent)return null;if(-1==(e=this.parent.getChildIndex(this)))throw new n.b('view-node-not-found-in-parent: The node\'s parent does not contain this node.');return e}get nextSibling(){const e=this.index;return null!==e&&this.parent.getChild(e+1)||null}get previousSibling(){const e=this.index;return null!==e&&this.parent.getChild(e-1)||null}get root(){let e=this;for(;e.parent;)e=e.parent;return e}get document(){return this.parent instanceof s?this.parent.document:null}getAncestors(e={includeSelf:!1,parentFirst:!1}){const t=[];for(let a=e.includeSelf?this:this.parent;a;)t[e.parentFirst?'push':'unshift'](a),a=a.parent;return t}getCommonAncestor(e,t={}){const a=this.getAncestors(t),n=e.getAncestors(t);let o=0;for(;a[o]==n[o]&&a[o];)o++;return 0==o?null:a[o-1]}remove(){this.parent.removeChildren(this.index)}_fireChange(e,t){this.fire('change:'+e,t),this.parent&&this.parent._fireChange(e,t)}toJSON(){const e=Object(r.a)(this);return delete e.parent,e}}t.a=s,Object(i.a)(s,o.c)},function(e,t,a){'use strict';function n(e){var t=-1,a=e?e.length:0;for(this.clear();++t<a;){var n=e[t];this.set(n[0],n[1])}}var o=a(302),i=a(303),r=a(304),s=a(305),l=a(306);n.prototype.clear=o.a,n.prototype['delete']=i.a,n.prototype.get=r.a,n.prototype.has=s.a,n.prototype.set=l.a,t.a=n},function(e,t,a){'use strict';var n=a(53);t.a=function(e,t){for(var a=e.length;a--;)if(Object(n.a)(e[a][0],t))return a;return-1}},function(e,t,a){'use strict';var n=a(56),o=Object(n.a)(Object,'create');t.a=o},function(e,t,a){'use strict';var n=a(320);t.a=function(e,t){var a=e.__data__;return Object(n.a)(t)?a['string'==typeof t?'string':'hash']:a.map}},function(e,t){'use strict';t.a=function(e,t){for(var a=-1,n=t.length,o=e.length;++a<n;)e[o+a]=t[a];return e}},function(e,t){'use strict';t.a=function(e){var t=-1,a=Array(e.size);return e.forEach(function(e){a[++t]=e}),a}},function(e,t,a){'use strict';var n=a(47),o=a(0),i=a(4),r=a(12);const s=Symbol('document');class l extends n.a{constructor(e,t,a){super(e,t,a),this.set('isReadOnly',!1),this.set('isFocused',!1)}get document(){return this.getCustomProperty(s)}set document(e){if(this.getCustomProperty(s))throw new o.b('view-editableelement-document-already-set: View document is already set.');this.setCustomProperty(s,e),this.bind('isReadOnly').to(e),this.bind('isFocused').to(e,'isFocused',(t)=>t&&e.selection.editableElement==this),this.listenTo(e,'render',()=>{this.isFocused=e.isFocused&&e.selection.editableElement==this},{priority:'high'})}}t.a=l,Object(i.a)(l,r.a)},function(e,t,a){'use strict';function n(){if(o(this))return null;let e=this.parent;for(;e&&e.is('attributeElement');){if(1<o(e))return null;e=e.parent}return!e||1<o(e)?null:this.childCount}function o(e){return Array.from(e.getChildren()).filter((e)=>!e.is('uiElement')).length}var i=a(27);const r=10;class s extends i.a{constructor(e,t,a){super(e,t,a),this.priority=r,this.getFillerOffset=n}is(e,t=null){return t?'attributeElement'==e&&t==this.name||super.is(e,t):'attributeElement'==e||super.is(e)}clone(e){const t=super.clone(e);return t.priority=this.priority,t}isSimilar(e){return super.isSimilar(e)&&this.priority==e.priority}}t.a=s,s.DEFAULT_PRIORITY=r},function(t,a,n){'use strict';function o(e){const t=e.offset,a=e.parent;if(a.is('text'))return e;if(a.is('attributeElement')&&0===a.childCount){const e=a.parent,t=a.index;return a.remove(),o(new A.a(e,t))}const n=a.getChild(t-1),i=a.getChild(t);if(!n||!i)return e;if(n.is('text')&&i.is('text'))return b(n,i);if(n.is('attributeElement')&&i.is('attributeElement')&&n.isSimilar(i)){const e=n.childCount;return n.appendChildren(i.getChildren()),i.remove(),o(new A.a(n,e))}return e}function i(e,t){t=Object(F.a)(t)?[...t]:[t],w(t);const a=d(e);if(!a)throw new V.b('view-writer-invalid-position-container');const n=m(e,!0),i=a.insertChildren(n.offset,t),r=n.getShiftedBy(i),s=o(n);if(0===i)return new O.a(s,s);else{s.isEqual(n)||r.offset--;const e=o(r);return new O.a(s,e)}}function r(e){if(x(e),e.isCollapsed)return new R.a;const{start:t,end:a}=c(e,!0),n=t.parent,i=a.offset-t.offset,r=n.removeChildren(t.offset,i),s=o(t);return e.start=s,e.end=A.a.createFromPosition(s),new R.a(r)}function s(e,t){let a;if(t.isAfter(e.end)){t=m(t,!0);const n=t.parent,o=n.childCount;e=c(e,!0),a=r(e),t.offset+=n.childCount-o}else a=r(e);return i(t,a)}function l(e,t){if(!(t instanceof T.a))throw new V.b('view-writer-wrap-invalid-attribute');if(x(e),e.isCollapsed)return e;if(e.end.isEqual(e.start.getShiftedBy(1))){const a=e.start.nodeAfter;if(a instanceof T.a&&_(t,a))return e}if(y(e)&&_(t,e.start.parent)){const t=e.start.parent.parent,a=e.start.parent.index;return O.a.createFromParentsAndOffsets(t,a,t,a+1)}const{start:a,end:n}=c(e,!0),i=a.parent,r=u(i,a.offset,n.offset,t),s=p(i,r.start.offset,r.end.offset,t),l=o(s.start);l.isEqual(s.start)||s.end.offset--;const d=o(s.end);return new O.a(l,d)}function d(e){let t=e.parent;for(;!v(t);){if(!t)return;t=t.parent}return t}function c(e,t=!1){const a=e.start,n=e.end;if(x(e),e.isCollapsed){const a=m(e.start,t);return new O.a(a,a)}const o=m(n,t),i=o.parent.childCount,r=m(a,t);return o.offset+=o.parent.childCount-i,new O.a(r,o)}function m(e,t=!1){const a=e.offset,n=e.parent;if(e.parent.is('emptyElement'))throw new V.b('view-writer-cannot-break-empty-element');if(e.parent.is('uiElement'))throw new V.b('view-writer-cannot-break-ui-element');if(!t&&n.is('text')&&v(n.parent))return A.a.createFromPosition(e);if(v(n))return A.a.createFromPosition(e);if(n.is('text'))return m(h(e),t);const o=n.childCount;if(a==o){const e=new A.a(n.parent,n.index+1);return m(e,t)}if(0===a){const e=new A.a(n.parent,n.index);return m(e,t)}else{const e=n.index+1,o=n.clone();n.parent.insertChildren(e,o);const i=n.childCount-a,r=n.removeChildren(a,i);o.appendChildren(r);const s=new A.a(n.parent,e);return m(s,t)}}function u(e,t,a,n){let r=t;const i=[];for(;r<a;){const t=e.getChild(r);if(t.isSimilar(n)){const n=t.getChildren(),o=t.childCount;t.remove(),e.insertChildren(r,n),i.push(new A.a(e,r),new A.a(e,r+o)),r+=o,a+=o-1}else t.is('attributeElement')&&u(t,0,t.childCount,n),r++}let s=0;for(const r of i){if(r.offset-=s,r.offset==t||r.offset==a)continue;const e=o(r);e.isEqual(r)||(s++,a--)}return O.a.createFromParentsAndOffsets(e,t,e,a)}function p(e,t,a,n){let r=t;const i=[];for(;r<a;){const t=e.getChild(r),a=t.is('text'),o=t.is('attributeElement'),s=t.is('emptyElement'),l=t.is('uiElement');if(a||s||l||o&&g(n,t)){const a=n.clone();t.remove(),a.appendChildren(t),e.insertChildren(r,a),i.push(new A.a(e,r))}else o&&p(t,0,t.childCount,n);r++}let s=0;for(const r of i){if(r.offset-=s,r.offset==t)continue;const e=o(r);e.isEqual(r)||(s++,a--)}return O.a.createFromParentsAndOffsets(e,t,e,a)}function g(e,t){if(e.priority<t.priority)return!0;return!(e.priority>t.priority)&&e.getIdentity()<t.getIdentity()}function f(e){const t=e.nodeBefore;if(t&&t.is('text'))return new A.a(t,t.data.length);const a=e.nodeAfter;return a&&a.is('text')?new A.a(a,0):e}function h(e){if(e.offset==e.parent.data.length)return new A.a(e.parent.parent,e.parent.index+1);if(0===e.offset)return new A.a(e.parent.parent,e.parent.index);const t=e.parent.data.slice(e.offset);return e.parent.data=e.parent.data.slice(0,e.offset),e.parent.parent.insertChildren(e.parent.index+1,new S.a(t)),new A.a(e.parent.parent,e.parent.index+1)}function b(e,t){const a=e.data.length;return e.data+=t.data,t.remove(),new A.a(e,a)}function _(e,t){if(e.name!==t.name||e.priority!==t.priority)return!1;for(const a of e.getAttributeKeys())if('class'!==a&&'style'!==a&&t.hasAttribute(a)&&t.getAttribute(a)!==e.getAttribute(a))return!1;for(const a of e.getStyleNames())if(t.hasStyle(a)&&t.getStyle(a)!==e.getStyle(a))return!1;for(const a of e.getAttributeKeys())'class'!==a&&'style'!==a&&(t.hasAttribute(a)||t.setAttribute(a,e.getAttribute(a)));for(const a of e.getStyleNames())t.hasStyle(a)||t.setStyle(a,e.getStyle(a));for(const a of e.getClassNames())t.hasClass(a)||t.addClass(a);return!0}function k(e,t){if(e.name!==t.name||e.priority!==t.priority)return!1;for(const a of e.getAttributeKeys())if('class'!==a&&'style'!==a&&(!t.hasAttribute(a)||t.getAttribute(a)!==e.getAttribute(a)))return!1;if(!t.hasClass(...e.getClassNames()))return!1;for(const a of e.getStyleNames())if(!t.hasStyle(a)||t.getStyle(a)!==e.getStyle(a))return!1;for(const a of e.getAttributeKeys())'class'!==a&&'style'!==a&&t.removeAttribute(a);return t.removeClass(...e.getClassNames()),t.removeStyle(...e.getStyleNames()),!0}function y(e){return e.start.parent==e.end.parent&&e.start.parent.is('attributeElement')&&0===e.start.offset&&e.end.offset===e.start.parent.childCount}function w(e){for(const t of e){if(!I.some((e)=>t instanceof e))throw new V.b('view-writer-insert-invalid-node');t.is('text')||w(t.getChildren())}}function v(e){return e&&(e.is('containerElement')||e.is('documentFragment'))}function x(e){const t=d(e.start),a=d(e.end);if(!t||!a||t!==a)throw new V.b('view-writer-invalid-range-container')}var A=n(22),C=n(47),T=n(92),P=n(177),E=n(94),S=n(35),O=n(38),V=n(0),R=n(128),F=n(34);a.a={breakAttributes:function(e){return e instanceof A.a?m(e):c(e)},breakContainer:function(e){const t=e.parent;if(!t.is('containerElement'))throw new V.b('view-writer-break-non-container-element: Trying to break an element which is not a container element.');if(!t.parent)throw new V.b('view-writer-break-root: Trying to break root element.');if(e.isAtStart)return A.a.createBefore(t);if(!e.isAtEnd){const a=t.clone(!1);i(A.a.createAfter(t),a);const n=new O.a(e,A.a.createAt(t,'end')),o=new A.a(a,0);s(n,o)}return A.a.createAfter(t)},mergeAttributes:o,mergeContainers:function(e){const t=e.nodeBefore,a=e.nodeAfter;if(!t||!a||!t.is('containerElement')||!a.is('containerElement'))throw new V.b('view-writer-merge-containers-invalid-position: Element before and after given position cannot be merged.');const n=t.getChild(t.childCount-1),o=n instanceof S.a?A.a.createAt(n,'end'):A.a.createAt(t,'end');return s(O.a.createIn(a),A.a.createAt(t,'end')),r(O.a.createOn(a)),o},insert:i,remove:r,clear:function(e,t){x(e);const a=e.getWalker({direction:'backward',ignoreElementEnd:!0});for(const n of a){const a=n.item;let o;if(a.is('element')&&t.isSimilar(a))o=O.a.createOn(a);else if(!n.nextPosition.isAfter(e.start)&&(a.is('text')||a.is('textProxy'))){const e=a.getAncestors().find((e)=>e.is('element')&&t.isSimilar(e));e&&(o=O.a.createIn(e))}o&&(o.end.isAfter(e.end)&&(o.end=e.end),o.start.isBefore(e.start)&&(o.start=e.start),r(o))}},move:s,wrap:l,wrapPosition:function(t,a){if(!(a instanceof T.a))throw new V.b('view-writer-wrap-invalid-attribute');if(a.isSimilar(t.parent))return f(A.a.createFromPosition(t));t.parent.is('text')&&(t=h(t));const n=new T.a;n.priority=e,n.isSimilar=()=>!1,t.parent.insertChildren(t.offset,n);const o=new O.a(t,t.getShiftedBy(1));l(o,a);const i=new A.a(n.parent,n.index);n.remove();const r=i.nodeBefore,s=i.nodeAfter;return r instanceof S.a&&s instanceof S.a?b(r,s):f(i)},unwrap:function(e,t){if(!(t instanceof T.a))throw new V.b('view-writer-unwrap-invalid-attribute');if(x(e),e.isCollapsed)return e;if(e.end.isEqual(e.start.getShiftedBy(1))){const a=e.start.nodeAfter;if(!t.isSimilar(a)&&a instanceof T.a&&k(t,a))return e}const{start:a,end:n}=c(e,!0),i=a.parent,r=u(i,a.offset,n.offset,t),s=o(r.start);s.isEqual(r.start)||r.end.offset--;const l=o(r.end);return new O.a(s,l)},rename:function(e,t){const a=new C.a(t,e.getAttributes());return i(A.a.createAfter(e),a),s(O.a.createIn(e),A.a.createAt(a)),r(O.a.createOn(e)),a}};const I=[S.a,T.a,C.a,P.a,E.a]},function(e,t,a){'use strict';function n(){return null}function o(e,t,a){if(t.keyCode==l.c.arrowright){const e=t.domTarget.ownerDocument.defaultView.getSelection(),n=1==e.rangeCount&&e.getRangeAt(0).collapsed;if(n||t.shiftKey){const t=e.focusNode,o=e.focusOffset,i=a.domPositionToView(t,o);if(null===i)return;let r=!1;const s=i.getLastMatchingPosition((e)=>(e.item.is('uiElement')&&(r=!0),e.item.is('uiElement')||e.item.is('attributeElement')));if(r){const t=a.viewPositionToDom(s);n?e.collapse(t.parent,t.offset):e.extend(t.parent,t.offset)}}}}t.b=function(e){e.on('keydown',(t,a)=>o(t,a,e.domConverter))};var i=a(27),r=a(0),s=a(84),l=a(28);class d extends i.a{constructor(e,t,a){super(e,t,a),this.getFillerOffset=n}is(e,t=null){return t?'uiElement'==e&&t==this.name||super.is(e,t):'uiElement'==e||super.is(e)}insertChildren(e,t){if(t&&(t instanceof s.a||0<Array.from(t).length))throw new r.b('view-uielement-cannot-add: Cannot add child nodes to UIElement instance.')}render(e){const t=e.createElement(this.name);for(const a of this.getAttributeKeys())t.setAttribute(a,this.getAttribute(a));return t}}t.a=d},function(e,t,a){'use strict';var n=a(40),o=a(3),i=a(0),r=a(23),s=a(361);class l extends n.a{constructor(e,t,a,n,i){super(i),this.range=o.a.createFromRange(e),this.key=t,this.oldValue=a===void 0?null:a,this.newValue=n===void 0?null:n}get type(){return null===this.oldValue?'addAttribute':null===this.newValue?'removeAttribute':'changeAttribute'}clone(){return new l(this.range,this.key,this.oldValue,this.newValue,this.baseVersion)}getReversed(){return new l(this.range,this.key,this.newValue,this.oldValue,this.baseVersion+1)}_execute(){for(const e of this.range.getItems()){if(null!==this.oldValue&&!Object(s.a)(e.getAttribute(this.key),this.oldValue))throw new i.b('attribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s old attribute value.',{item:e,key:this.key,value:this.oldValue});if(null===this.oldValue&&null!==this.newValue&&e.hasAttribute(this.key))throw new i.b('attribute-operation-attribute-exists: The attribute with given key already exists.',{node:e,key:this.key})}return Object(s.a)(this.oldValue,this.newValue)||r.a.setAttribute(this.range,this.key,this.newValue),{range:this.range,key:this.key,oldValue:this.oldValue,newValue:this.newValue}}static get className(){return'engine.model.operation.AttributeOperation'}static fromJSON(e,t){return new l(o.a.fromJSON(e.range,t),e.key,e.oldValue,e.newValue,e.baseVersion)}}t.a=l},function(e,t,a){'use strict';function n(e,t,a,s,l){return!(e!==t)||(null!=e&&null!=t&&(Object(i.a)(e)||Object(r.a)(t))?Object(o.a)(e,t,n,a,s,l):e!==e&&t!==t)}var o=a(362),i=a(17),r=a(44);t.a=n},function(e,t,a){'use strict';function n(e){var t=-1,a=e?e.length:0;for(this.__data__=new o.a;++t<a;)this.add(e[t])}var o=a(123),i=a(363),r=a(364);n.prototype.add=n.prototype.push=i.a,n.prototype.has=r.a,t.a=n},function(e,t,a){'use strict';var n=a(29),o=a(41);class i extends n.a{get position(){return this.targetPosition}set position(e){this.targetPosition=e}get type(){return'reinsert'}getReversed(){const e=this.sourcePosition._getTransformedByInsertion(this.targetPosition,this.howMany);return new o.a(this.getMovedRangeStart(),this.howMany,e,this.baseVersion+1)}static get className(){return'engine.model.operation.ReinsertOperation'}}t.a=i},function(e,t,a){'use strict';function n(e,t,a){const n=new c;e.addDelta(n);const o=e.document.graveyard,i=new l.a(o,[0]),r=new s.a(t,a,i,e.document.version);n.addOperation(r),e.document.applyOperation(r)}var o=a(100),i=a(20),r=a(19),s=a(41),l=a(1),d=a(3);class c extends o.a{static get className(){return'engine.model.delta.RemoveDelta'}}t.a=c,Object(i.b)('remove',function(e){if(e instanceof d.a){const t=e.getMinimalFlatRanges().reverse();for(const e of t)n(this,e.start,e.end.offset-e.start.offset)}else n(this,l.a.createBefore(e),1);return this}),r.a.register(c)},function(e,t,a){'use strict';function n(e,t,a,n,o){const i=new s.a(a,n,o,e.document.version);t.addOperation(i),e.document.applyOperation(i)}var o=a(24),i=a(19),r=a(20),s=a(29),l=a(1),d=a(3),c=a(0);class m extends o.a{get type(){return'move'}get howMany(){return this._moveOperation?this._moveOperation.howMany:null}get sourcePosition(){return this._moveOperation?this._moveOperation.sourcePosition:null}get targetPosition(){return this._moveOperation?this._moveOperation.targetPosition:null}get _moveOperation(){return this.operations[0]||null}get _reverseDeltaClass(){return m}static get className(){return'engine.model.delta.MoveDelta'}}t.a=m,Object(r.b)('move',function(e,t){const a=new m;if(this.addDelta(a),e instanceof d.a){if(!e.isFlat)throw new c.b('batch-move-range-not-flat: Range to move is not flat.');n(this,a,e.start,e.end.offset-e.start.offset,t)}else n(this,a,l.a.createBefore(e),1,t);return this}),i.a.register(m)},function(e,t,a){'use strict';var n=a(24),o=a(19),i=a(102),r=a(20),s=a(1),l=a(5),d=a(41),c=a(29),m=a(0);class u extends n.a{get type(){return'merge'}get position(){return this._removeOperation?this._removeOperation.sourcePosition:null}get _removeOperation(){return this.operations[1]||null}get _reverseDeltaClass(){return i.a}static get className(){return'engine.model.delta.MergeDelta'}}t.a=u,Object(r.b)('merge',function(e){const t=new u;this.addDelta(t);const a=e.nodeBefore,n=e.nodeAfter;if(!(a instanceof l.a))throw new m.b('batch-merge-no-element-before: Node before merge position must be an element.');if(!(n instanceof l.a))throw new m.b('batch-merge-no-element-after: Node after merge position must be an element.');const o=s.a.createFromParentAndOffset(n,0),i=s.a.createFromParentAndOffset(a,a.maxOffset),r=new c.a(o,n.maxOffset,i,this.document.version);r.isSticky=!0,t.addOperation(r),this.document.applyOperation(r);const p=this.document.graveyard,g=new s.a(p,[0]),f=new d.a(e,1,g,this.document.version);return t.addOperation(f),this.document.applyOperation(f),this}),o.a.register(u)},function(e,t,a){'use strict';var n=a(24),o=a(19),i=a(20),r=a(1),s=a(5),l=a(48),d=a(29),c=a(0),m=a(101);class u extends n.a{get type(){return'split'}get position(){return this._moveOperation?this._moveOperation.sourcePosition:null}get _cloneOperation(){return this.operations[0]||null}get _moveOperation(){return this.operations[1]&&this.operations[1]instanceof d.a?this.operations[1]:null}get _reverseDeltaClass(){return m.a}static get className(){return'engine.model.delta.SplitDelta'}}t.a=u,Object(i.b)('split',function(e){const t=new u;this.addDelta(t);const a=e.parent;if(!a.parent)throw new c.b('batch-split-root: Root element can not be split.');const n=new s.a(a.name,a.getAttributes()),o=new l.a(r.a.createAfter(a),n,this.document.version);t.addOperation(o),this.document.applyOperation(o);const i=new d.a(e,a.maxOffset-e.offset,r.a.createFromParentAndOffset(n,0),this.document.version);return i.isSticky=!0,t.addOperation(i),this.document.applyOperation(i),this}),o.a.register(u)},function(e,t,a){'use strict';var n=a(24),o=a(19),i=a(104),r=a(20),s=a(1),l=a(41),d=a(29),c=a(0);class m extends n.a{get type(){return'unwrap'}get position(){return this._moveOperation?this._moveOperation.targetPosition:null}get _moveOperation(){return this.operations[0]||null}get _reverseDeltaClass(){return i.a}static get className(){return'engine.model.delta.UnwrapDelta'}}t.a=m,Object(r.b)('unwrap',function(e){if(null===e.parent)throw new c.b('batch-unwrap-element-no-parent: Trying to unwrap an element which has no parent.');const t=new m;this.addDelta(t);const a=s.a.createFromParentAndOffset(e,0),n=new d.a(a,e.maxOffset,s.a.createBefore(e),this.document.version);n.isSticky=!0,t.addOperation(n),this.document.applyOperation(n);const o=this.document.graveyard,i=new s.a(o,[0]),r=new l.a(s.a.createBefore(e),1,i,this.document.version);return t.addOperation(r),this.document.applyOperation(r),this}),o.a.register(m)},function(e,t,a){'use strict';var n=a(24),o=a(19),i=a(103),r=a(20),s=a(1),l=a(3),d=a(5),c=a(48),m=a(29),u=a(0);class p extends n.a{get type(){return'wrap'}get range(){const e=this._moveOperation;return e?l.a.createFromPositionAndShift(e.sourcePosition,e.howMany):null}get howMany(){const e=this.range;return e?e.end.offset-e.start.offset:0}get _insertOperation(){return this.operations[0]||null}get _moveOperation(){return this.operations[1]||null}get _reverseDeltaClass(){return i.a}static get className(){return'engine.model.delta.WrapDelta'}}t.a=p,Object(r.b)('wrap',function(e,t){if(!e.isFlat)throw new u.b('batch-wrap-range-not-flat: Range to wrap is not flat.');const a=t instanceof d.a?t:new d.a(t);if(0<a.childCount)throw new u.b('batch-wrap-element-not-empty: Element to wrap with is not empty.');if(null!==a.parent)throw new u.b('batch-wrap-element-attached: Element to wrap with is already attached to tree model.');const n=new p;this.addDelta(n);const o=new c.a(e.end,a,this.document.version);n.addOperation(o),this.document.applyOperation(o);const i=s.a.createFromParentAndOffset(a,0),r=new m.a(e.start,e.end.offset-e.start.offset,i,this.document.version);return n.addOperation(r),this.document.applyOperation(r),this}),o.a.register(p)},function(e,t,a){'use strict';var n=a(15),o=a(381);t.a=function(e){return Object(n.a)(e)?e:Object(o.a)(e)}},function(e,t,a){'use strict';var n=a(42);t.a=function(e,t,a,o){for(var i=e.length,r=o?i:-1;(o?r--:++r<i)&&t(e[r],r,e););return a?Object(n.a)(e,o?0:r,o?r+1:i):Object(n.a)(e,o?r+1:0,o?i:r)}},function(e,t,a){'use strict';var n=a(148),o=a(192),i=a(46);t.a=function(e,t,a){var r=0,s=e?e.length:r;if('number'==typeof t&&t===t&&s<=4294967295>>>1){for(;r<s;){var l=r+s>>>1,d=e[l];null!==d&&!Object(i.a)(d)&&(a?d<=t:d<t)?r=l+1:s=l}return s}return Object(n.a)(e,t,o.a,a)}},function(e,t,a){'use strict';var n=a(109),i=a(30),r=a(118),s=a(162),l=a(14);t.a=function(e){if(!(e&&e.length))return[];var t=0;return e=Object(n.a)(e,function(e){if(Object(l.a)(e))return t=o(e.length,t),!0}),Object(s.a)(t,function(t){return Object(i.a)(e,Object(r.a)(t))})}},function(e,t){'use strict';t.a=function(e,t){for(var a=-1,n=e.length,o=0,i=[];++a<n;){var r=e[a];t(r,a,e)&&(i[o++]=r)}return i}},function(e,t,a){'use strict';function n(e){return e['data-ck-expando']||(e['data-ck-expando']=Object(r.a)())}function o(e){return e&&Object(l.a)(e.addEventListener)}var i=a(8),r=a(52),s=a(45),l=a(166);const d=Object(s.a)({},i.c,{listenTo(...e){const t=e[0];o(t)&&(e[0]=this._getProxyEmitter(t)||new c(t)),i.c.listenTo.apply(this,e)},stopListening(...e){const t=e[0];if(o(t)){const a=this._getProxyEmitter(t);if(!a)return;e[0]=a}i.c.stopListening.apply(this,e)},_getProxyEmitter(e){return Object(i.a)(this,n(e))}});t.a=d;class c{constructor(e){Object(i.b)(this,n(e)),this._domNode=e}}Object(s.a)(c.prototype,i.c,{on(e,t,a={}){if(i.c.on.call(this,e,t,a),!(this._domListeners&&this._domListeners[e])){const t=this._createDomListener(e,!!a.useCapture);this._domNode.addEventListener(e,t,!!a.useCapture),this._domListeners||(this._domListeners={}),this._domListeners[e]=t}},off(e,t,a){i.c.off.call(this,e,t,a);let n;!this._domListeners[e]||(n=this._events[e])&&n.callbacks.length||this._domListeners[e].removeListener()},_createDomListener(e,t){const a=(t)=>{this.fire(e,t)};return a.removeListener=()=>{this._domNode.removeEventListener(e,a,t),delete this._domListeners[e]},a}})},function(e,t,a){'use strict';var n=a(0),o=a(38),i=a(22),r=a(4),s=a(8),l=a(27),d=a(152),c=a(34);class m{constructor(e,t){this._ranges=[],this._lastRangeBackward=!1,this._isFake=!1,this._fakeSelectionLabel='',e&&this.setRanges(e,t)}setFake(e=!0,t={}){this._isFake=e,this._fakeSelectionLabel=e?t.label||'':'',this.fire('change')}get isFake(){return this._isFake}get fakeSelectionLabel(){return this._fakeSelectionLabel}get anchor(){if(!this._ranges.length)return null;const e=this._ranges[this._ranges.length-1],t=this._lastRangeBackward?e.end:e.start;return i.a.createFromPosition(t)}get focus(){if(!this._ranges.length)return null;const e=this._ranges[this._ranges.length-1],t=this._lastRangeBackward?e.start:e.end;return i.a.createFromPosition(t)}get isCollapsed(){return 1===this.rangeCount&&this._ranges[0].isCollapsed}get rangeCount(){return this._ranges.length}get isBackward(){return!this.isCollapsed&&this._lastRangeBackward}get editableElement(){return this.anchor?this.anchor.editableElement:null}addRange(e,t){if(!(e instanceof o.a))throw new n.b('view-selection-invalid-range: Invalid Range.');this._pushRange(e),this._lastRangeBackward=!!t,this.fire('change')}*getRanges(){for(const e of this._ranges)yield o.a.createFromRange(e)}getFirstRange(){let e=null;for(const t of this._ranges)(!e||t.start.isBefore(e.start))&&(e=t);return e?o.a.createFromRange(e):null}getLastRange(){let e=null;for(const t of this._ranges)(!e||t.end.isAfter(e.end))&&(e=t);return e?o.a.createFromRange(e):null}getFirstPosition(){const e=this.getFirstRange();return e?i.a.createFromPosition(e.start):null}getLastPosition(){const e=this.getLastRange();return e?i.a.createFromPosition(e.end):null}isEqual(e){if(this.isFake!=e.isFake)return!1;if(this.isFake&&this.fakeSelectionLabel!=e.fakeSelectionLabel)return!1;if(this.rangeCount!=e.rangeCount)return!1;if(0===this.rangeCount)return!0;if(!this.anchor.isEqual(e.anchor)||!this.focus.isEqual(e.focus))return!1;for(const t of this._ranges){let a=!1;for(const n of e._ranges)if(t.isEqual(n)){a=!0;break}if(!a)return!1}return!0}isSimilar(e){if(this.isBackward!=e.isBackward)return!1;const t=Object(d.a)(this.getRanges()),a=Object(d.a)(e.getRanges());if(t!=a)return!1;if(0==t)return!0;for(let t of this.getRanges()){t=t.getTrimmed();let a=!1;for(let n of e.getRanges())if(n=n.getTrimmed(),t.start.isEqual(n.start)&&t.end.isEqual(n.end)){a=!0;break}if(!a)return!1}return!0}removeAllRanges(){this._ranges.length&&(this._ranges=[],this.fire('change'))}setRanges(e,t){this._ranges=[];for(const a of e){if(!(a instanceof o.a))throw new n.b('view-selection-invalid-range: Invalid Range.');this._pushRange(a)}this._lastRangeBackward=!!t,this.fire('change')}setTo(e){e instanceof m?(this._isFake=e._isFake,this._fakeSelectionLabel=e._fakeSelectionLabel,this.setRanges(e.getRanges(),e.isBackward)):e instanceof o.a?this.setRanges([e]):Object(c.a)(e)?this.setRanges(e):this.setRanges([new o.a(e)])}setIn(e){this.setRanges([o.a.createIn(e)])}setOn(e){this.setRanges([o.a.createOn(e)])}setCollapsedAt(e,t){const a=i.a.createAt(e,t),n=new o.a(a,a);this.setRanges([n])}collapseToStart(){const e=this.getFirstPosition();null!==e&&this.setRanges([new o.a(e,e)])}collapseToEnd(){const e=this.getLastPosition();null!==e&&this.setRanges([new o.a(e,e)])}moveFocusTo(e,t){if(null===this.anchor)throw new n.b('view-selection-moveFocusTo-no-ranges: Cannot set selection focus if there are no ranges in selection.');const a=i.a.createAt(e,t);if('same'!=a.compareWith(this.focus)){const e=this.anchor;this._ranges.pop(),'before'==a.compareWith(e)?this.addRange(new o.a(a,e),!0):this.addRange(new o.a(e,a))}}getSelectedElement(){if(1!==this.rangeCount)return null;const e=this.getFirstRange(),t=e.start.nodeAfter,a=e.end.nodeBefore;return t instanceof l.a&&t==a?t:null}static createFromSelection(e){const t=new m;return t.setTo(e),t}_pushRange(e){for(const t of this._ranges)if(e.isIntersecting(t))throw new n.b('view-selection-range-intersects: Trying to add a range that intersects with another range from selection.',{addedRange:e,intersectingRange:t});this._ranges.push(o.a.createFromRange(e))}}t.a=m,Object(r.a)(m,s.c)},function(e,t,a){'use strict';function n(e){return e.every((e)=>'string'==typeof e)}var o=a(0),i=a(12),r=a(113),s=a(4);class l extends r.a{constructor(e){super({idProperty:'viewUid'}),this.on('add',(e,t,a)=>{t.element&&this._parentElement&&this._parentElement.insertBefore(t.element,this._parentElement.children[a])}),this.on('remove',(e,t)=>{t.element&&this._parentElement&&t.element.remove()}),this.locale=e,this.set('ready',!1),this._parentElement=null}init(){if(this.ready)throw new o.b('ui-viewcollection-init-reinit: This ViewCollection has already been initialized.');this.map((e)=>e.init()),this.ready=!0}destroy(){this.map((e)=>e.destroy())}add(e,t){super.add(e,t),this.ready&&!e.ready&&e.init()}setParent(e){this._parentElement=e}delegate(...e){if(!e.length||!n(e))throw new o.b('ui-viewcollection-delegate-wrong-events: All event names must be strings.');return{to:(t)=>{for(const a of this)for(const n of e)a.delegate(n).to(t);this.on('add',(a,n)=>{for(const o of e)n.delegate(o).to(t)}),this.on('remove',(a,n)=>{for(const o of e)n.stopDelegating(o,t)})}}}}t.a=l,Object(s.a)(r.a,i.a)},function(e,t,a){'use strict';var n=a(8),o=a(0),i=a(52),r=a(4);class s{constructor(e){this._items=[],this._itemMap=new Map,this._idProperty=e&&e.idProperty||'id',this._bindToExternalToInternalMap=new WeakMap,this._bindToInternalToExternalMap=new WeakMap}get length(){return this._items.length}add(e,t){let a;const n=this._idProperty;if(n in e){if(a=e[n],'string'!=typeof a)throw new o.b('collection-add-invalid-id');if(this.get(a))throw new o.b('collection-add-item-already-exists')}else e[n]=a=Object(i.a)();if(void 0===t)t=this._items.length;else if(t>this._items.length||0>t)throw new o.b('collection-add-item-invalid-index');return this._items.splice(t,0,e),this._itemMap.set(a,e),this.fire('add',e,t),this}get(e){let t;if('string'==typeof e)t=this._itemMap.get(e);else if('number'==typeof e)t=this._items[e];else throw new o.b('collection-get-invalid-arg: Index or id must be given.');return t||null}getIndex(e){let t;return t='string'==typeof e?this._itemMap.get(e):e,this._items.indexOf(t)}remove(e){let t=!1,a,n,i;const r=this._idProperty;if('string'==typeof e?(n=e,i=this._itemMap.get(n),t=!i,i&&(a=this._items.indexOf(i))):'number'==typeof e?(a=e,i=this._items[a],t=!i,i&&(n=i[r])):(i=e,n=i[r],a=this._items.indexOf(i),t=-1==a||!this._itemMap.get(n)),t)throw new o.b('collection-remove-404: Item not found.');this._items.splice(a,1),this._itemMap.delete(n);const s=this._bindToInternalToExternalMap.get(i);return this._bindToInternalToExternalMap.delete(i),this._bindToExternalToInternalMap.delete(s),this.fire('remove',i),i}map(e,t){return this._items.map(e,t)}find(e,t){return this._items.find(e,t)}filter(e,t){return this._items.filter(e,t)}clear(){for(this._bindToCollection&&(this.stopListening(this._bindToCollection),this._bindToCollection=null);this.length;)this.remove(0)}bindTo(e){if(this._bindToCollection)throw new o.b('collection-bind-to-rebind: The collection cannot be bound more than once.');return this._bindToCollection=e,{as:(e)=>{this._setUpBindToBinding((t)=>new e(t))},using:(e)=>{'function'==typeof e?this._setUpBindToBinding((t)=>e(t)):this._setUpBindToBinding((t)=>t[e])}}}_setUpBindToBinding(e){const t=this._bindToCollection,a=(a,n,o)=>{const i=t._bindToCollection==this,r=t._bindToInternalToExternalMap.get(n);if(i&&r)this._bindToExternalToInternalMap.set(n,r),this._bindToInternalToExternalMap.set(r,n);else{const t=e(n);this._bindToExternalToInternalMap.set(n,t),this._bindToInternalToExternalMap.set(t,n),this.add(t,o)}};for(const n of t)a(null,n);this.listenTo(t,'add',a),this.listenTo(t,'remove',(e,t)=>{const a=this._bindToExternalToInternalMap.get(t);a&&this.remove(a)})}[Symbol.iterator](){return this._items[Symbol.iterator]()}}t.a=s,Object(r.a)(s,n.c)},function(e,t,a){'use strict';function n(e){return!!(e.focus&&'none'!=o.a.window.getComputedStyle(e.element).display)}var o=a(60);class i{constructor(e){if(Object.assign(this,e),e.actions&&e.keystrokeHandler)for(const t in e.actions){let a=e.actions[t];'string'==typeof a&&(a=[a]);for(const n of a)e.keystrokeHandler.set(n,(e,a)=>{this[t](),a()})}}get first(){return this.focusables.find(n)||null}get last(){return this.focusables.filter(n).slice(-1)[0]||null}get next(){return this._getFocusableItem(1)}get previous(){return this._getFocusableItem(-1)}get current(){let e=null;return null===this.focusTracker.focusedElement?null:(this.focusables.find((t,a)=>{const n=t.element===this.focusTracker.focusedElement;return n&&(e=a),n}),e)}focusFirst(){this._focus(this.first)}focusLast(){this._focus(this.last)}focusNext(){this._focus(this.next)}focusPrevious(){this._focus(this.previous)}_focus(e){e&&e.focus()}_getFocusableItem(e){const t=this.current,a=this.focusables.length;if(!a)return null;if(null===t)return this[1===e?'first':'last'];let o=(t+a+e)%a;do{const t=this.focusables.get(o);if(n(t))return t;o=(o+a+e)%a}while(o!==t);return null}}t.a=i},function(e,t,a){'use strict';function n(e,t,a,n){if(a.test(t.input,{name:t.input.name})&&r(t.input,t.context,n.schema,!1)){t.context.push('paragraph');const e=n.convertItem(t.input,a,t);t.context.pop(),t.output=e}}function o(e,t,a,n){if(!t.output)return;const o=g.paragraphLikeElements.has(t.input.name)&&!t.output.is('element'),i=t.input.is('documentFragment')||t.input.is('element')&&t.output.is('element')||o;if(!i)return;const s=t.output.is('element');s&&t.context.push(t.output);let l=null;for(let s=0;s<t.output.childCount;s++){const e=t.output.getChild(s);r(e,t.context,n.schema,o)?(l?s--:(l=new c.a('paragraph'),t.output.insertChildren(e.index,l)),e.remove(),l.appendChildren(e)):l=null}s&&t.context.pop()}function r(e,t,a,n){const o=e.name||'$text';return!n&&a.check({name:o,inside:t})?!1:!!a.check({name:'paragraph',inside:t})&&!!a.check({name:o,inside:t.concat('paragraph')})}function i(e,t){for(const a of e.getRootNames()){const n=e.getRoot(a);n.isEmpty?!f.has(n)&&f.set(n,t):f.delete(n)}}function s(){for(const[e,t]of f){const a=t.document,n=a.schema;n.check({name:'paragraph',inside:[e]})&&a.enqueueChanges(()=>{f.delete(e),t.insert(m.a.createAt(e),new c.a('paragraph'))})}}var l=a(520),d=a(2),c=a(5),m=a(1),u=a(51),p=a(43);class g extends d.a{static get pluginName(){return'Paragraph'}init(){const e=this.editor,t=e.document,a=e.data,r=e.editing;e.commands.add('paragraph',new l.a(e)),t.schema.registerItem('paragraph','$block'),Object(u.a)().for(a.modelToView,r.modelToView).fromElement('paragraph').toElement('p'),Object(p.a)().for(a.viewToModel).fromElement('p').toElement('paragraph'),a.viewToModel.on('element',n,{priority:'low'}),a.viewToModel.on('text',n,{priority:'lowest'}),a.viewToModel.on('element',o,{priority:'lowest'}),a.viewToModel.on('documentFragment',o,{priority:'lowest'}),t.on('change',(e,a,n,o)=>{'transparent'==o.type||i(t,o)}),t.on('changesDone',s,{priority:'lowest'}),e.on('dataReady',()=>{i(t,t.batch('transparent')),s()},{priority:'lowest'})}}t.a=g,g.paragraphLikeElements=new Set(['blockquote','dd','div','dt','h1','h2','h3','h4','h5','h6','li','p','td']);const f=new Map},function(e,t){'use strict';var a=Object.getPrototypeOf;t.a=function(e){return a(Object(e))}},function(e,t,a){'use strict';var n=a(64);t.a=function(e,t,a,o){a||(a={});for(var i=-1,r=t.length;++i<r;){var s=t[i],l=o?o(a[s],e[s],s,a,e):e[s];Object(n.a)(a,s,l)}return a}},function(e,t){'use strict';t.a=function(e){return function(t){return null==t?void 0:t[e]}}},function(e,t,a){'use strict';var n=a(14),o=Object.prototype,i=o.hasOwnProperty,r=o.toString,s=o.propertyIsEnumerable;t.a=function(e){return Object(n.a)(e)&&i.call(e,'callee')&&(!s.call(e,'callee')||r.call(e)=='[object Arguments]')}},function(e,t,a){'use strict';var n=a(15),o=a(44),i=Object.prototype,r=i.toString;t.a=function(e){return'string'==typeof e||!Object(n.a)(e)&&Object(o.a)(e)&&r.call(e)=='[object String]'}},function(e,t,a){'use strict';t.a=function(e){return Object(n.a)(e)?Object(o.a)(e):new Map(e)};var n=a(77),o=a(164)},function(e,t,a){'use strict';function n(e){this.__data__=new o.a(e)}var o=a(85),i=a(307),r=a(308),s=a(309),l=a(310),d=a(311);n.prototype.clear=i.a,n.prototype['delete']=r.a,n.prototype.get=s.a,n.prototype.has=l.a,n.prototype.set=d.a,t.a=n},function(e,t,a){'use strict';function n(e){var t=-1,a=e?e.length:0;for(this.clear();++t<a;){var n=e[t];this.set(n[0],n[1])}}var o=a(312),i=a(319),r=a(321),s=a(322),l=a(323);n.prototype.clear=o.a,n.prototype['delete']=i.a,n.prototype.get=r.a,n.prototype.has=s.a,n.prototype.set=l.a,t.a=n},function(e,t,a){'use strict';function n(e){return h.call(e)}var o=a(331),i=a(168),r=a(332),s=a(172),l=a(333),d=a(167),c='[object Map]',m='[object Promise]',u='[object Set]',p='[object WeakMap]',g='[object DataView]',f=Object.prototype,h=f.toString,b=Object(d.a)(o.a),_=Object(d.a)(i.a),k=Object(d.a)(r.a),y=Object(d.a)(s.a),w=Object(d.a)(l.a);(o.a&&n(new o.a(new ArrayBuffer(1)))!=g||i.a&&n(new i.a)!=c||r.a&&n(r.a.resolve())!=m||s.a&&n(new s.a)!=u||l.a&&n(new l.a)!=p)&&(n=function(e){var t=h.call(e),a=t=='[object Object]'?e.constructor:void 0,n=a?Object(d.a)(a):void 0;if(n)switch(n){case b:return g;case _:return c;case k:return m;case y:return u;case w:return p;}return t}),t.a=n},function(e,t,a){'use strict';var n=a(173);t.a=function(e){var t=new e.constructor(e.byteLength);return new n.a(t).set(new n.a(e)),t}},function(e,t){'use strict';t.a=function(e){var t=-1,a=Array(e.size);return e.forEach(function(e,n){a[++t]=[n,e]}),a}},function(e,t,a){'use strict';var n=a(33),o=n.a.Symbol;t.a=o},function(e,t,a){'use strict';function n(e){return'string'==typeof e?[new o.a(e)]:(Object(r.a)(e)||(e=[e]),Array.from(e).map((e)=>'string'==typeof e?new o.a(e):e))}var o=a(35),i=a(4),r=a(34),s=a(8);class l{constructor(e){this._children=[],e&&this.insertChildren(0,e)}[Symbol.iterator](){return this._children[Symbol.iterator]()}get childCount(){return this._children.length}get isEmpty(){return 0===this.childCount}get root(){return this}get parent(){return null}is(e){return'documentFragment'==e}appendChildren(e){return this.insertChildren(this.childCount,e)}getChild(e){return this._children[e]}getChildIndex(e){return this._children.indexOf(e)}getChildren(){return this._children[Symbol.iterator]()}insertChildren(e,t){this._fireChange('children',this);let a=0;t=n(t);for(const n of t)null!==n.parent&&n.remove(),n.parent=this,this._children.splice(e,0,n),e++,a++;return a}removeChildren(e,t=1){this._fireChange('children',this);for(let a=e;a<e+t;a++)this._children[a].parent=null;return this._children.splice(e,t)}_fireChange(e,t){this.fire('change:'+e,t)}}t.a=l,Object(i.a)(l,s.c)},function(e,t,a){'use strict';function n(e,t,a,n){n instanceof p.a?i(e,e.document,t,a,n):o(e,e.document,t,a,n)}function o(e,t,a,n,o){const i=o.getAttribute(a);let r,s;const l=o.is('rootElement')?new f:new g;i!=n&&(e.addDelta(l),o.is('rootElement')?s=new c.a(o,a,i,n,t.version):(r=o.is('element')?new p.a(u.a.createBefore(o),u.a.createFromParentAndOffset(o,0)):new p.a(u.a.createBefore(o),u.a.createAfter(o)),s=new d.a(r,a,i,n,t.version)),l.addOperation(s),t.applyOperation(s))}function i(e,t,a,n,o){function i(){0===r.operations.length&&e.addDelta(r);const o=new p.a(s,l),i=new d.a(o,a,c,n,t.version);r.addOperation(i),t.applyOperation(i)}const r=new g;let s=o.start,l,c,m;for(const r of o)m=r.item.getAttribute(a),l&&c!=m&&(c!=n&&i(),s=l),l=r.nextPosition,c=m;l instanceof u.a&&l!=s&&c!=n&&i()}var r=a(24),s=a(19),l=a(20),d=a(95),c=a(132),m=a(72),u=a(1),p=a(3);class g extends r.a{get type(){return'attribute'}get key(){return this.operations[0]?this.operations[0].key:null}get value(){return this.operations[0]?this.operations[0].newValue:null}get range(){if(this._range)return this._range;let e=null,t=null;for(const a of this.operations)a instanceof m.a||((null==e||e.isAfter(a.range.start))&&(e=a.range.start),(null==t||t.isBefore(a.range.end))&&(t=a.range.end));return e&&t?(this._range=new p.a(e,t),this._range):null}get _reverseDeltaClass(){return g}toJSON(){const e=super.toJSON();return delete e._range,e}static get className(){return'engine.model.delta.AttributeDelta'}}t.a=g;class f extends r.a{static get className(){return'engine.model.delta.RootAttributeDelta'}}Object(l.b)('setAttribute',function(e,t,a){return n(this,t,a,e),this}),Object(l.b)('removeAttribute',function(e,t){return n(this,t,null,e),this}),s.a.register(g),s.a.register(f)},function(e,t,a){'use strict';var n=a(40),o=a(3);class i extends n.a{constructor(e,t,a,n,i){super(i),this.name=e,this.oldRange=t?o.a.createFromRange(t):null,this.newRange=a?o.a.createFromRange(a):null,this._markers=n}get type(){return'marker'}clone(){return new i(this.name,this.oldRange,this.newRange,this._markers,this.baseVersion)}getReversed(){return new i(this.name,this.newRange,this.oldRange,this._markers,this.baseVersion+1)}_execute(){const e=this.newRange?'set':'remove';return this._markers[e](this.name,this.newRange),{name:this.name,type:e}}toJSON(){const e=super.toJSON();return delete e._markers,e}static get className(){return'engine.model.operation.MarkerOperation'}static fromJSON(e,t){return new i(e.name,e.oldRange?o.a.fromJSON(e.oldRange,t):null,e.newRange?o.a.fromJSON(e.newRange,t):null,t.markers,e.baseVersion)}}t.a=i},function(e,t,a){'use strict';var n=a(40),o=a(5),i=a(0),r=a(1);class s extends n.a{constructor(e,t,a,n){super(n),this.position=e,this.oldName=t,this.newName=a}get type(){return'rename'}clone(){return new s(r.a.createFromPosition(this.position),this.oldName,this.newName,this.baseVersion)}getReversed(){return new s(r.a.createFromPosition(this.position),this.newName,this.oldName,this.baseVersion+1)}_execute(){const e=this.position.nodeAfter;if(!(e instanceof o.a))throw new i.b('rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.');else if(e.name!==this.oldName)throw new i.b('rename-operation-wrong-name: Element to change has different name than operation\'s old name.');return e.name!=this.newName&&(e.name=this.newName),{element:e,oldName:this.oldName}}static get className(){return'engine.model.operation.RenameOperation'}static fromJSON(e,t){return new s(r.a.fromJSON(e.position,t),e.oldName,e.newName,e.baseVersion)}}t.a=s},function(e,t,a){'use strict';var n=a(40),o=a(0);class i extends n.a{constructor(e,t,a,n,o){super(o),this.root=e,this.key=t,this.oldValue=a,this.newValue=n}get type(){return null===this.oldValue?'addRootAttribute':null===this.newValue?'removeRootAttribute':'changeRootAttribute'}clone(){return new i(this.root,this.key,this.oldValue,this.newValue,this.baseVersion)}getReversed(){return new i(this.root,this.key,this.newValue,this.oldValue,this.baseVersion+1)}_execute(){if(null!==this.oldValue&&this.root.getAttribute(this.key)!==this.oldValue)throw new o.b('rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s old attribute value.',{root:this.root,key:this.key});if(null===this.oldValue&&null!==this.newValue&&this.root.hasAttribute(this.key))throw new o.b('rootattribute-operation-attribute-exists: The attribute with given key already exists.',{root:this.root,key:this.key});return null===this.newValue?this.root.removeAttribute(this.key):this.root.setAttribute(this.key,this.newValue),{root:this.root,key:this.key,oldValue:this.oldValue,newValue:this.newValue}}static get className(){return'engine.model.operation.RootAttributeOperation'}static fromJSON(e,t){if(!t.hasRoot(e.root))throw new o.b('rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.',{rootName:e});return new i(t.getRoot(e.root),e.key,e.oldValue,e.newValue,e.baseVersion)}}t.a=i},function(e,t,a){'use strict';var n=a(24),o=a(99),i=a(19),r=a(48),s=a(20),l=a(23),d=a(39),c=a(3),m=a(1);class u extends n.a{get type(){return'insert'}get position(){return this._insertOperation?this._insertOperation.position:null}get nodes(){return this._insertOperation?this._insertOperation.nodes:null}get _insertOperation(){return this.operations[0]||null}get _reverseDeltaClass(){return o.a}static get className(){return'engine.model.delta.InsertDelta'}}t.a=u,Object(s.b)('insert',function(e,t){const a=Object(l.c)(t);if(0===a.length)return this;const n=new u,o=new r.a(e,a,this.document.version);if(this.addDelta(n),n.addOperation(o),this.document.applyOperation(o),t instanceof d.a)for(const[a,n]of t.markers){const t=m.a.createAt(n.root),o=new c.a(n.start._getCombined(t,e),n.end._getCombined(t,e));this.setMarker(a,o)}return this}),i.a.register(u)},function(e,t,a){'use strict';function n(e,t,a){t.addOperation(a),e.document.applyOperation(a)}var o=a(24),i=a(19),r=a(20),s=a(131),l=a(5),d=a(1),c=a(0);class m extends o.a{get type(){return'rename'}get _reverseDeltaClass(){return m}static get className(){return'engine.model.delta.RenameDelta'}}t.a=m,Object(r.b)('rename',function(e,t){if(!(e instanceof l.a))throw new c.b('batch-rename-not-element-instance: Trying to rename an object which is not an instance of Element.');const a=new m;this.addDelta(a);const o=new s.a(d.a.createBefore(e),e.name,t,this.document.version);return n(this,a,o),this}),i.a.register(m)},function(e,t,a){'use strict';var n=a(136);t.a=function(e,t){return!!e.length&&-1<Object(n.a)(e,t,0)}},function(e,t,a){'use strict';var n=a(187);t.a=function(e,t,a){if(t!==t)return Object(n.a)(e,a);for(var o=a-1,i=e.length;++o<i;)if(e[o]===t)return o;return-1}},function(e,t){'use strict';t.a=function(e,t,a){for(var n=-1,o=e.length;++n<o;)if(a(t,e[n]))return!0;return!1}},function(e,t){'use strict';t.a=function(e){return function(t){return e(t)}}},function(e,t){'use strict';t.a=function(e,t){return e.has(t)}},function(e,t,a){'use strict';var n=a(105),o=a(57),i=a(58);t.a=function(e,t){t=Object(o.a)(t,e)?[t]:Object(n.a)(t);for(var a=0,r=t.length;null!=e&&a<r;)e=e[Object(i.a)(t[a++])];return a&&a==r?e:void 0}},function(e,t,a){'use strict';var o=a(42),i=a(13);t.a=function(e,t,a){var n=e?e.length:0;return n?(t=a||void 0===t?1:Object(i.a)(t),Object(o.a)(e,0>t?0:t,n)):[]}},function(e,t,a){'use strict';var o=a(42),i=a(13);t.a=function(e,t,a){var n=e?e.length:0;return n?(t=a||void 0===t?1:Object(i.a)(t),t=n-t,Object(o.a)(e,0,0>t?0:t)):[]}},function(e,t){'use strict';t.a=function(e){return e&&e.length?e[0]:void 0}},function(e,t,a){'use strict';var o=a(97),i=a(135),r=a(137),s=a(30),l=a(138),d=a(139);t.a=function(e,t,a){for(var c=a?r.a:i.a,m=e[0].length,u=e.length,p=u,g=Array(u),f=Infinity,h=[];p--;){var b=e[p];p&&t&&(b=Object(s.a)(b,Object(l.a)(t))),f=n(b.length,f),g[p]=!a&&(t||120<=m&&120<=b.length)?new o.a(p&&b):void 0}b=e[0];var _=-1,k=g[0];outer:for(;++_<m&&h.length<f;){var y=b[_],w=t?t(y):y;if(y=a||0!==y?y:0,k?!Object(d.a)(k,w):!c(h,w,a)){for(p=u;--p;){var v=g[p];if(v?!Object(d.a)(v,w):!c(e[p],w,a))continue outer}k&&k.push(w),h.push(y)}}return h}},function(e,t,a){'use strict';var n=a(14);t.a=function(e){return Object(n.a)(e)?e:[]}},function(e,t,a){'use strict';var n=a(147);t.a=function(e,t){return e&&e.length&&t&&t.length?Object(n.a)(e,t):e}},function(e,t,a){'use strict';var n=a(30),o=a(136),i=a(394),r=a(138),s=Array.prototype,l=s.splice;t.a=function(e,t,a,s){var d=s?i.a:o.a,c=-1,m=t.length,u=e;for(a&&(u=Object(n.a)(e,Object(r.a)(a)));++c<m;)for(var p=0,g=t[c],f=a?a(g):g;-1<(p=d(u,f,p,s));)u!==e&&l.call(u,p,1),l.call(e,p,1);return e}},function(e,a,o){'use strict';var i=o(46);a.a=function(e,a,o,r){a=o(a);for(var s=0,l=e?e.length:0,d=a!==a,c=null===a,m=Object(i.a)(a),u=void 0===a;s<l;){var p=t((s+l)/2),g=o(e[p]),f=g!==void 0,h=null===g,b=g===g,_=Object(i.a)(g);if(d)var k=r||b;else k=u?b&&(r||f):c?b&&f&&(r||!h):m?b&&f&&!h&&(r||!_):h||_?!1:r?g<=a:g<a;k?s=p+1:l=p}return n(l,4294967295-1)}},function(e,t,a){'use strict';var n=a(158),o=a(30),i=a(108);t.a=function(e,t){if(!(e&&e.length))return[];var a=Object(i.a)(e);return null==t?a:Object(o.a)(a,function(e){return Object(n.a)(t,void 0,e)})}},function(e,t,a){'use strict';var n=a(89),o=a(73),i=a(49);t.a=function(e,t,a){for(var r=-1,s=e.length;++r<s;)var l=l?Object(n.a)(Object(o.a)(l,e[r],t,a),Object(o.a)(e[r],l,t,a)):e[r];return l&&l.length?Object(i.a)(l,t,a):[]}},function(e,t,a){'use strict';function n(){const e=new Set(['insert','move','remove','reinsert']);this.listenTo(this.root.document,'change',(t,a,n,i,r)=>{e.has(a)&&o.call(this,a,r,i,n.range,n.sourcePosition)},{priority:'high'})}function o(e,t,a,n,o){const r=n.end.offset-n.start.offset;let s=n.start;('move'==e||'remove'==e||'reinsert'==e)&&(s=s._getTransformedByInsertion(o,r));const l=this._getTransformedByDocumentChange(e,t,s,r,o);('move'==e||'remove'==e||'reinsert'==e)&&3==l.length&&(l[2]=n);const d=i.a.createFromRanges(l),c=!d.isEqual(this),m=this.containsPosition(s),u=o&&(this.containsPosition(o)||this.start.isEqual(o));if(c){const t=i.a.createFromRange(this);this.start=d.start,this.end=d.end,this.fire('change:range',t,{type:e,batch:a,range:n,sourcePosition:o})}else(m||u)&&this.fire('change:content',i.a.createFromRange(this),{type:e,batch:a,range:n,sourcePosition:o})}var i=a(3),r=a(8),s=a(4);class l extends i.a{constructor(e,t){super(e,t),n.call(this)}detach(){this.stopListening()}}t.a=l,Object(s.a)(l,r.c)},function(e,t){'use strict';function a(e){let t=0;for(const a of e)t++;return t}t.a=a},function(e,t,a){'use strict';function n(e,t,a){let n=Object(f.a)(e);return a&&(n=n.slice(n.indexOf(a)+1)),n.some((e)=>e.tagName&&t.includes(e.tagName.toLowerCase()))}function o(e,t){for(;e&&e!=p.a.document;)t(e),e=e.parentNode}var i=a(35),r=a(27),s=a(22),l=a(38),d=a(111),c=a(128),m=a(68),u=a(74),p=a(60),g=a(414),f=a(252),h=a(415);t.a=class{constructor(e={}){this.blockFiller=e.blockFiller||u.a,this.preElements=['pre'],this.blockElements=['p','div','h1','h2','h3','h4','h5','h6'],this._domToViewMapping=new WeakMap,this._viewToDomMapping=new WeakMap,this._fakeSelectionMapping=new WeakMap}bindFakeSelection(e,t){this._fakeSelectionMapping.set(e,d.a.createFromSelection(t))}fakeSelectionToView(e){return this._fakeSelectionMapping.get(e)}bindElements(e,t){this._domToViewMapping.set(e,t),this._viewToDomMapping.set(t,e)}unbindDomElement(e){const t=this._domToViewMapping.get(e);if(t){this._domToViewMapping.delete(e),this._viewToDomMapping.delete(t);for(const t of Array.from(e.childNodes))this.unbindDomElement(t)}}bindDocumentFragments(e,t){this._domToViewMapping.set(e,t),this._viewToDomMapping.set(t,e)}viewToDom(e,t,a={}){if(e.is('text')){const a=this._processDataFromViewText(e);return t.createTextNode(a)}else{if(this.mapViewToDom(e))return this.mapViewToDom(e);let n;if(e.is('documentFragment'))n=t.createDocumentFragment(),a.bind&&this.bindDocumentFragments(n,e);else{if(e.is('uiElement'))return n=e.render(t),a.bind&&this.bindElements(n,e),n;n=t.createElement(e.name),a.bind&&this.bindElements(n,e);for(const t of e.getAttributeKeys())n.setAttribute(t,e.getAttribute(t))}if(a.withChildren||void 0===a.withChildren)for(const o of this.viewChildrenToDom(e,t,a))n.appendChild(o);return n}}*viewChildrenToDom(e,t,a={}){const n=e.getFillerOffset&&e.getFillerOffset();let o=0;for(const i of e.getChildren())n===o&&(yield this.blockFiller(t)),yield this.viewToDom(i,t,a),o++;n===o&&(yield this.blockFiller(t))}viewRangeToDom(e){const t=this.viewPositionToDom(e.start),a=this.viewPositionToDom(e.end),n=document.createRange();return n.setStart(t.parent,t.offset),n.setEnd(a.parent,a.offset),n}viewPositionToDom(e){const t=e.parent;if(t.is('text')){const a=this.findCorrespondingDomText(t);if(!a)return null;let n=e.offset;return Object(u.i)(a)&&(n+=u.c),{parent:a,offset:n}}else{let a,n,o;if(0===e.offset){if(a=this.mapViewToDom(t),!a)return null;o=a.childNodes[0]}else{const t=e.nodeBefore;if(n=t.is('text')?this.findCorrespondingDomText(t):this.mapViewToDom(e.nodeBefore),!n)return null;a=n.parentNode,o=n.nextSibling}if(this.isText(o)&&Object(u.i)(o))return{parent:o,offset:u.c};const i=n?Object(g.a)(n)+1:0;return{parent:a,offset:i}}}domToView(e,t={}){if(Object(u.g)(e,this.blockFiller))return null;const a=this.getParentUIElement(e,this._domToViewMapping);if(a)return a;if(this.isText(e)){if(Object(u.h)(e))return null;else{const t=this._processDataFromDomText(e);return''===t?null:new i.a(t)}}else if(this.isComment(e))return null;else{if(this.mapDomToView(e))return this.mapDomToView(e);let a;if(this.isDocumentFragment(e))a=new c.a,t.bind&&this.bindDocumentFragments(e,a);else{const n=t.keepOriginalCase?e.tagName:e.tagName.toLowerCase();a=new r.a(n),t.bind&&this.bindElements(e,a);const o=e.attributes;for(let e=o.length-1;0<=e;e--)a.setAttribute(o[e].name,o[e].value)}if(t.withChildren||void 0===t.withChildren)for(const n of this.domChildrenToView(e,t))a.appendChildren(n);return a}}*domChildrenToView(e,t={}){for(let a=0;a<e.childNodes.length;a++){const n=e.childNodes[a],o=this.domToView(n,t);null!==o&&(yield o)}}domSelectionToView(e){if(1===e.rangeCount){let t=e.getRangeAt(0).startContainer;this.isText(t)&&(t=t.parentNode);const a=this.fakeSelectionToView(t);if(a)return a}const t=new d.a,a=this.isDomSelectionBackward(e);for(let n=0;n<e.rangeCount;n++){const o=e.getRangeAt(n),i=this.domRangeToView(o);i&&t.addRange(i,a)}return t}domRangeToView(e){const t=this.domPositionToView(e.startContainer,e.startOffset),a=this.domPositionToView(e.endContainer,e.endOffset);return t&&a?new l.a(t,a):null}domPositionToView(e,t){if(Object(u.g)(e,this.blockFiller))return this.domPositionToView(e.parentNode,Object(g.a)(e));const a=this.mapDomToView(e);if(a&&a.is('uiElement'))return s.a.createBefore(a);if(this.isText(e)){if(Object(u.h)(e))return this.domPositionToView(e.parentNode,Object(g.a)(e));const a=this.findCorrespondingViewText(e);let n=t;return a?(Object(u.i)(e)&&(n-=u.c,n=0>n?0:n),new s.a(a,n)):null}if(0===t){const t=this.mapDomToView(e);if(t)return new s.a(t,0)}else{const a=e.childNodes[t-1],n=this.isText(a)?this.findCorrespondingViewText(a):this.mapDomToView(a);if(n&&n.parent)return new s.a(n.parent,n.index+1)}return null}mapDomToView(e){return this.getParentUIElement(e)||this._domToViewMapping.get(e)}findCorrespondingViewText(e){if(Object(u.h)(e))return null;const t=this.getParentUIElement(e);if(t)return t;const a=e.previousSibling;if(a){if(!this.isElement(a))return null;const e=this.mapDomToView(a);if(e){const t=e.nextSibling;return t instanceof i.a?e.nextSibling:null}}else{const t=this.mapDomToView(e.parentNode);if(t){const e=t.getChild(0);return e instanceof i.a?e:null}}return null}mapViewToDom(e){return this._viewToDomMapping.get(e)}findCorrespondingDomText(e){const t=e.previousSibling;return t&&this.mapViewToDom(t)?this.mapViewToDom(t).nextSibling:!t&&e.parent&&this.mapViewToDom(e.parent)?this.mapViewToDom(e.parent).childNodes[0]:null}focus(e){const t=this.mapViewToDom(e);if(t&&t.ownerDocument.activeElement!==t){const{scrollX:e,scrollY:a}=p.a.window,n=[];o(t,(e)=>{const{scrollLeft:t,scrollTop:a}=e;n.push([t,a])}),t.focus(),o(t,(e)=>{const[t,a]=n.shift();e.scrollLeft=t,e.scrollTop=a}),p.a.window.scrollTo(e,a)}}isText(e){return e&&e.nodeType==Node.TEXT_NODE}isElement(e){return e&&e.nodeType==Node.ELEMENT_NODE}isDocumentFragment(e){return e&&e.nodeType==Node.DOCUMENT_FRAGMENT_NODE}isComment(e){return e&&e.nodeType==Node.COMMENT_NODE}isDomSelectionBackward(e){if(e.isCollapsed)return!1;const t=document.createRange();t.setStart(e.anchorNode,e.anchorOffset),t.setEnd(e.focusNode,e.focusOffset);const a=t.collapsed;return t.detach(),a}getParentUIElement(e){const t=Object(f.a)(e);for(t.pop();t.length;){const e=t.pop(),a=this._domToViewMapping.get(e);if(a&&a.is('uiElement'))return a}return null}isDomSelectionCorrect(e){return this._isDomSelectionPositionCorrect(e.anchorNode,e.anchorOffset)&&this._isDomSelectionPositionCorrect(e.focusNode,e.focusOffset)}_isDomSelectionPositionCorrect(e,t){if(this.isText(e)&&Object(u.i)(e)&&t<u.c)return!1;if(this.isElement(e)&&Object(u.i)(e.childNodes[t]))return!1;const a=this.mapDomToView(e);return a&&a.is('uiElement')?!1:!0}_processDataFromViewText(e){let t=e.data;if(e.getAncestors().some((e)=>this.preElements.includes(e.name)))return t;if(' '==t.charAt(0)){const a=this._getTouchingViewTextNode(e,!1),n=a&&this._nodeEndsWithSpace(a);(n||!a)&&(t='\xA0'+t.substr(1))}if(' '==t.charAt(t.length-1)){const a=this._getTouchingViewTextNode(e,!0);a||(t=t.substr(0,t.length-1)+'\xA0')}return t.replace(/ {2}/g,' \xA0')}_nodeEndsWithSpace(e){if(e.getAncestors().some((e)=>this.preElements.includes(e.name)))return!1;const t=this._processDataFromViewText(e);return' '==t.charAt(t.length-1)}_processDataFromDomText(e){let t=Object(u.e)(e);if(n(e,this.preElements))return t;t=t.replace(/[ \n\t\r]{1,}/g,' ');const a=this._getTouchingDomTextNode(e,!1),o=this._getTouchingDomTextNode(e,!0);return(!a||/[^\S\u00A0]/.test(a.data.charAt(a.data.length-1)))&&(t=t.replace(/^ /,'')),o||(t=t.replace(/ $/,'')),t=t.replace(/ \u00A0/g,'  '),(!a||/[^\S\u00A0]/.test(a.data.charAt(a.data.length-1)))&&(t=t.replace(/^\u00A0/,' ')),o&&'\xA0'!=o.data.charAt(0)||(t=t.replace(/\u00A0( *)$/,' $1')),t}_getTouchingViewTextNode(e,t){const a=new m.a({startPosition:t?s.a.createAfter(e):s.a.createBefore(e),direction:t?'forward':'backward'});for(const n of a){if(n.item.is('containerElement'))return null;if(n.item.is('text'))return n.item}return null}_getTouchingDomTextNode(e,t){if(!e.parentNode)return null;const a=t?'nextNode':'previousNode',o=e.ownerDocument,i=o.createTreeWalker(o.childNodes[0],NodeFilter.SHOW_TEXT);i.currentNode=e;const r=i[a]();if(null!==r){const t=Object(h.a)(e,r);if(t&&!n(e,this.blockElements,t)&&!n(r,this.blockElements,t))return r}return null}}},function(e,t,a){'use strict';var n=a(45);class o{constructor(e,t,a){this.document=e,this.domEvent=t,this.domTarget=t.target,Object(n.a)(this,a)}get target(){return this.document.domConverter.mapDomToView(this.domTarget)}preventDefault(){this.domEvent.preventDefault()}stopPropagation(){this.domEvent.stopPropagation()}}t.a=o},function(e,t){'use strict';t.a=function(e){return'[object Range]'==Object.prototype.toString.apply(e)}},function(e,t,a){'use strict';function n(e,t,a){const n=new r.a;n.on('change:top',(n,o)=>{o.oldDescriptor&&a(e,o.oldDescriptor),o.newDescriptor&&t(e,o.newDescriptor)}),e.setCustomProperty('addHighlight',(e,t)=>n.add(t)),e.setCustomProperty('removeHighlight',(e,t)=>n.remove(t))}function o(e,t){e.setCustomProperty(l,t)}function i(){return null}t.c=function(e){return!!e.getCustomProperty(s)},t.d=function(e,t={}){function a(e){return Array.isArray(e)?e:[e]}return e.setAttribute('contenteditable',!1),e.getFillerOffset=i,e.addClass(d),e.setCustomProperty(s,!0),t.label&&o(e,t.label),n(e,(e,t)=>e.addClass(...a(t.class)),(e,t)=>e.removeClass(...a(t.class))),e},t.b=function(e){const t=e.getCustomProperty(l);return t?'function'==typeof t?t():t:''},t.e=function(e){return e.addClass('ck-editable'),e.setAttribute('contenteditable',!e.isReadOnly),e.on('change:isReadOnly',(t,a,n)=>{e.setAttribute('contenteditable',!n)}),e.on('change:isFocused',(t,a,n)=>{n?e.addClass('ck-editable_focused'):e.removeClass('ck-editable_focused')}),e};var r=a(493);const s=Symbol('isWidget'),l=Symbol('label'),d='ck-widget';t.a='ck-widget_selected'},function(e,t,a){'use strict';var n=a(2),o=a(272),i=a(0),r=a(63);class s extends n.a{static get pluginName(){return'ContextualBalloon'}init(){this.view=new o.a,this.positionLimiter=()=>{const e=this.editor.editing.view,t=e.selection.editableElement;return t?e.domConverter.mapViewToDom(t.root):null},this._stack=new Map,this.editor.ui.focusTracker.add(this.view.element),this.editor.ui.view.body.add(this.view)}get visibleView(){const e=this._stack.get(this.view.content.get(0));return e?e.view:null}hasView(e){return this._stack.has(e)}add(e){if(this.hasView(e.view))throw new i.b('contextualballoon-add-view-exist: Cannot add configuration of the same view twice.');this.visibleView&&this.view.content.remove(this.visibleView),this._stack.set(e.view,e),this._show(e)}remove(e){if(!this.hasView(e))throw new i.b('contextualballoon-remove-view-not-exist: Cannot remove configuration of not existing view.');if(this.visibleView===e){this.view.content.remove(e),this._stack.delete(e);const t=Array.from(this._stack.values()).pop();t?this._show(t):this.view.hide()}else this._stack.delete(e)}updatePosition(e){e&&(this._stack.get(this.visibleView).position=e),this.view.pin(this._getBalloonPosition())}_show({view:e,balloonClassName:t=''}){this.view.className=t,this.view.content.add(e),this.view.pin(this._getBalloonPosition())}_getBalloonPosition(){let e=Object(r.a)(this._stack.values()).position;return e&&!e.limiter&&(e=Object.assign({},e,{limiter:this.positionLimiter})),e}}t.a=s},function(e,t){'use strict';t.a=function(e,t,a){var n=a.length;return 0===n?e.call(t):1===n?e.call(t,a[0]):2===n?e.call(t,a[0],a[1]):3===n?e.call(t,a[0],a[1],a[2]):e.apply(t,a)}},function(e,t,a){'use strict';var n=a(65),o=a(17),i=a(46),r=0/0,s=/^\s+|\s+$/g,l=/^[-+]0x[0-9a-f]+$/i,d=/^0b[01]+$/i,c=/^0o[0-7]+$/i,m=parseInt;t.a=function(e){if('number'==typeof e)return e;if(Object(i.a)(e))return r;if(Object(o.a)(e)){var t=Object(n.a)(e.valueOf)?e.valueOf():e;e=Object(o.a)(t)?t+'':t}if('string'!=typeof e)return 0===e?e:+e;e=e.replace(s,'');var a=d.test(e);return a||c.test(e)?m(e.slice(2),a?2:8):l.test(e)?r:+e}},function(e){e.exports=function(e){if(!e.webpackPolyfill){var t=Object.create(e);t.children||(t.children=[]),Object.defineProperty(t,'loaded',{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,'id',{enumerable:!0,get:function(){return t.i}}),Object.defineProperty(t,'exports',{enumerable:!0}),t.webpackPolyfill=1}return t}},function(e,t,a){'use strict';var n=a(162),o=a(119),i=a(15),r=a(81),s=a(120);t.a=function(e){var t=e?e.length:void 0;return Object(r.a)(t)&&(Object(i.a)(e)||Object(s.a)(e)||Object(o.a)(e))?Object(n.a)(t,String):null}},function(e,t){'use strict';t.a=function(e,t){for(var a=-1,n=Array(e);++a<e;)n[a]=t(a);return n}},function(e,t,a){'use strict';var n=a(1),o=a(3),i=a(22),r=a(38),s=a(35),l=a(8),d=a(4);class c{constructor(){this._modelToViewMapping=new WeakMap,this._viewToModelMapping=new WeakMap,this._viewToModelLengthCallbacks=new Map,this.on('modelToViewPosition',(e,t)=>{if(!t.viewPosition){const e=this._modelToViewMapping.get(t.modelPosition.parent);t.viewPosition=this._findPositionIn(e,t.modelPosition.offset)}},{priority:'low'}),this.on('viewToModelPosition',(e,t)=>{if(t.modelPosition)return;let a=t.viewPosition.parent,o=this._viewToModelMapping.get(a);for(;!o;)a=a.parent,o=this._viewToModelMapping.get(a);const i=this._toModelOffset(t.viewPosition.parent,t.viewPosition.offset,a);t.modelPosition=n.a.createFromParentAndOffset(o,i)},{priority:'low'})}bindElements(e,t){this._modelToViewMapping.set(e,t),this._viewToModelMapping.set(t,e)}unbindViewElement(e){const t=this.toModelElement(e);this._unbindElements(t,e)}unbindModelElement(e){const t=this.toViewElement(e);this._unbindElements(e,t)}clearBindings(){this._modelToViewMapping=new WeakMap,this._viewToModelMapping=new WeakMap}toModelElement(e){return this._viewToModelMapping.get(e)}toViewElement(e){return this._modelToViewMapping.get(e)}toModelRange(e){return new o.a(this.toModelPosition(e.start),this.toModelPosition(e.end))}toViewRange(e){return new r.a(this.toViewPosition(e.start),this.toViewPosition(e.end))}toModelPosition(e){const t={viewPosition:e,mapper:this};return this.fire('viewToModelPosition',t),t.modelPosition}toViewPosition(e){const t={modelPosition:e,mapper:this};return this.fire('modelToViewPosition',t),t.viewPosition}registerViewToModelLength(e,t){this._viewToModelLengthCallbacks.set(e,t)}_toModelOffset(e,t,a){if(a!=e){const n=this._toModelOffset(e.parent,e.index,a),o=this._toModelOffset(e,t,e);return n+o}if(e.is('text'))return t;let n=0;for(let o=0;o<t;o++)n+=this.getModelLength(e.getChild(o));return n}_unbindElements(e,t){this._viewToModelMapping.delete(t),this._modelToViewMapping.delete(e)}getModelLength(e){if(this._viewToModelLengthCallbacks.get(e.name)){const t=this._viewToModelLengthCallbacks.get(e.name);return t(e)}if(this._viewToModelMapping.has(e))return 1;if(e.is('text'))return e.data.length;if(e.is('uiElement'))return 0;else{let t=0;for(const a of e.getChildren())t+=this.getModelLength(a);return t}}_findPositionIn(e,t){let a=0,n=0,o=0,r;if(e.is('text'))return new i.a(e,t);for(;n<t;)r=e.getChild(o),a=this.getModelLength(r),n+=a,o++;return n==t?this._moveViewPositionToTextNode(new i.a(e,o)):this._findPositionIn(r,t-(n-a))}_moveViewPositionToTextNode(e){const t=e.nodeBefore,a=e.nodeAfter;if(t instanceof s.a)return new i.a(t,t.data.length);return a instanceof s.a?new i.a(a,0):e}}t.a=c,Object(d.a)(c,l.c)},function(e,t){'use strict';t.a=function(e){const t=new Map;for(const a in e)t.set(a,e[a]);return t}},function(e,t,a){'use strict';function n(e,t,a,T,P,E,S){var O;if(T&&(O=E?T(e,P,E,S):T(e)),void 0!==O)return O;if(!Object(k.a)(e))return e;var V=Object(h.a)(e);if(!V){var R=Object(u.a)(e),F=R==v||R==x;if(Object(b.a)(e))return Object(l.a)(e,t);if(R==A||R==w||F&&!E){if(Object(_.a)(e))return E?e:{};if(O=Object(f.a)(F?{}:e),!t)return Object(c.a)(e,Object(s.a)(O,e))}else{if(!C[R])return E?e:{};O=Object(g.a)(e,R,n,t)}}else if(O=Object(p.a)(e),!t)return Object(d.a)(e,O);S||(S=new o.a);var I=S.get(e);if(I)return I;if(S.set(e,O),!V)var N=a?Object(m.a)(e):Object(y.a)(e);return Object(i.a)(N||e,function(o,i){N&&(i=o,o=e[i]),Object(r.a)(O,i,n(o,t,a,T,i,e,S))}),O}var o=a(122),i=a(324),r=a(64),s=a(325),l=a(327),d=a(170),c=a(328),m=a(329),u=a(124),p=a(334),g=a(335),f=a(344),h=a(15),b=a(346),_=a(78),k=a(17),y=a(70),w='[object Arguments]',v='[object Function]',x='[object GeneratorFunction]',A='[object Object]',C={};C[w]=C['[object Array]']=C['[object ArrayBuffer]']=C['[object DataView]']=C['[object Boolean]']=C['[object Date]']=C['[object Float32Array]']=C['[object Float64Array]']=C['[object Int8Array]']=C['[object Int16Array]']=C['[object Int32Array]']=C['[object Map]']=C['[object Number]']=C[A]=C['[object RegExp]']=C['[object Set]']=C['[object String]']=C['[object Symbol]']=C['[object Uint8Array]']=C['[object Uint8ClampedArray]']=C['[object Uint16Array]']=C['[object Uint32Array]']=!0,C['[object Error]']=C[v]=C['[object WeakMap]']=!1,t.a=n},function(e,t,a){'use strict';var n=a(65),o=a(78),i=a(17),r=a(167),s=/[\\^$.*+?()[\]{}|]/g,l=/^\[object .+?Constructor\]$/,d=Object.prototype,c=Function.prototype.toString,m=d.hasOwnProperty,u=RegExp('^'+c.call(m).replace(s,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');t.a=function(e){if(!Object(i.a)(e))return!1;var t=Object(n.a)(e)||Object(o.a)(e)?u:l;return t.test(Object(r.a)(e))}},function(e,t){'use strict';var a=Function.prototype.toString;t.a=function(e){if(null!=e){try{return a.call(e)}catch(t){}try{return e+''}catch(t){}}return''}},function(e,t,a){'use strict';var n=a(56),o=a(33),i=Object(n.a)(o.a,'Map');t.a=i},function(e,t,a){'use strict';var n=a(116),o=Object.prototype,i=o.hasOwnProperty;t.a=function(e,t){return i.call(e,t)||'object'==typeof e&&t in e&&null===Object(n.a)(e)}},function(e,t){'use strict';t.a=function(e,t){var a=-1,n=e.length;for(t||(t=Array(n));++a<n;)t[a]=e[a];return t}},function(e,t){'use strict';function a(e){return n(Object(e))}var n=Object.getOwnPropertySymbols;n||(a=function(){return[]}),t.a=a},function(e,t,a){'use strict';var n=a(56),o=a(33),i=Object(n.a)(o.a,'Set');t.a=i},function(e,t,a){'use strict';var n=a(33),o=n.a.Uint8Array;t.a=o},function(e,t){'use strict';t.a=function(e,t,a,n){var o=-1,i=e.length;for(n&&i&&(a=e[++o]);++o<i;)a=t(a,e[o],o,e);return a}},function(e,t){'use strict';function a(e,t){if('function'==typeof t)return t(e);const a={};return t.name&&(a.name=n(t.name,e.name),!a.name)?null:t.attribute&&(a.attribute=o(t.attribute,e),!a.attribute)?null:t.class&&(a.class=i(t.class,e),!a.class)?!1:t.style&&(a.style=r(t.style,e),!a.style)?!1:a}function n(e,t){return e instanceof RegExp?e.test(t):e===t}function o(e,t){const a=[];for(const n in e){const o=e[n];if(t.hasAttribute(n)){const e=t.getAttribute(n);if(o instanceof RegExp){if(o.test(e))a.push(n);else return null;}else if(e===o)a.push(n);else return null}else return null}return a}function i(e,t){const a=[];for(const n of e)if(n instanceof RegExp){const e=t.getClassNames();for(const t of e)n.test(t)&&a.push(t);if(0===a.length)return null}else if(t.hasClass(n))a.push(n);else return null;return a}function r(e,t){const a=[];for(const n in e){const o=e[n];if(t.hasStyle(n)){const e=t.getStyle(n);if(o instanceof RegExp){if(o.test(e))a.push(n);else return null;}else if(e===o)a.push(n);else return null}else return null}return a}t.a=class{constructor(...e){this._patterns=[],this.add(...e)}add(...e){for(let t of e)('string'==typeof t||t instanceof RegExp)&&(t={name:t}),t.class&&('string'==typeof t.class||t.class instanceof RegExp)&&(t.class=[t.class]),this._patterns.push(t)}match(...e){for(const t of e)for(const e of this._patterns){const n=a(t,e);if(n)return{element:t,pattern:e,match:n}}return null}matchAll(...e){const t=[];for(const n of e)for(const e of this._patterns){const o=a(n,e);o&&t.push({element:n,pattern:e,match:o})}return 0<t.length?t:null}getElementName(){if(1!==this._patterns.length)return null;const e=this._patterns[0],t=e.name;return'function'!=typeof e&&t&&!(t instanceof RegExp)?t:null}}},function(e,t,a){'use strict';function n(e,t,a){const n=t.getRange(),o=Array.from(e.getAncestors());o.shift(),o.reverse();const i=o.some((e)=>{if(n.containsItem(e)){const t=a.toViewElement(e);return!!t.getCustomProperty('addHighlight')}});return!i}var o=a(349),i=a(3),r=a(1),s=a(39),l=a(8),d=a(4),c=a(45);class m{constructor(e,t={}){this._modelDocument=e,this.conversionApi=Object(c.a)({dispatcher:this},t)}convertChange(e,t){'remove'!==e&&t.range&&'$graveyard'==t.range.root.rootName||'remove'==e&&'$graveyard'==t.sourcePosition.root.rootName||'rename'==e&&'$graveyard'==t.element.root.rootName||('insert'==e||'reinsert'==e?this.convertInsertion(t.range):'move'==e?this.convertMove(t.sourcePosition,t.range):'remove'==e?this.convertRemove(t.sourcePosition,t.range):'addAttribute'==e||'removeAttribute'==e||'changeAttribute'==e?this.convertAttribute(e,t.range,t.key,t.oldValue,t.newValue):'rename'==e&&this.convertRename(t.element,t.oldName))}convertInsertion(e){const t=this._createInsertConsumable(e);for(const a of e){const e=a.item,n=i.a.createFromPositionAndShift(a.previousPosition,a.length),o={item:e,range:n};this._testAndFire('insert',o,t);for(const a of e.getAttributeKeys())o.attributeKey=a,o.attributeOldValue=null,o.attributeNewValue=e.getAttribute(a),this._testAndFire(`addAttribute:${a}`,o,t)}for(const t of this._modelDocument.markers){const a=t.getRange(),o=a.getIntersection(e);o&&n(e.start,t,this.conversionApi.mapper)&&this.convertMarker('addMarker',t.name,o)}}convertMove(e,t){if(t.start.isBefore(e)){this.convertInsertion(t);const a=e._getTransformedByInsertion(t.start,t.end.offset-t.start.offset);this.convertRemove(a,t)}else this.convertRemove(e,t),this.convertInsertion(t)}convertRemove(e,t){const a=this._createConsumableForRange(t,'remove');for(const n of t.getItems({shallow:!0})){this._testAndFire('remove',{sourcePosition:e,item:n},a)}}convertAttribute(e,t,a,n,o){if(n!=o){const r=this._createConsumableForRange(t,e+':'+a);for(const s of t){const t=s.item,l=i.a.createFromPositionAndShift(s.previousPosition,s.length);this._testAndFire(`${e}:${a}`,{item:t,range:l,attributeKey:a,attributeOldValue:n,attributeNewValue:o},r)}}}convertRename(e,t){if(e.name!=t){const a=e.clone(!0);a.name=t,this.conversionApi.mapper.bindElements(a,this.conversionApi.mapper.toViewElement(e));const n=new s.a;n.appendChildren(a),this.convertRemove(r.a.createBefore(e),i.a.createOn(a)),this.convertInsertion(i.a.createOn(e))}}convertSelection(e){const t=Array.from(this._modelDocument.markers.getMarkersAtPosition(e.getFirstPosition())),a=this._createSelectionConsumable(e,t);this.fire('selection',{selection:e},a,this.conversionApi);for(const o of t){const t=o.getRange();if(!n(e.getFirstPosition(),o,this.conversionApi.mapper))continue;const i={selection:e,markerName:o.name,markerRange:t};a.test(e,'selectionMarker:'+o.name)&&this.fire('selectionMarker:'+o.name,i,a,this.conversionApi)}for(const t of e.getAttributeKeys()){const n={selection:e,key:t,value:e.getAttribute(t)};a.test(e,'selectionAttribute:'+n.key)&&this.fire('selectionAttribute:'+n.key,n,a,this.conversionApi)}}convertMarker(e,t,a){if(a.root.document&&'$graveyard'!=a.root.rootName){const n=e+':'+t;if(a.isCollapsed){const e=new o.a;return e.add(a,n),void this.fire(n,{markerName:t,markerRange:a},e,this.conversionApi)}const r=this._createConsumableForRange(a,n);for(const e of a){const o=e.item;if(!r.test(o,n))continue;const s={item:o,range:i.a.createFromPositionAndShift(e.previousPosition,e.length),markerName:t,markerRange:a};this.fire(n,s,r,this.conversionApi)}}}_createInsertConsumable(e){const t=new o.a;for(const a of e){const e=a.item;t.add(e,'insert');for(const a of e.getAttributeKeys())t.add(e,'addAttribute:'+a)}return t}_createConsumableForRange(e,t){const a=new o.a;for(const n of e.getItems())a.add(n,t);return a}_createSelectionConsumable(e,t){const a=new o.a;a.add(e,'selection');for(const n of t)a.add(e,'selectionMarker:'+n.name);for(const n of e.getAttributeKeys())a.add(e,'selectionAttribute:'+n);return a}_testAndFire(e,t,a){if(a.test(t.item,e)){const n=t.item.name||'$text';this.fire(e+':'+n,t,a,this.conversionApi)}}}t.a=m,Object(d.a)(m,l.c)},function(e,t,a){'use strict';function n(){return null}var o=a(27),i=a(0),r=a(84);class s extends o.a{constructor(e,t,a){super(e,t,a),this.getFillerOffset=n}is(e,t=null){return t?'emptyElement'==e&&t==this.name||super.is(e,t):'emptyElement'==e||super.is(e)}insertChildren(e,t){if(t&&(t instanceof r.a||0<Array.from(t).length))throw new i.b('view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.')}}t.a=s},function(e,t,a){'use strict';function n(){const e=new Set(['insert','move','remove','reinsert']);this.listenTo(this.root.document,'change',(t,a,n)=>{e.has(a)&&o.call(this,a,n.range,n.sourcePosition)},{priority:'high'})}function o(e,t,a){const n=t.end.offset-t.start.offset;let o;switch(e){case'insert':const i='sticksToNext'==this.stickiness;o=this._getTransformedByInsertion(t.start,n,i);break;case'move':case'remove':case'reinsert':const s=r.a.createFromPositionAndShift(a,n),l=s.containsPosition(this)||s.start.isEqual(this)&&'sticksToNext'==this.stickiness||s.end.isEqual(this)&&'sticksToPrevious'==this.stickiness;if(l)o=this._getCombined(a,t.start);else{const e='sticksToNext'==this.stickiness;o=this._getTransformedByMove(a,t.start,n,e)}}if(!this.isEqual(o)){const e=i.a.createFromPosition(this);this.path=o.path,this.root=o.root,this.fire('change',e)}}var i=a(1),r=a(3),s=a(8),l=a(4),d=a(0);class c extends i.a{constructor(e,t,a){if(super(e,t),!this.root.is('rootElement'))throw new d.b('model-liveposition-root-not-rootelement: LivePosition\'s root has to be an instance of RootElement.');this.stickiness=a||'sticksToNext',n.call(this)}detach(){this.stopListening()}}t.a=c,Object(l.a)(c,s.c)},function(e,t){'use strict';function a(e){return!!e&&1==e.length&&/[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(e)}function n(e){return!!e&&1==e.length&&/[\ud800-\udbff]/.test(e)}function o(e){return!!e&&1==e.length&&/[\udc00-\udfff]/.test(e)}t.b=function(e,t){return n(e.charAt(t-1))&&o(e.charAt(t))},t.a=function(e,t){return a(e.charAt(t))}},function(e,t,a){'use strict';var n=a(97),o=a(365);t.a=function(e,t,a,i,r,s){var l=r&2,d=e.length,c=t.length;if(d!=c&&!(l&&c>d))return!1;var m=s.get(e);if(m)return m==t;var u=-1,p=!0,g=r&1?new n.a:void 0;for(s.set(e,t);++u<d;){var f=e[u],h=t[u];if(i)var b=l?i(h,f,u,t,e,s):i(f,h,u,e,t,s);if(void 0!==b){if(b)continue;p=!1;break}if(g){if(!Object(o.a)(t,function(e,t){if(!g.has(t)&&(f===e||a(f,e,i,r,s)))return g.add(t)})){p=!1;break}}else if(!(f===h||a(f,h,i,r,s))){p=!1;break}}return s['delete'](e),p}},function(e,t,a){'use strict';var n=a(133),o=a(20),i=a(19),r=a(48),s=a(23);class l extends n.a{static get className(){return'engine.model.delta.WeakInsertDelta'}}t.a=l,Object(o.b)('weakInsert',function(e,t){const a=new l;this.addDelta(a),t=Object(s.c)(t);for(const a of t)a.setAttributesTo(this.document.selection.getAttributes());const n=new r.a(e,t,this.document.version);return a.addOperation(n),this.document.applyOperation(n),this}),i.a.register(l)},function(e,t,a){'use strict';function n(e,t){for(const a of t)for(const t of a.operations)t.baseVersion=++e;return t}function o(e){return e.reduce((e,t)=>e+t.operations.length,0)}function i(e,t){const a=e[e.length-1];let n=a.operations.length+a.baseVersion;const o=new g.a;for(let a=0;a<t;a++)o.addOperation(new A.a(n++));e.push(o)}function r(e,t,a){c(e,t,a),s(e,t,a),d(t,a),l(t,a)}function s(e,t,a){const n=a.originalDelta.get(t);if(a.document.history.isUndoingDelta(n)){const t=a.document.history.getUndoneDelta(n),o=a.wasAffected.get(e),i=o.get(t);i!==void 0&&(a.insertBefore=i)}}function l(e,t){const a=t.originalDelta.get(e),n=t.document.history;t.forceNotSticky=n.isUndoneDelta(a)||n.isUndoingDelta(a)}function d(e,t){const a=t.document.history,n=t.originalDelta.get(e);t.forceWeakRemove=a.isUndoneDelta(n)}function c(e,t,a){a.wasAffected.get(e)||a.wasAffected.set(e,new Map);const n=a.originalDelta.get(t);let o=!!a.wasAffected.get(e).get(n);for(const n of e.operations){for(const e of t.operations)if(n instanceof C.a&&e instanceof C.a&&m(n,e)){o=!0;break}if(o)break}a.wasAffected.get(e).set(n,o)}function m(e,t){const a=e.targetPosition,n=t.sourcePosition,o=Object(E.a)(n.getParentPath(),a.getParentPath());return!(a.root!=n.root)&&'same'==o&&n.offset<a.offset}function u(e,t,a){delete a.insertBefore,delete a.forceNotSticky,delete a.forceWeakRemove;const n=a.wasAffected.get(e);a.wasAffected.delete(e);for(const o of t)a.wasAffected.set(o,new Map(n))}function p(e,t){let a=[],n=null,o;switch(e){case f.a:case h.a:for(const e of t)n=e instanceof A.a?new g.a:e instanceof T.a?new h.a:new f.a,n.addOperation(e),a.push(n);return a;case _.a:case k.a:return n=new e,n.addOperation(t[0]),n.addOperation(t[1]),a=p(f.a,t.slice(2)),[n].concat(a);case b.a:case y.a:return a=p(f.a,t.slice(0,-2)),n=new e,n.addOperation(t[t.length-2]),n.addOperation(t[t.length-1]),a.concat(n);case w.a:return n=t[0]instanceof A.a?new g.a:new w.a,n.addOperation(t[0]),[n];case v.a:for(o=0;o<t.length&&!!(t[o]instanceof A.a);o++);o==t.length?n=new g.a:(n=new v.a,0!=o&&t.unshift(t.splice(o,1)[0]));for(const e of t)n.addOperation(e);return[n];default:n=new e;for(const e of t)n.addOperation(e);return[n];}}var g=a(24),f=a(100),h=a(99),b=a(101),_=a(102),k=a(104),y=a(103),w=a(134),v=a(129),x=a(370),A=a(72),C=a(29),T=a(41),P=a(371),E=a(55);const S=new Map,O={transform(e,t,a){const o=O.getTransformationCase(e,t)||O.defaultTransform,i=o(e,t,Object.assign({},a)),r=P.a.last(t.operations).baseVersion;return n(r,i)},defaultTransform(e,t,a){const n=[];let o=t.operations,r=[];for(const i of e.operations){const e=[i];for(const t of o)for(let n=0;n<e.length;n++){const o=e[n],i=Object(x.a)(o,t,a);Array.prototype.splice.apply(e,[n,1].concat(i)),n+=i.length-1;const s=Object.assign({},a);s.isStrong=!a.isStrong,s.insertBefore=a.insertBefore===void 0?void 0:!a.insertBefore;const l=Object(x.a)(t,o,s);Array.prototype.push.apply(r,l)}o=r,r=[];for(const t of e)n.push(t)}return p(e.constructor,n)},addTransformationCase(e,t,a){let n=S.get(e);n||(n=new Map,S.set(e,n)),n.set(t,a)},getTransformationCase(e,t){let a=S.get(e.constructor);if(!a||!a.get(t.constructor)){const n=S.keys();for(const o of n)if(e instanceof o&&S.get(o).get(t.constructor)){a=S.get(o);break}}return a?a.get(t.constructor):void 0},transformDeltaSets(e,t,a=null){const n=Array.from(e),s=Array.from(t),d=null!==a,c={isStrong:!0};if(d){c.wasAffected=new Map,c.originalDelta=new Map,c.document=a,c.undoMode=!0;for(const e of s)c.originalDelta.set(e,e)}for(let o=0;o<n.length;o++){const e=[n[o]];for(let t=0;t<s.length;t++){const a=[s[t]];for(let t=0;t<e.length;t++)for(let n=0;n<a.length;n++){d&&r(e[t],a[n],c);const o=O.transform(e[t],a[n],{insertBefore:c.insertBefore,forceNotSticky:c.forceNotSticky,isStrong:c.isStrong,forceWeakRemove:c.forceWeakRemove,undoMode:c.undoMode}),i=O.transform(a[n],e[t],{insertBefore:!c.insertBefore,forceNotSticky:c.forceNotSticky,isStrong:!c.isStrong,forceWeakRemove:c.forceWeakRemove,undoMode:c.undoMode});if(d){u(e[t],o,c);const r=c.originalDelta.get(a[n]);for(const e of i)c.originalDelta.set(e,r)}e.splice(t,1,...o),t+=o.length-1,a.splice(n,1,...i),n+=i.length-1}s.splice(t,1,...a),t+=a.length-1}n.splice(o,1,...e),o+=e.length-1}const l=o(n)-o(e),m=o(s)-o(t);return m<l?i(s,l-m):l<m&&i(n,m-l),{deltasA:n,deltasB:s}}};t.a=O},function(e,t,a){'use strict';var n=a(42),i=a(79),r=a(13),s=Math.ceil;t.a=function(e,t,a){t=(a?Object(i.a)(e,t,a):void 0===t)?1:o(Object(r.a)(t),0);var l=e?e.length:0;if(!l||1>t)return[];for(var d=0,c=0,m=Array(s(l/t));d<l;)m[c++]=Object(n.a)(e,d,d+=t);return m}},function(e,t){'use strict';t.a=function(e){for(var t=-1,a=e?e.length:0,n=0,o=[];++t<a;){var i=e[t];i&&(o[n++]=i)}return o}},function(e,t,a){'use strict';var n=a(89),o=a(25),i=a(170),r=a(15);t.a=function(){for(var e=arguments.length,t=Array(e?e-1:0),a=arguments[0],s=e;s--;)t[s-1]=arguments[s];return e?Object(n.a)(Object(r.a)(a)?Object(i.a)(a):[a],Object(o.a)(t,1)):[]}},function(e,t,a){'use strict';var n=a(73),o=a(25),i=a(14),r=a(9),s=Object(r.a)(function(e,t){return Object(i.a)(e)?Object(n.a)(e,Object(o.a)(t,1,i.a,!0)):[]});t.a=s},function(e,t){'use strict';t.a=function(e,t,a){for(var n=e.length,o=t+(a?0:-1);a?o--:++o<n;){var i=e[o];if(i!==i)return o}return-1}},function(e,t,a){'use strict';var n=a(73),o=a(25),i=a(10),r=a(14),s=a(18),l=a(9),d=Object(l.a)(function(e,t){var a=Object(s.a)(t);return Object(r.a)(a)&&(a=void 0),Object(r.a)(e)?Object(n.a)(e,Object(o.a)(t,1,r.a,!0),Object(i.a)(a)):[]});t.a=d},function(e,t,a){'use strict';var n=a(17);t.a=function(e){return e===e&&!Object(n.a)(e)}},function(e,t){'use strict';t.a=function(e,t){return function(a){return null!=a&&a[e]===t&&(t!==void 0||e in Object(a))}}},function(e,t,a){'use strict';var n=a(140);t.a=function(e,t,a){var o=null==e?void 0:Object(n.a)(e,t);return o===void 0?a:o}},function(e,t){'use strict';t.a=function(e){return e}},function(e,t,a){'use strict';var n=a(73),o=a(25),i=a(14),r=a(18),s=a(9),l=Object(s.a)(function(e,t){var a=Object(r.a)(t);return Object(i.a)(a)&&(a=void 0),Object(i.a)(e)?Object(n.a)(e,Object(o.a)(t,1,i.a,!0),void 0,a):[]});t.a=l},function(e,t,a){'use strict';var n=a(10),o=a(106);t.a=function(e,t){return e&&e.length?Object(o.a)(e,Object(n.a)(t,3),!0,!0):[]}},function(e,t,a){'use strict';var n=a(10),o=a(106);t.a=function(e,t){return e&&e.length?Object(o.a)(e,Object(n.a)(t,3),!0):[]}},function(e,t,a){'use strict';var n=a(390),o=a(79);t.a=function(e,t,a,i){var r=e?e.length:0;return r?(a&&'number'!=typeof a&&Object(o.a)(e,t,a)&&(a=0,i=r),Object(n.a)(e,t,a,i)):[]}},function(e,t,a){'use strict';var n=a(198),o=a(10);t.a=function(e,t){return e&&e.length?Object(n.a)(e,Object(o.a)(t,3)):-1}},function(e,t){'use strict';t.a=function(e,t,a){for(var n=e.length,o=a?n:-1;a?o--:++o<n;)if(t(e[o],o,e))return o;return-1}},function(e,t,a){'use strict';var n=a(198),o=a(10);t.a=function(e,t){return e&&e.length?Object(n.a)(e,Object(o.a)(t,3),!0):-1}},function(e,t,a){'use strict';var n=a(143);a.d(t,'a',function(){return n.a})},function(e,t,a){'use strict';var n=a(25);t.a=function(e){var t=e?e.length:0;return t?Object(n.a)(e,1):[]}},function(e,t,a){'use strict';var n=a(25);t.a=function(e){var t=e?e.length:0;return t?Object(n.a)(e,1/0):[]}},function(e,t,a){'use strict';var n=a(25),o=a(13);t.a=function(e,t){var a=e?e.length:0;return a?(t=void 0===t?1:Object(o.a)(t),Object(n.a)(e,t)):[]}},function(e,t){'use strict';t.a=function(e){for(var t=-1,a=e?e.length:0,n={};++t<a;){var o=e[t];n[o[0]]=o[1]}return n}},function(e,t,a){'use strict';var n=a(136),i=a(13);t.a=function(e,t,a){var r=e?e.length:0;return r?(a=Object(i.a)(a),0>a&&(a=o(r+a,0)),Object(n.a)(e,t,a)):-1}},function(e,t,a){'use strict';var n=a(142);t.a=function(e){return Object(n.a)(e,1)}},function(e,t,a){'use strict';var n=a(30),o=a(144),i=a(145),r=a(9),s=Object(r.a)(function(e){var t=Object(n.a)(e,i.a);return t.length&&t[0]===e[0]?Object(o.a)(t):[]});t.a=s},function(e,t,a){'use strict';var n=a(30),o=a(144),i=a(10),r=a(145),s=a(18),l=a(9),d=Object(l.a)(function(e){var t=Object(s.a)(e),a=Object(n.a)(e,r.a);return t===Object(s.a)(a)?t=void 0:a.pop(),a.length&&a[0]===e[0]?Object(o.a)(a,Object(i.a)(t)):[]});t.a=d},function(e,t,a){'use strict';var n=a(30),o=a(144),i=a(145),r=a(18),s=a(9),l=Object(s.a)(function(e){var t=Object(r.a)(e),a=Object(n.a)(e,i.a);return t===Object(r.a)(a)?t=void 0:a.pop(),a.length&&a[0]===e[0]?Object(o.a)(a,void 0,t):[]});t.a=l},function(e,t){'use strict';var a=Array.prototype,n=a.join;t.a=function(e,t){return e?n.call(e,t):''}},function(e,t,a){'use strict';var i=a(187),r=a(13);t.a=function(e,t,a){var s=e?e.length:0;if(!s)return-1;var l=s;if(void 0!==a&&(l=Object(r.a)(a),l=(0>l?o(s+l,0):n(l,s-1))+1),t!==t)return Object(i.a)(e,l,!0);for(;l--;)if(e[l]===t)return l;return-1}},function(e,t,a){'use strict';var o=a(393),i=a(13);t.a=function(e,t){return e&&e.length?Object(o.a)(e,Object(i.a)(t)):void 0}},function(e,t,a){'use strict';var n=a(146),o=a(9),i=Object(o.a)(n.a);t.a=i},function(e,t,a){'use strict';var n=a(10),o=a(147);t.a=function(e,t,a){return e&&e.length&&t&&t.length?Object(o.a)(e,t,Object(n.a)(a)):e}},function(e,t,a){'use strict';var n=a(147);t.a=function(e,t,a){return e&&e.length&&t&&t.length?Object(n.a)(e,t,void 0,a):e}},function(e,t,a){'use strict';var n=a(30),o=a(395),i=a(25),r=a(217),s=a(397),l=a(37),d=a(9),c=Object(d.a)(function(e,t){t=Object(i.a)(t,1);var a=e?e.length:0,d=Object(o.a)(e,t);return Object(r.a)(e,Object(n.a)(t,function(e){return Object(l.a)(e,a)?+e:e}).sort(s.a)),d});t.a=c},function(e,t,a){'use strict';var n=a(105),o=a(37),i=a(57),r=a(18),s=a(396),l=a(58),d=Array.prototype,c=d.splice;t.a=function(e,t){for(var a=e?t.length:0,d=a-1;a--;){var m=t[a];if(a==d||m!==u){var u=m;if(Object(o.a)(m))c.call(e,m,1);else if(!Object(i.a)(m,e)){var p=Object(n.a)(m),g=Object(s.a)(e,p);null!=g&&delete g[Object(l.a)(Object(r.a)(p))]}else delete e[Object(l.a)(m)]}}return e}},function(e,t,a){'use strict';var n=a(10),o=a(217);t.a=function(e,t){var a=[];if(!(e&&e.length))return a;var i=-1,r=[],s=e.length;for(t=Object(n.a)(t,3);++i<s;){var l=e[i];t(l,i,e)&&(a.push(l),r.push(i))}return Object(o.a)(e,r),a}},function(e,t){'use strict';var a=Array.prototype,n=a.reverse;t.a=function(e){return e?n.call(e):e}},function(e,t,a){'use strict';var n=a(42),o=a(79),i=a(13);t.a=function(e,t,a){var r=e?e.length:0;return r?(a&&'number'!=typeof a&&Object(o.a)(e,t,a)?(t=0,a=r):(t=null==t?0:Object(i.a)(t),a=void 0===a?r:Object(i.a)(a)),Object(n.a)(e,t,a)):[]}},function(e,t,a){'use strict';var n=a(107);t.a=function(e,t){return Object(n.a)(e,t)}},function(e,t,a){'use strict';var n=a(10),o=a(148);t.a=function(e,t,a){return Object(o.a)(e,t,Object(n.a)(a))}},function(e,t,a){'use strict';var n=a(107),o=a(53);t.a=function(e,t){var a=e?e.length:0;if(a){var i=Object(n.a)(e,t);if(i<a&&Object(o.a)(e[i],t))return i}return-1}},function(e,t,a){'use strict';var n=a(107);t.a=function(e,t){return Object(n.a)(e,t,!0)}},function(e,t,a){'use strict';var n=a(10),o=a(148);t.a=function(e,t,a){return Object(o.a)(e,t,Object(n.a)(a),!0)}},function(e,t,a){'use strict';var n=a(107),o=a(53);t.a=function(e,t){var a=e?e.length:0;if(a){var i=Object(n.a)(e,t,!0)-1;if(Object(o.a)(e[i],t))return i}return-1}},function(e,t,a){'use strict';var n=a(228);t.a=function(e){return e&&e.length?Object(n.a)(e):[]}},function(e,t,a){'use strict';var n=a(53);t.a=function(e,t){for(var a=-1,o=e.length,i=0,r=[];++a<o;){var s=e[a],l=t?t(s):s;if(!a||!Object(n.a)(l,d)){var d=l;r[i++]=0===s?0:s}}return r}},function(e,t,a){'use strict';var n=a(10),o=a(228);t.a=function(e,t){return e&&e.length?Object(o.a)(e,Object(n.a)(t)):[]}},function(e,t,a){'use strict';var n=a(141);t.a=function(e){return Object(n.a)(e,1)}},function(e,t,a){'use strict';var o=a(42),i=a(13);t.a=function(e,t,a){return e&&e.length?(t=a||void 0===t?1:Object(i.a)(t),Object(o.a)(e,0,0>t?0:t)):[]}},function(e,t,a){'use strict';var o=a(42),i=a(13);t.a=function(e,t,a){var n=e?e.length:0;return n?(t=a||void 0===t?1:Object(i.a)(t),t=n-t,Object(o.a)(e,0>t?0:t,n)):[]}},function(e,t,a){'use strict';var n=a(10),o=a(106);t.a=function(e,t){return e&&e.length?Object(o.a)(e,Object(n.a)(t,3),!1,!0):[]}},function(e,t,a){'use strict';var n=a(10),o=a(106);t.a=function(e,t){return e&&e.length?Object(o.a)(e,Object(n.a)(t,3)):[]}},function(e,t,a){'use strict';var n=a(25),o=a(49),i=a(14),r=a(9),s=Object(r.a)(function(e){return Object(o.a)(Object(n.a)(e,1,i.a,!0))});t.a=s},function(e,t,a){'use strict';var n=a(25),o=a(10),i=a(49),r=a(14),s=a(18),l=a(9),d=Object(l.a)(function(e){var t=Object(s.a)(e);return Object(r.a)(t)&&(t=void 0),Object(i.a)(Object(n.a)(e,1,r.a,!0),Object(o.a)(t))});t.a=d},function(e,t,a){'use strict';var n=a(25),o=a(49),i=a(14),r=a(18),s=a(9),l=Object(s.a)(function(e){var t=Object(r.a)(e);return Object(i.a)(t)&&(t=void 0),Object(o.a)(Object(n.a)(e,1,i.a,!0),void 0,t)});t.a=l},function(e,t,a){'use strict';var n=a(49);t.a=function(e){return e&&e.length?Object(n.a)(e):[]}},function(e,t,a){'use strict';var n=a(10),o=a(49);t.a=function(e,t){return e&&e.length?Object(o.a)(e,Object(n.a)(t)):[]}},function(e,t,a){'use strict';var n=a(49);t.a=function(e,t){return e&&e.length?Object(n.a)(e,void 0,t):[]}},function(e,t,a){'use strict';var n=a(73),o=a(14),i=a(9),r=Object(i.a)(function(e,t){return Object(o.a)(e)?Object(n.a)(e,t):[]});t.a=r},function(e,t,a){'use strict';var n=a(109),o=a(150),i=a(14),r=a(9),s=Object(r.a)(function(e){return Object(o.a)(Object(n.a)(e,i.a))});t.a=s},function(e,t,a){'use strict';var n=a(109),o=a(10),i=a(150),r=a(14),s=a(18),l=a(9),d=Object(l.a)(function(e){var t=Object(s.a)(e);return Object(r.a)(t)&&(t=void 0),Object(i.a)(Object(n.a)(e,r.a),Object(o.a)(t))});t.a=d},function(e,t,a){'use strict';var n=a(109),o=a(150),i=a(14),r=a(18),s=a(9),l=Object(s.a)(function(e){var t=Object(r.a)(e);return Object(i.a)(t)&&(t=void 0),Object(o.a)(Object(n.a)(e,i.a),void 0,t)});t.a=l},function(e,t,a){'use strict';var n=a(9),o=a(108),i=Object(n.a)(o.a);t.a=i},function(e,t,a){'use strict';var n=a(64),o=a(247);t.a=function(e,t){return Object(o.a)(e||[],t||[],n.a)}},function(e,t){'use strict';t.a=function(e,t,a){for(var n=-1,o=e.length,i=t.length,r={};++n<o;){var s=n<i?t[n]:void 0;a(r,e[n],s)}return r}},function(e,t,a){'use strict';var n=a(400),o=a(247);t.a=function(e,t){return Object(o.a)(e||[],t||[],n.a)}},function(e,t,a){'use strict';var n=a(9),o=a(149),i=Object(n.a)(function(e){var t=e.length,a=1<t?e[t-1]:void 0;return a='function'==typeof a?(e.pop(),a):void 0,Object(o.a)(e,a)});t.a=i},function(e,t,a){'use strict';function n(e){return e instanceof d.a||e instanceof l.a?e.getAttributes():null}function o(e,t,a){if(!t||'transparent'==t.type)return;const n=e.range&&e.range.start.parent;!n||n.isEmpty||a.enqueueChanges(()=>{const e=Array.from(n.getAttributeKeys()).filter((e)=>e.startsWith(g));for(const a of e)t.removeAttribute(n,a)})}var i=a(1),r=a(3),s=a(151),l=a(26),d=a(67),c=a(121),m=a(0),u=a(16),p=a(59);const g='selection:',f=new Set(['addAttribute','removeAttribute','changeAttribute','addRootAttribute','removeRootAttribute','changeRootAttribute']);class h extends p.a{constructor(e){super(),this._document=e,this._attributePriority=new Map,this.listenTo(this._document,'change',(e,t,a,n)=>{f.has(t)&&this._updateAttributes(!1),o(a,n,this._document)})}get isCollapsed(){const e=this._ranges.length;return 0===e?this._document._getDefaultRange().isCollapsed:super.isCollapsed}get anchor(){return super.anchor||this._document._getDefaultRange().start}get focus(){return super.focus||this._document._getDefaultRange().end}get rangeCount(){return this._ranges.length?this._ranges.length:1}get hasOwnRange(){return 0<this._ranges.length}destroy(){for(let e=0;e<this._ranges.length;e++)this._ranges[e].detach();this.stopListening()}*getRanges(){this._ranges.length?yield*super.getRanges():yield this._document._getDefaultRange()}getFirstRange(){return super.getFirstRange()||this._document._getDefaultRange()}getLastRange(){return super.getLastRange()||this._document._getDefaultRange()}addRange(e,t=!1){super.addRange(e,t),this.refreshAttributes()}removeAllRanges(){super.removeAllRanges(),this.refreshAttributes()}setRanges(e,t=!1){super.setRanges(e,t),this.refreshAttributes()}setAttribute(e,t){if(this.isCollapsed&&this.anchor.parent.isEmpty&&this._storeAttribute(e,t),this._setAttribute(e,t)){this.fire('change:attribute',{attributeKeys:[e],directChange:!0})}}removeAttribute(e){if(this.isCollapsed&&this.anchor.parent.isEmpty&&this._removeStoredAttribute(e),this._removeAttribute(e)){this.fire('change:attribute',{attributeKeys:[e],directChange:!0})}}setAttributesTo(e){e=Object(c.a)(e),this.isCollapsed&&this.anchor.parent.isEmpty&&this._setStoredAttributesTo(e);const t=this._setAttributesTo(e);if(0<t.size){const e=Array.from(t);this.fire('change:attribute',{attributeKeys:e,directChange:!0})}}clearAttributes(){this.setAttributesTo([])}refreshAttributes(){this._updateAttributes(!0)}static createFromSelection(){throw new m.b('documentselection-cannot-create: Cannot create a new DocumentSelection instance.')}_popRange(){this._ranges.pop().detach()}_pushRange(e){const t=this._prepareRange(e);t&&this._ranges.push(t)}_prepareRange(e){if(!(e instanceof r.a))throw new m.b('model-selection-added-not-range: Trying to add an object that is not an instance of Range.');if(e.root==this._document.graveyard)return void u.a.warn('model-selection-range-in-graveyard: Trying to add a Range that is in the graveyard root. Range rejected.');this._checkRange(e);const t=s.a.createFromRange(e);return this.listenTo(t,'change:range',(e,a,n)=>{t.root==this._document.graveyard&&this._fixGraveyardSelection(t,n.sourcePosition),this.fire('change:range',{directChange:!1})}),t}_updateAttributes(e){const t=Object(c.a)(this._getSurroundingAttributes()),a=Object(c.a)(this.getAttributes());if(e)this._attributePriority=new Map,this._attrs=new Map;else for(const[e,t]of this._attributePriority)'low'==t&&(this._attrs.delete(e),this._attributePriority.delete(e));this._setAttributesTo(t,!1);const n=[];for(const[t,o]of this.getAttributes())a.has(t)&&a.get(t)===o||n.push(t);for(const[t]of a)this.hasAttribute(t)||n.push(t);0<n.length&&this.fire('change:attribute',{attributeKeys:n,directChange:!1})}static _getStoreAttributeKey(e){return g+e}static _isStoreAttributeKey(e){return e.startsWith(g)}_setAttribute(e,t,a=!0){const n=a?'normal':'low';if('low'==n&&'normal'==this._attributePriority.get(e))return!1;const o=super.getAttribute(e);return o!==t&&(this._attrs.set(e,t),this._attributePriority.set(e,n),!0)}_removeAttribute(e,t=!0){const a=t?'normal':'low';return'low'==a&&'normal'==this._attributePriority.get(e)?!1:!!super.hasAttribute(e)&&(this._attrs.delete(e),this._attributePriority.set(e,a),!0)}_setAttributesTo(e,t=!0){const a=new Set;for(const[n,o]of this.getAttributes())e.get(n)!==o&&this._removeAttribute(n,t)&&a.add(n);for(const[n,o]of e){const e=this._setAttribute(n,o,t);e&&a.add(n)}return a}*_getStoredAttributes(){const e=this.getFirstPosition().parent;if(this.isCollapsed&&e.isEmpty)for(const t of e.getAttributeKeys())if(t.startsWith(g)){const a=t.substr(g.length);yield[a,e.getAttribute(t)]}}_removeStoredAttribute(e){const t=h._getStoreAttributeKey(e);this._document.batch().removeAttribute(this.anchor.parent,t)}_storeAttribute(e,t){const a=h._getStoreAttributeKey(e);this._document.batch().setAttribute(this.anchor.parent,a,t)}_setStoredAttributesTo(e){const t=this.anchor.parent,a=this._document.batch();for(const[n]of this._getStoredAttributes()){const e=h._getStoreAttributeKey(n);a.removeAttribute(t,e)}for(const[n,o]of e){const e=h._getStoreAttributeKey(n);a.setAttribute(t,e,o)}}_getSurroundingAttributes(){const e=this.getFirstPosition(),t=this._document.schema;let a=null;if(!this.isCollapsed){const e=this.getFirstRange();for(const n of e){if(n.item.is('element')&&t.objects.has(n.item.name))break;'text'==n.type&&null==a&&(a=n.item.getAttributes())}}else{const t=e.textNode?e.textNode:e.nodeBefore,o=e.textNode?e.textNode:e.nodeAfter;if(a=n(t),a||(a=n(o)),!a)for(let e=t;e&&!a;)e=e.previousSibling,a=n(e);if(!a)for(let e=o;e&&!a;)e=e.nextSibling,a=n(e);a||(a=this._getStoredAttributes())}return a}_fixGraveyardSelection(e,t){const a=i.a.createFromPosition(t),n=this._document.getNearestSelectionRange(a),o=this._ranges.indexOf(e);if(this._ranges.splice(o,1),e.detach(),n){const e=this._prepareRange(n);this._ranges.splice(o,0,e)}this.fire('change:range',{directChange:!1})}}t.a=h},function(e,t){'use strict';t.a=function(e,t,a){function i(n){const i=(m[n-1]===void 0?-1:m[n-1])+1,u=m[n+1]===void 0?-1:m[n+1],p=i>u?-1:1;c[n+p]&&(c[n]=c[n+p].slice(0)),c[n]||(c[n]=[]),c[n].push(i>u?r:s);let g=o(i,u),f=g-n;for(;f<l&&g<d&&a(e[f],t[g]);)f++,g++,c[n].push('equal');return g}a=a||function(e,t){return e===t};let r,s;if(t.length<e.length){const a=e;e=t,t=a,r='delete',s='insert'}else r='insert',s='delete';const l=e.length,d=t.length,n=d-l,c={},m={};let u=0,g;do{for(g=-u;g<n;g++)m[g]=i(g);for(g=n+u;g>n;g--)m[g]=i(g);m[n]=i(n),u++}while(m[n]!==d);return c[n].slice(1)}},function(e,t){'use strict';t.a=function(e){const t=[];for(;e&&e.nodeType!=Node.DOCUMENT_NODE;)t.unshift(e),e=e.parentNode;return t}},function(e,t,a){'use strict';var n=a(91);const o=Symbol('rootName');class i extends n.a{constructor(e){super(e),this.rootName='main'}is(e,t=null){return t?'rootElement'==e&&t==this.name||super.is(e,t):'rootElement'==e||super.is(e)}get rootName(){return this.getCustomProperty(o)}set rootName(e){this.setCustomProperty(o,e)}}t.a=i},function(e,t,a){'use strict';var n=a(61),o=a(111),i=a(74),r=a(416);class s extends n.a{constructor(e){super(e),this._config={childList:!0,characterData:!0,characterDataOldValue:!0,subtree:!0},this.domConverter=e.domConverter,this.renderer=e.renderer,this._domElements=[],this._mutationObserver=new window.MutationObserver(this._onMutations.bind(this))}flush(){this._onMutations(this._mutationObserver.takeRecords())}observe(e){this._domElements.push(e),this.isEnabled&&this._mutationObserver.observe(e,this._config)}enable(){super.enable();for(const e of this._domElements)this._mutationObserver.observe(e,this._config)}disable(){super.disable(),this._mutationObserver.disconnect()}destroy(){super.destroy(),this._mutationObserver.disconnect()}_onMutations(e){function t(e,t){if(!Array.isArray(e))return e===t||e.is('text')&&t.is('text')&&e.data===t.data}if(0===e.length)return;const a=this.domConverter,n=new Map,s=new Set;for(const t of e)if('childList'===t.type){const e=a.mapDomToView(t.target);if(e&&e.is('uiElement'))continue;e&&!this._isBogusBrMutation(t)&&s.add(e)}for(const t of e){const e=a.mapDomToView(t.target);if(!(e&&e.is('uiElement'))&&'characterData'===t.type){const e=a.findCorrespondingViewText(t.target);e&&!s.has(e.parent)?n.set(e,{type:'text',oldText:e.data,newText:Object(i.e)(t.target),node:e}):!e&&Object(i.i)(t.target)&&s.add(a.mapDomToView(t.target.parentNode))}}const l=[];for(const t of n.values())this.renderer.markToSync('text',t.node),l.push(t);for(const n of s){const e=a.mapViewToDom(n),o=Array.from(n.getChildren()),i=Array.from(a.domChildrenToView(e));Object(r.a)(o,i,t)||(this.renderer.markToSync('children',n),l.push({type:'children',oldChildren:o,newChildren:i,node:n}))}const d=e[0].target.ownerDocument.getSelection();let c=null;if(d&&d.anchorNode){const e=a.domPositionToView(d.anchorNode,d.anchorOffset),t=a.domPositionToView(d.focusNode,d.focusOffset);e&&t&&(c=new o.a,c.setCollapsedAt(e),c.moveFocusTo(t))}this.document.fire('mutations',l,c),this.document.render()}_isBogusBrMutation(e){let t=null;return null===e.nextSibling&&0===e.removedNodes.length&&1==e.addedNodes.length&&(t=this.domConverter.domToView(e.addedNodes[0],{withChildren:!1})),t&&t.is('element','br')}}t.a=s},function(e,t,a){'use strict';var i=a(17),r=a(418),s=a(159);t.a=function(e,t,a){function l(t){var a=y,n=w;return y=w=void 0,h=t,x=e.apply(n,a),x}function d(e){return h=e,A=setTimeout(u,t),b?l(e):x}function c(e){var a=e-f,o=e-h,i=t-a;return _?n(i,v-o):i}function m(e){var a=e-f,n=e-h;return!f||a>=t||0>a||_&&n>=v}function u(){var e=Object(r.a)();return m(e)?p(e):void(A=setTimeout(u,c(e)))}function p(e){return(clearTimeout(A),A=void 0,k&&y)?l(e):(y=w=void 0,x)}function g(){var e=Object(r.a)(),a=m(e);if(y=arguments,w=this,f=e,a){if(void 0===A)return d(f);if(_)return clearTimeout(A),A=setTimeout(u,t),l(f)}return void 0===A&&(A=setTimeout(u,t)),x}var f=0,h=0,b=!1,_=!1,k=!0,y,w,v,x,A;if('function'!=typeof e)throw new TypeError('Expected a function');return t=Object(s.a)(t)||0,Object(i.a)(a)&&(b=!!a.leading,_='maxWait'in a,v=_?o(Object(s.a)(a.maxWait)||0,t):v,k='trailing'in a?!!a.trailing:k),g.cancel=function(){void 0!==A&&clearTimeout(A),f=h=0,y=w=A=void 0},g.flush=function(){return void 0===A?x:p(Object(r.a)())},g}},function(e,t,a){'use strict';function i(e,t){for(const a of g)e[a]=t[a]}function r(e){return!!Object(d.a)(e)&&e===e.ownerDocument.body}var s=a(155),l=a(423),d=a(257),c=a(258),m=a(16);class u{constructor(e){const t=Object(s.a)(e);if(Object.defineProperty(this,'_source',{value:e._source||e,writable:!0,enumerable:!1}),Object(d.a)(e)||t){const a=t?e.startContainer:e;a.ownerDocument&&a.ownerDocument.body.contains(a)||m.a.warn('rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',{source:e}),t?i(this,u.getDomRangeRects(e)[0]):i(this,e.getBoundingClientRect())}else if(Object(l.a)(e)){const{innerWidth:t,innerHeight:a}=e;i(this,{top:0,right:t,bottom:a,left:0,width:t,height:a})}else i(this,e)}clone(){return new u(this)}moveTo(e,t){return this.top=t,this.right=e+this.width,this.bottom=t+this.height,this.left=e,this}moveBy(e,t){return this.top+=t,this.right+=e,this.left+=e,this.bottom+=t,this}getIntersection(e){const t={top:o(this.top,e.top),right:n(this.right,e.right),bottom:n(this.bottom,e.bottom),left:o(this.left,e.left)};return t.width=t.right-t.left,t.height=t.bottom-t.top,0>t.width||0>t.height?null:new u(t)}getIntersectionArea(e){const t=this.getIntersection(e);return t?t.getArea():0}getArea(){return this.width*this.height}getVisible(){const e=this._source;let t=this.clone();if(!r(e))for(let a=e.parentNode||e.commonAncestorContainer;a&&!r(a);){const e=new u(a),n=t.getIntersection(e);if(n)n.getArea()<t.getArea()&&(t=n);else return null;a=a.parentNode}return t}isEqual(e){for(const t of g)if(this[t]!==e[t])return!1;return!0}contains(e){const t=this.getIntersection(e);return!!(t&&t.isEqual(e))}excludeScrollbarsAndBorders(){const e=this._source;let t,a;if(Object(l.a)(e))t=e.innerWidth-e.document.documentElement.clientWidth,a=e.innerHeight-e.document.documentElement.clientHeight;else{const n=Object(c.a)(this._source);t=e.offsetWidth-e.clientWidth,a=e.offsetHeight-e.clientHeight,this.moveBy(n.left,n.top)}return this.width-=t,this.right-=t,this.height-=a,this.bottom-=a,this}static getDomRangeRects(e){const t=[],a=Array.from(e.getClientRects());if(a.length)for(const e of a)t.push(new u(e));else{const a=new u(e.startContainer.getBoundingClientRect());a.right=a.left,a.width=0,t.push(a)}return t}}t.a=u;const g=['top','right','bottom','left','width','height']},function(e,t,a){'use strict';var n=a(44),o=a(77);t.a=function(e){return!!e&&1===e.nodeType&&Object(n.a)(e)&&!Object(o.a)(e)}},function(e,t){'use strict';t.a=function(e){const t=e.ownerDocument.defaultView.getComputedStyle(e);return{top:parseInt(t.borderTopWidth,10),right:parseInt(t.borderRightWidth,10),bottom:parseInt(t.borderBottomWidth,10),left:parseInt(t.borderLeftWidth,10)}}},function(e,t,a){'use strict';function n(e,t,a,n,i){if(!e.isCollapsed)return;if(!n.consume(e,i))return;let l=t.getFirstPosition();o(l.parent)&&(l=l.getLastMatchingPosition((e)=>e.item.is('uiElement'))),l=s.a.wrapPosition(l,a),t.removeAllRanges(),t.addRange(new r.a(l,l))}function o(e){if(!e.is('element'))return!1;for(const t of e.getChildren())if(!t.is('uiElement'))return!1;return!0}t.d=function(){return(e,t,a,n)=>{const o=t.selection;if(!o.isCollapsed&&a.consume(o,'selection')){n.viewSelection.removeAllRanges();for(const e of o.getRanges()){const t=n.mapper.toViewRange(e);n.viewSelection.addRange(t,o.isBackward)}}}},t.c=function(){return(e,t,a,n)=>{const o=t.selection;if(o.isCollapsed&&a.consume(o,'selection')){const e=o.getFirstPosition(),t=n.mapper.toViewPosition(e),a=s.a.breakAttributes(t);n.viewSelection.removeAllRanges(),n.viewSelection.addRange(new r.a(a,a))}}},t.e=function(e){return(t,a,o,r)=>{const s=e instanceof i.a?e.clone(!0):e(a.value,a,a.selection,o,r);if(s){const e='selectionAttribute:'+a.key;n(a.selection,r.viewSelection,s,o,e)}}},t.f=function(e){return(t,a,o,i)=>{const r='function'==typeof e?e(a,o,i):e;if(r){r.id||(r.id=a.markerName);const e=Object(l.a)(r),t='selectionMarker:'+a.markerName;n(a.selection,i.viewSelection,e,o,t)}}},t.a=function(){return(e,t,a,n)=>{for(const o of n.viewSelection.getRanges())o.isCollapsed&&o.end.parent.document&&s.a.mergeAttributes(o.start);n.viewSelection.removeAllRanges()}},t.b=function(){return(e,t,a,n)=>n.viewSelection.setFake(!1)};var i=a(27),r=a(38),s=a(93),l=a(71)},function(e,t,a){'use strict';var n=a(427),o=a(153),i=a(74);t.a=class{constructor(){this._domParser=new DOMParser,this._domConverter=new o.a({blockFiller:i.d}),this._htmlWriter=new n.a}toData(e){const t=this._domConverter.viewToDom(e,document);return this._htmlWriter.getHtml(t)}toView(e){const t=this._toDom(e);return this._domConverter.domToView(t)}_toDom(e){const t=this._domParser.parseFromString(e,'text/html'),a=t.createDocumentFragment(),n=t.body.childNodes;for(;0<n.length;)a.appendChild(n[0]);return a}}},function(e,t){'use strict';t.a=function(e){return(t)=>t+e}},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(62),r=a(114),s=a(50),l=a(439),d=a(440),c=a(16);class m extends n.a{constructor(e){super(e),this.items=this.createCollection(),this.focusTracker=new i.a,this.keystrokes=new s.a,this._focusCycler=new r.a({focusables:this.items,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:['arrowleft','arrowup'],focusNext:['arrowright','arrowdown']}}),this.template=new o.a({tag:'div',attributes:{class:['ck-toolbar']},children:this.items,on:{mousedown:Object(d.a)(this)}}),this.items.on('add',(e,t)=>{this.focusTracker.add(t.element)}),this.items.on('remove',(e,t)=>{this.focusTracker.remove(t.element)})}init(){this.keystrokes.listenTo(this.element),super.init()}focus(){this._focusCycler.focusFirst()}fillFromConfig(e,t){e.map((e)=>{'|'==e?this.items.add(new l.a):t.has(e)?this.items.add(t.create(e)):c.a.warn('toolbarview-item-unavailable: The requested toolbar item is unavailable.',{name:e})})}}t.a=m},function(e,t,a){'use strict';var n=a(152);class o{constructor(e,t=20){this.document=e,this.size=0,this.limit=t,this.isLocked=!1,this._changeCallback=(e,t,a,n)=>{this._onBatch(n)},this._selectionChangeCallback=()=>{this._reset()},e.on('change',this._changeCallback),e.selection.on('change:range',this._selectionChangeCallback),e.selection.on('change:attribute',this._selectionChangeCallback)}get batch(){return this._batch||(this._batch=this.document.batch()),this._batch}input(e){this.size+=e,this.size>=this.limit&&this._reset(!0)}lock(){this.isLocked=!0}unlock(){this.isLocked=!1}destroy(){this.document.off('change',this._changeCallback),this.document.selection.off('change:range',this._selectionChangeCallback),this.document.selection.off('change:attribute',this._selectionChangeCallback)}_onBatch(e){'transparent'!=e.type&&e!==this._batch&&1>=Object(n.a)(e.getOperations())&&this._reset(!0)}_reset(e){(!this.isLocked||e)&&(this._batch=null,this.size=0)}}t.a=o},function(e,t,a){'use strict';function n(e,t){const n=o([e],t);n.sort((e,t)=>e.start.isBefore(t.start)?-1:1);for(let o=1;o<n.length;o++){const e=n[o-1],t=n[o];e.end.isTouching(t.start)&&(e.end=t.end,n.splice(o,1),o--)}return n}function o(e,t){for(const a of t)for(const t of a.operations)for(let a=0;a<e.length;a++){let n;switch(t.type){case'insert':n=e[a]._getTransformedByInsertion(t.position,t.nodes.maxOffset,!0);break;case'move':case'remove':case'reinsert':n=e[a]._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,!0);}n&&(e.splice(a,1,...n),a=a+n.length-1)}return e}var i=a(11);class r extends i.a{constructor(e){super(e),this._stack=[],this._createdBatches=new WeakSet,this.refresh()}refresh(){this.isEnabled=0<this._stack.length}addBatch(e){const t=this.editor.document.selection,a={ranges:t.hasOwnRange?Array.from(t.getRanges()):[],isBackward:t.isBackward};this._stack.push({batch:e,selection:a}),this.refresh()}clearStack(){this._stack=[],this.refresh()}_restoreSelection(e,t,a){const o=this.editor.document,i=[];for(const r of e){const e=n(r,a),t=e.find((e)=>e.start.root!=o.graveyard);t&&i.push(t)}i.length&&o.selection.setRanges(i,t)}_undo(e){const t=this.editor.document,a=t.batch();this._createdBatches.add(a);const n=e.deltas.slice();n.reverse();for(const o of n){const e=o.baseVersion+o.operations.length,n=Array.from(t.history.getDeltas(e)),i=t.transformDeltas([o.getReversed()],n,!0),r=i.deltasA;for(const e of r){e.baseVersion=t.version,a.addDelta(e);for(const a of e.operations)t.applyOperation(a);t.history.setDeltaAsUndone(o,e)}}return a}}t.a=r},function(e,t,a){'use strict';var n=a(11);class o extends n.a{constructor(e,t){super(e),this.attributeKey=t}refresh(){const e=this.editor.document;this.value=e.selection.hasAttribute(this.attributeKey),this.isEnabled=e.schema.checkAttributeInSelection(e.selection,this.attributeKey)}execute(e={}){const t=this.editor.document,a=t.selection,n=e.forceValue===void 0?!this.value:e.forceValue;t.enqueueChanges(()=>{if(a.isCollapsed)n?a.setAttribute(this.attributeKey,!0):a.removeAttribute(this.attributeKey);else{const o=t.schema.getValidRanges(a.getRanges(),this.attributeKey),i=e.batch||t.batch();for(const e of o)n?i.setAttribute(e,this.attributeKey,n):i.removeAttribute(e,this.attributeKey)}})}}t.a=o},function(e,t,a){'use strict';var n=a(2),o=a(267),i=a(494),r=a(498),s=a(36),l=a(508),d=a.n(l);class c extends n.a{static get requires(){return[o.a,i.a,r.a]}static get pluginName(){return'Image'}init(){const e=this.editor,t=e.plugins.get('ContextualToolbar');t&&this.listenTo(t,'show',(t)=>{Object(s.b)(e.editing.view.selection)&&t.stop()},{priority:'high'})}}t.a=c},function(e,t,a){'use strict';function n(){return new c.a('figure',{class:'image'},new m.a('img'))}var o=a(2),i=a(51),r=a(43),s=a(492),l=a(36),d=a(5),c=a(47),m=a(177);class u extends o.a{init(){const e=this.editor,a=e.document,o=a.schema,c=e.data,m=e.editing,u=e.t;o.registerItem('image'),o.requireAttributes('image',['src']),o.allow({name:'image',attributes:['alt','src','srcset'],inside:'$root'}),o.objects.add('image'),Object(i.a)().for(c.modelToView).fromElement('image').toElement(()=>n()),Object(i.a)().for(m.modelToView).fromElement('image').toElement(()=>Object(l.c)(n(),u('image widget'))),Object(s.b)([m.modelToView,c.modelToView],'src'),Object(s.b)([m.modelToView,c.modelToView],'alt'),Object(s.b)([m.modelToView,c.modelToView],'srcset',s.d),Object(r.a)().for(c.viewToModel).from({name:'img',attribute:{src:/./}}).toElement((e)=>new d.a('image',{src:e.getAttribute('src')})),c.viewToModel.on('element:img',s.a,{priority:'low'}),c.viewToModel.on('element',s.c,{priority:'low'}),Object(r.a)().for(c.viewToModel).from({name:'img',attribute:{alt:/./}}).consuming({attribute:['alt']}).toAttribute((e)=>({key:'alt',value:e.getAttribute('alt')})),Object(r.a)().for(c.viewToModel).from({name:'img',attribute:{srcset:/./}}).consuming({attribute:['srcset']}).toAttribute((e)=>{const t={data:e.getAttribute('srcset')};return e.hasAttribute('width')&&(t.width=e.getAttribute('width')),{key:'srcset',value:t}}),c.viewToModel.on('element:figure',Object(s.e)())}}t.a=u},function(e,t){'use strict';t.a=function({emitter:e,activator:t,callback:a,contextElements:n}){e.listenTo(document,'mousedown',(e,{target:o})=>{if(t()){for(const e of n)if(e.contains(o))return;a()}})}},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(52),r=a(502);class s extends n.a{constructor(e,t){super(e);const a=`ck-input-${Object(i.a)()}`;this.set('label'),this.set('value'),this.set('isReadOnly',!1),this.labelView=this._createLabelView(a),this.inputView=this._createInputView(t,a);const n=this.bindTemplate;this.template=new o.a({tag:'div',attributes:{class:[n.if('isReadOnly','ck-disabled')]},children:[this.labelView,this.inputView]})}_createLabelView(e){const t=new r.a(this.locale);return t.for=e,t.bind('text').to(this,'label'),t}_createInputView(e,t){const a=new e(this.locale);return a.id=t,a.bind('value').to(this),a.bind('isReadOnly').to(this),a}select(){this.inputView.select()}focus(){this.inputView.focus()}}t.a=s},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(e){super(e),this.set('value'),this.set('id'),this.set('placeholder'),this.set('isReadOnly',!1);const t=this.bindTemplate;this.template=new o.a({tag:'input',attributes:{type:'text',class:['ck-input','ck-input-text'],id:t.to('id'),placeholder:t.to('placeholder'),readonly:t.to('isReadOnly')}}),this.on('change:value',(e,t,a)=>{this.element.value=a||''})}select(){this.element.select()}focus(){this.element.focus()}}t.a=i},function(e,t){'use strict';t.a=function({view:e}){e.listenTo(e.element,'submit',(t,a)=>{a.preventDefault(),e.fire('submit')},{useCapture:!0})}},function(e,t,a){'use strict';function n(e){return Object(c.a)(e)?e:Object(d.a)(e)?e.commonAncestorContainer:'function'==typeof e?n(e()):null}function o(e,t){return e.top-t.height-f.arrowVerticalOffset}function i(e){return e.bottom+f.arrowVerticalOffset}var r=a(7),s=a(6),l=a(503),d=a(155),c=a(257),m=a(261),u=a(60);const p=Object(m.a)('px'),g=u.a.document.body;class f extends r.a{constructor(e){super(e);const t=this.bindTemplate;this.set('top',0),this.set('left',0),this.set('position','arrow_nw'),this.set('isVisible',!1),this.set('withArrow',!0),this.set('className'),this.content=this.createCollection(),this.template=new s.a({tag:'div',attributes:{class:['ck-balloon-panel',t.to('position',(e)=>`ck-balloon-panel_${e}`),t.if('isVisible','ck-balloon-panel_visible'),t.if('withArrow','ck-balloon-panel_with-arrow'),t.to('className')],style:{top:t.to('top',p),left:t.to('left',p)}},children:this.content})}show(){this.isVisible=!0}hide(){this.isVisible=!1}attachTo(e){this.show();const t=f.defaultPositions,a=Object.assign({},{element:this.element,positions:[t.southArrowNorthWest,t.southArrowNorthEast,t.northArrowSouthWest,t.northArrowSouthEast],limiter:g,fitInViewport:!0},e),{top:n,left:o,name:i}=Object(l.a)(a);Object.assign(this,{top:n,left:o,position:i})}pin(e){this.unpin(),this._pinWhenIsVisibleCallback=()=>{this.isVisible?this._startPinning(e):this._stopPinning()},this._startPinning(e),this.listenTo(this,'change:isVisible',this._pinWhenIsVisibleCallback)}unpin(){this._pinWhenIsVisibleCallback&&(this._stopPinning(),this.stopListening(this,'change:isVisible',this._pinWhenIsVisibleCallback),this._pinWhenIsVisibleCallback=null,this.hide())}_startPinning(e){this.attachTo(e);const t=n(e.target),a=e.limiter?n(e.limiter):g;this.listenTo(u.a.document,'scroll',(n,o)=>{const i=o.target,r=t&&i.contains(t),s=a&&i.contains(a);(r||s||!t||!a)&&this.attachTo(e)},{useCapture:!0}),this.listenTo(u.a.window,'resize',()=>{this.attachTo(e)})}_stopPinning(){this.stopListening(u.a.document,'scroll'),this.stopListening(u.a.window,'resize')}}t.a=f,f.arrowHorizontalOffset=30,f.arrowVerticalOffset=15,f.defaultPositions={northArrowSouth:(e,t)=>({top:o(e,t),left:e.left+e.width/2-t.width/2,name:'arrow_s'}),northArrowSouthEast:(e,t)=>({top:o(e,t),left:e.left+e.width/2-t.width+f.arrowHorizontalOffset,name:'arrow_se'}),northArrowSouthWest:(e,t)=>({top:o(e,t),left:e.left+e.width/2-f.arrowHorizontalOffset,name:'arrow_sw'}),northWestArrowSouth:(e,t)=>({top:o(e,t),left:e.left-t.width/2,name:'arrow_s'}),northWestArrowSouthWest:(e,t)=>({top:o(e,t),left:e.left-f.arrowHorizontalOffset,name:'arrow_sw'}),northWestArrowSouthEast:(e,t)=>({top:o(e,t),left:e.left-t.width+f.arrowHorizontalOffset,name:'arrow_se'}),northEastArrowSouth:(e,t)=>({top:o(e,t),left:e.right-t.width/2,name:'arrow_s'}),northEastArrowSouthEast:(e,t)=>({top:o(e,t),left:e.right-t.width+f.arrowHorizontalOffset,name:'arrow_se'}),northEastArrowSouthWest:(e,t)=>({top:o(e,t),left:e.right-f.arrowHorizontalOffset,name:'arrow_sw'}),southArrowNorth:(e,t)=>({top:i(e,t),left:e.left+e.width/2-t.width/2,name:'arrow_n'}),southArrowNorthEast:(e,t)=>({top:i(e,t),left:e.left+e.width/2-t.width+f.arrowHorizontalOffset,name:'arrow_ne'}),southArrowNorthWest:(e,t)=>({top:i(e,t),left:e.left+e.width/2-f.arrowHorizontalOffset,name:'arrow_nw'}),southWestArrowNorth:(e,t)=>({top:i(e,t),left:e.left-t.width/2,name:'arrow_n'}),southWestArrowNorthWest:(e,t)=>({top:i(e,t),left:e.left-f.arrowHorizontalOffset,name:'arrow_nw'}),southWestArrowNorthEast:(e,t)=>({top:i(e,t),left:e.left-t.width+f.arrowHorizontalOffset,name:'arrow_ne'}),southEastArrowNorth:(e,t)=>({top:i(e,t),left:e.right-t.width/2,name:'arrow_n'}),southEastArrowNorthEast:(e,t)=>({top:i(e,t),left:e.right-t.width+f.arrowHorizontalOffset,name:'arrow_ne'}),southEastArrowNorthWest:(e,t)=>({top:i(e,t),left:e.right-f.arrowHorizontalOffset,name:'arrow_nw'})}},function(e,t,a){'use strict';function n(e){const t=e.editing.view,a=o.a.defaultPositions;return{target:t.domConverter.viewToDom(t.selection.getSelectedElement()),positions:[a.northArrowSouth,a.southArrowNorth]}}t.b=function(e){const t=e.plugins.get('ContextualBalloon');if(Object(i.b)(e.editing.view.selection)){const a=n(e);t.updatePosition(a)}},t.a=n;var o=a(272),i=a(36)},function(e,t,a){'use strict';var n=a(2),o=a(510),i=a(515);class r extends n.a{static get pluginName(){return'ImageUpload'}static get requires(){return[o.a,i.a]}}t.a=r},function(e,t,a){'use strict';var n=a(2),i=a(76),r=a(511),s=a(512),l=a(59),d=a(276);class c extends n.a{static get requires(){return[i.a,s.a]}init(){const e=this.editor,t=e.document,a=t.schema,n=e.plugins.get(i.a);a.allow({name:'image',attributes:['uploadId'],inside:'$root'}),a.allow({name:'image',attributes:['uploadStatus'],inside:'$root'}),a.requireAttributes('image',['uploadId']),e.commands.add('imageUpload',new r.a(e)),e.editing.view.on('clipboardInput',(a,n)=>{let o=new l.a(n.targetRanges.map((t)=>e.editing.mapper.toModelRange(t)));for(const i of n.dataTransfer.files){const n=Object(d.a)(o);Object(d.b)(i)&&(e.execute('imageUpload',{file:i,insertAt:n}),a.stop()),o=t.selection}}),e.editing.view.on('dragover',(e,t)=>{t.preventDefault()}),t.on('change',(e,t,a)=>{if('insert'===t||'reinsert'===t||'remove'===t)for(const e of a.range)if('elementStart'===e.type&&'image'===e.item.name){const a=e.item,o=a.getAttribute('uploadId');if(o){const e=n.loaders.get(o);e&&('insert'===t&&'idle'==e.status&&this.load(e,a),'remove'===t&&e.abort())}}})}load(e,a){function n(){t.enqueueChanges(()=>{t.batch('transparent').removeAttribute(a,'uploadId'),t.batch('transparent').removeAttribute(a,'uploadStatus')}),d.destroyLoader(e)}const r=this.editor,l=r.locale.t,t=r.document,d=r.plugins.get(i.a),c=r.plugins.get(s.a);t.enqueueChanges(()=>{t.batch('transparent').setAttribute(a,'uploadStatus','reading')}),e.read().then((n)=>{const o=r.editing.mapper.toViewElement(a),i=o.getChild(0),s=e.upload();return i.setAttribute('src',n),r.editing.view.render(),t.enqueueChanges(()=>{t.batch('transparent').setAttribute(a,'uploadStatus','uploading')}),s}).then((e)=>{t.enqueueChanges(()=>{t.batch('transparent').setAttribute(a,'uploadStatus','complete'),t.batch('transparent').setAttribute(a,'src',e.default);let n=0;const i=Object.keys(e).filter((e)=>{const t=parseInt(e,10);if(!isNaN(t))return n=o(n,t),!0}).map((t)=>`${e[t]} ${t}w`).join(', ');''!=i&&t.batch('transparent').setAttribute(a,'srcset',{data:i,width:n})}),n()}).catch((o)=>{'error'==e.status&&c.showWarning(o,{title:l('Upload failed'),namespace:'upload'}),n(),t.enqueueChanges(()=>{t.batch('transparent').remove(a)})})}}t.a=c},function(e,t,a){'use strict';t.b=function(e){const t=/^image\/(jpeg|png|gif|bmp)$/;return t.test(e.type)},t.a=function(e){const t=e.getSelectedElement();if(t)return n.a.createAfter(t);const a=e.getSelectedBlocks().next().value;if(a){if(a.isEmpty)return n.a.createAt(a);const t=n.a.createAfter(a);return e.focus.isTouching(t)?t:n.a.createBefore(a)}return e.focus};var n=a(1)},function(e,t,a){'use strict';var n=a(92);class o extends n.a{}t.a=o},function(e,t,a){'use strict';function n(e,t,a){let n=e.textNode||(a?e.nodeBefore:e.nodeAfter),o=null;for(;n&&n.getAttribute('linkHref')==t;)o=n,n=a?n.previousSibling:n.nextSibling;return o?i.a.createAt(o,a?'before':'after'):e}t.a=function(e,t){return new o.a(n(e,t,!0),n(e,t,!1))};var o=a(3),i=a(1)},function(e,t,a){'use strict';Object.defineProperty(t,'__esModule',{value:!0});var n=a(280),o=a(445),i=a(470),r=a(473),s=a(476),l=a(479),d=a(482),c=a(488),m=a(519),u=a(266),p=a(532),g=a(540),f=a(548),h=a(549),b=a(558),_=a(115),k=a(274);class y extends n.a{}t['default']=y,y.build={plugins:[o.a,i.a,r.a,s.a,l.a,d.a,c.a,m.a,u.a,p.a,g.a,f.a,h.a,b.a,_.a,k.a],config:{toolbar:{items:['headings','bold','italic','link','bulletedList','numberedList','blockQuote','undo','redo']},image:{toolbar:['imageStyleFull','imageStyleSide','|','imageTextAlternative']}}}},function(e,t,a){'use strict';var n=a(281),o=a(260),i=a(428),r=a(432),s=a(441),l=a(442),d=a.n(l);class c extends n.a{constructor(e,t){super(e,t),this.document.createRoot(),this.data.processor=new o.a,this.ui=new i.a(this,new r.a(this.locale)),this._elementReplacer=new s.a}destroy(){return this.updateEditorElement(),this._elementReplacer.restore(),this.ui.destroy(),super.destroy()}static create(e,t){return new Promise((a)=>{const n=new this(e,t);a(n.initPlugins().then(()=>n._elementReplacer.replace(e,n.ui.view.element)).then(()=>{n.ui.init(),n.fire('uiReady')}).then(()=>n.editing.view.attachDomRoot(n.ui.view.editableElement)).then(()=>n.loadDataFromEditorElement()).then(()=>{n.fire('dataReady'),n.fire('ready')}).then(()=>n))})}}t.a=c},function(e,t,a){'use strict';var n=a(282),o=a(408),i=a(409),r=a(65),s=a(425),l=a(426);class d extends n.a{constructor(e,t){super(t),this.element=e,this.editing=new i.a(this.document),this.editing.view.bind('isReadOnly').to(this),this.keystrokes=new o.a(this),this.keystrokes.listenTo(this.editing.view),this._attachToForm()}destroy(){return Promise.resolve().then(()=>this.keystrokes.destroy()).then(()=>this.editing.destroy()).then(super.destroy())}setData(e){this.data.set(e)}getData(){return this.data.get()}updateEditorElement(){Object(l.a)(this.element,this.getData())}loadDataFromEditorElement(){this.setData(Object(s.a)(this.element))}_attachToForm(){const e=this.element;if(e&&'textarea'===e.tagName.toLowerCase()&&e.form){let t;const a=e.form,n=()=>this.updateEditorElement();Object(r.a)(a.submit)&&(t=a.submit,a.submit=()=>{n(),t.apply(a)}),a.addEventListener('submit',n),this.on('destroy',()=>{a.removeEventListener('submit',n),t&&(a.submit=t)})}}static create(e,t){return new Promise((a)=>{const n=new this(e,t);a(n.initPlugins().then(()=>{n.fire('dataReady'),n.fire('ready')}).then(()=>n))})}}t.a=d},function(e,t,a){'use strict';var n=a(283),o=a(284),i=a(285),r=a(286),s=a(288),l=a(358),d=a(12),c=a(4);class m{constructor(e){const t=this.constructor.build&&this.constructor.build.plugins;this.config=new n.a(e,this.constructor.build&&this.constructor.build.config),this.config.define('plugins',t),this.plugins=new o.a(this,t),this.commands=new i.a,this.locale=new r.a(this.config.get('lang')),this.t=this.locale.t,this.document=new l.a,this.data=new s.a(this.document),this.set('isReadOnly',!1)}initPlugins(){function e(e,t){return e.reduce((e,a)=>a[t]?e.then(a[t].bind(a)):e,Promise.resolve())}const t=this,a=this.config;return function(){const e=a.get('plugins')||[],n=a.get('removePlugins')||[];return t.plugins.load(e,n)}().then((t)=>e(t,'init').then(()=>e(t,'afterInit'))).then(()=>this.fire('pluginsReady'))}destroy(){return this.fire('destroy'),this.stopListening(),this.commands.destroy(),this.plugins.destroy().then(()=>{this.document.destroy(),this.data.destroy()})}execute(...e){this.commands.execute(...e)}static create(e){return new Promise((t)=>{const a=new this(e);t(a.initPlugins().then(()=>{a.fire('dataReady'),a.fire('ready')}).then(()=>a))})}}t.a=m,Object(c.a)(m,d.a)},function(e,t,a){'use strict';var n=a(77);t.a=class{constructor(e,t){this._config={},t&&this.define(t),e&&this._setObjectToTarget(this._config,e)}set(e,t){this._setToTarget(this._config,e,t)}define(e,t){this._setToTarget(this._config,e,t,!0)}get(e){return this._getFromSource(this._config,e)}_setToTarget(e,t,a,o=!1){if(Object(n.a)(t))return void this._setObjectToTarget(e,t,o);const i=t.split('.');t=i.pop();for(const r of i)Object(n.a)(e[r])||(e[r]={}),e=e[r];return Object(n.a)(a)?(Object(n.a)(e[t])||(e[t]={}),e=e[t],void this._setObjectToTarget(e,a,o)):void(o&&'undefined'!=typeof e[t]||(e[t]=a))}_getFromSource(e,t){const a=t.split('.');t=a.pop();for(const o of a){if(!Object(n.a)(e[o])){e=null;break}e=e[o]}return e?e[t]:void 0}_setObjectToTarget(e,t,a){Object.keys(t).forEach((n)=>{this._setToTarget(e,n,t[n],a)})}}},function(e,t,a){'use strict';var n=a(0),o=a(16);class i{constructor(e,t=[]){this._editor=e,this._availablePlugins=new Map,this._plugins=new Map;for(const a of t)this._availablePlugins.set(a,a),a.pluginName&&this._availablePlugins.set(a.pluginName,a)}*[Symbol.iterator](){for(const e of this._plugins)'function'==typeof e[0]&&(yield e)}get(e){return this._plugins.get(e)}load(e,t=[]){function a(e){return p.includes(e)||l.get(e)||c.has(e)?void 0:i(e).catch((t)=>{throw o.a.error('plugincollection-load: It was not possible to load the plugin.',{plugin:e}),t})}function i(e){return new Promise((o)=>{c.add(e),e.requires&&e.requires.forEach((o)=>{const i=r(o);if(t.includes(i))throw new n.b('plugincollection-required: Cannot load a plugin because one of its dependencies is listed inthe `removePlugins` option.',{plugin:i,requiredBy:e});a(i)});const i=new e(d);l._add(e,i),m.push(i),o()})}function r(e){return'function'==typeof e?e:l._availablePlugins.get(e)}function s(e){return e.map((e)=>r(e)).filter((e)=>!!e)}const l=this,d=this._editor,c=new Set,m=[],u=s(e),p=s(t),g=function(e){const t=[];for(const a of e)r(a)||t.push(a);return t.length?t:null}(e);if(g){const e='plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.';return o.a.error(e,{plugins:g}),Promise.reject(new n.b(e,{plugins:g}))}return Promise.all(u.map(a)).then(()=>m)}destroy(){const e=Array.from(this).map(([,e])=>e).filter((e)=>'function'==typeof e.destroy).map((e)=>e.destroy());return Promise.all(e)}_add(e,t){this._plugins.set(e,t);const a=e.pluginName;a&&(this._plugins.has(a)?o.a.warn('plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.',{pluginName:a,plugin1:this._plugins.get(a).constructor,plugin2:e}):this._plugins.set(a,t))}}t.a=i},function(e,t,a){'use strict';var n=a(0);class o{constructor(){this._commands=new Map}add(e,t){this._commands.set(e,t)}get(e){return this._commands.get(e)}execute(e,...t){const a=this.get(e);if(!a)throw new n.b('commandcollection-command-not-found: Command does not exist.',{commandName:e});a.execute(...t)}*names(){yield*this._commands.keys()}*commands(){yield*this._commands.values()}[Symbol.iterator](){return this._commands[Symbol.iterator]()}destroy(){for(const e of this.commands())e.destroy()}}t.a=o},function(e,t,a){'use strict';var n=a(287);t.a=class{constructor(e){this.lang=e||'en',this.t=(...e)=>this._t(...e)}_t(e,t){let a=Object(n.a)(this.lang,e);return t&&(a=a.replace(/%(\d+)/g,(e,a)=>a<t.length?t[a]:e)),a}}},function(e,t){'use strict';function a(e,t){return e in n&&t in n[e]}t.a=function(e,t){return a(e,t)?n[e][t]:t.replace(/ \[context: [^\]]+\]$/,'')};let n={}},function(e,t,a){'use strict';var n=a(4),o=a(12),i=a(163),r=a(176),s=a(71),l=a(351),d=a(353),c=a(128),m=a(3),u=a(1),p=a(5),g=a(354),f=a(355),h=a(356),b=a(357);class _{constructor(e,t){this.model=e,this.processor=t,this.mapper=new i.a,this.modelToView=new r.a(this.model,{mapper:this.mapper}),this.modelToView.on('insert:$text',Object(s.f)(),{priority:'lowest'}),this.viewToModel=new l.a({schema:e.schema}),this.viewToModel.on('text',Object(d.a)(),{priority:'lowest'}),this.viewToModel.on('element',Object(d.b)(),{priority:'lowest'}),this.viewToModel.on('documentFragment',Object(d.b)(),{priority:'lowest'}),['insertContent','deleteContent','modifySelection','getSelectedContent'].forEach((e)=>this.decorate(e))}get(e='main'){return this.stringify(this.model.getRoot(e))}stringify(e){const t=this.toView(e);return this.processor.toData(t)}toView(e){const t=m.a.createIn(e),a=new c.a;return this.mapper.bindElements(e,a),this.modelToView.convertInsertion(t),this.mapper.clearBindings(),a}set(e,t='main'){const a=this.model.getRoot(t);this.model.enqueueChanges(()=>{this.model.selection.removeAllRanges(),this.model.selection.clearAttributes(),this.model.batch('transparent').remove(m.a.createIn(a)).insert(u.a.createAt(a,0),this.parse(e))})}parse(e,t='$root'){const a=this.processor.toView(e);return this.toModel(a,t)}toModel(e,t='$root'){return this.viewToModel.convert(e,{context:[t]})}destroy(){}insertContent(e,t,a){Object(g.a)(this,e,t,a)}deleteContent(e,t,a){Object(f.a)(e,t,a)}modifySelection(e,t){Object(h.a)(this,e,t)}getSelectedContent(e){return Object(b.a)(e)}hasContent(e){if(e instanceof p.a&&(e=m.a.createIn(e)),e.isCollapsed)return!1;for(const t of e.getItems())if(t.is('textProxy')||this.model.schema.objects.has(t.name))return!0;return!1}}t.a=_,Object(n.a)(_,o.a)},function(e,t,a){'use strict';var n=a(290);t.a=class{constructor(e,t){this.source=e,this.name=t,this.path=[],this.stop=Object(n.a)(),this.off=Object(n.a)()}}},function(e,t){'use strict';t.a=function(){return function e(){e.called=!0}}},function(e,t){'use strict';const a={get(e){return'number'==typeof e?e:this[e]||this.normal},highest:1e5,high:1e3,normal:0,low:-1e3,lowest:-1e5};t.a=a},function(e,t,a){'use strict';var n=a(64),o=a(117),i=a(293),r=a(80),s=a(82),l=a(296),d=Object.prototype,c=d.propertyIsEnumerable,m=!c.call({valueOf:1},'valueOf'),u=Object(i.a)(function(e,t){if(m||Object(s.a)(t)||Object(r.a)(t))return void Object(o.a)(t,Object(l.a)(t),e);for(var a in t)Object(n.a)(e,a,t[a])});t.a=u},function(e,t,a){'use strict';var n=a(79),o=a(9);t.a=function(e){return Object(o.a)(function(t,a){var o=-1,i=a.length,r=1<i?a[i-1]:void 0,s=2<i?a[2]:void 0;for(r=3<e.length&&'function'==typeof r?(i--,r):void 0,s&&Object(n.a)(a[0],a[1],s)&&(r=3>i?void 0:r,i=1),t=Object(t);++o<i;){var l=a[o];l&&e(t,l,o,r)}return t})}},function(e,t,a){'use strict';var n=a(118),o=Object(n.a)('length');t.a=o},function(e,t,a){'use strict';var n=a(159),o=1/0;t.a=function(e){if(!e)return 0===e?e:0;if(e=Object(n.a)(e),e===o||e===-o){var t=0>e?-1:1;return t*1.7976931348623157e308}return e===e?e:0}},function(e,t,a){'use strict';var n=a(297),o=a(161),i=a(37),r=a(82),s=Object.prototype,l=s.hasOwnProperty;t.a=function(e){for(var t=-1,a=Object(r.a)(e),s=Object(n.a)(e),d=s.length,c=Object(o.a)(e),m=c||[],u=m.length;++t<d;){var p=s[t];!!c&&('length'==p||Object(i.a)(p,u))||'constructor'==p&&(a||!l.call(e,p))||m.push(p)}return m}},function(e,t,a){'use strict';function n(e){e=null==e?e:Object(e);var t=[];for(var a in e)t.push(a);return t}var o=a(298),i=a(301),r=Object.prototype,s=o.a?o.a.enumerate:void 0,l=r.propertyIsEnumerable;s&&!l.call({valueOf:1},'valueOf')&&(n=function(e){return Object(i.a)(s(e))}),t.a=n},function(e,t,a){'use strict';var n=a(33),o=n.a.Reflect;t.a=o},function(e){var t=function(){return this}();try{t=t||Function('return this')()||(1,eval)('this')}catch(a){'object'==typeof window&&(t=window)}e.exports=t},function(e,t){'use strict';t.a=function(e){return e&&e.Object===Object?e:null}},function(e,t){'use strict';t.a=function(e){for(var t=[],a;!(a=e.next()).done;)t.push(a.value);return t}},function(e,t){'use strict';t.a=function(){this.__data__=[]}},function(e,t,a){'use strict';var n=a(86),o=Array.prototype,i=o.splice;t.a=function(e){var t=this.__data__,a=Object(n.a)(t,e);if(0>a)return!1;var o=t.length-1;return a==o?t.pop():i.call(t,a,1),!0}},function(e,t,a){'use strict';var n=a(86);t.a=function(e){var t=this.__data__,a=Object(n.a)(t,e);return 0>a?void 0:t[a][1]}},function(e,t,a){'use strict';var n=a(86);t.a=function(e){return-1<Object(n.a)(this.__data__,e)}},function(e,t,a){'use strict';var n=a(86);t.a=function(e,t){var a=this.__data__,o=Object(n.a)(a,e);return 0>o?a.push([e,t]):a[o][1]=t,this}},function(e,t,a){'use strict';var n=a(85);t.a=function(){this.__data__=new n.a}},function(e,t){'use strict';t.a=function(e){return this.__data__['delete'](e)}},function(e,t){'use strict';t.a=function(e){return this.__data__.get(e)}},function(e,t){'use strict';t.a=function(e){return this.__data__.has(e)}},function(e,t,a){'use strict';var n=a(85),o=a(123);t.a=function(e,t){var a=this.__data__;return a instanceof n.a&&a.__data__.length==200&&(a=this.__data__=new o.a(a.__data__)),a.set(e,t),this}},function(e,t,a){'use strict';var n=a(313),o=a(85),i=a(168);t.a=function(){this.__data__={hash:new n.a,map:new(i.a||o.a),string:new n.a}}},function(e,t,a){'use strict';function n(e){var t=-1,a=e?e.length:0;for(this.clear();++t<a;){var n=e[t];this.set(n[0],n[1])}}var o=a(314),i=a(315),r=a(316),s=a(317),l=a(318);n.prototype.clear=o.a,n.prototype['delete']=i.a,n.prototype.get=r.a,n.prototype.has=s.a,n.prototype.set=l.a,t.a=n},function(e,t,a){'use strict';var n=a(87);t.a=function(){this.__data__=n.a?Object(n.a)(null):{}}},function(e,t){'use strict';t.a=function(e){return this.has(e)&&delete this.__data__[e]}},function(e,t,a){'use strict';var n=a(87),o=Object.prototype,i=o.hasOwnProperty;t.a=function(e){var t=this.__data__;if(n.a){var a=t[e];return a==='__lodash_hash_undefined__'?void 0:a}return i.call(t,e)?t[e]:void 0}},function(e,t,a){'use strict';var n=a(87),o=Object.prototype,i=o.hasOwnProperty;t.a=function(e){var t=this.__data__;return n.a?t[e]!==void 0:i.call(t,e)}},function(e,t,a){'use strict';var n=a(87);t.a=function(e,t){var a=this.__data__;return a[e]=n.a&&void 0===t?'__lodash_hash_undefined__':t,this}},function(e,t,a){'use strict';var n=a(88);t.a=function(e){return Object(n.a)(this,e)['delete'](e)}},function(e,t){'use strict';t.a=function(e){var t=typeof e;return'string'==t||'number'==t||'symbol'==t||'boolean'==t?'__proto__'!==e:null===e}},function(e,t,a){'use strict';var n=a(88);t.a=function(e){return Object(n.a)(this,e).get(e)}},function(e,t,a){'use strict';var n=a(88);t.a=function(e){return Object(n.a)(this,e).has(e)}},function(e,t,a){'use strict';var n=a(88);t.a=function(e,t){return Object(n.a)(this,e).set(e,t),this}},function(e,t){'use strict';t.a=function(e,t){for(var a=-1,n=e.length;++a<n&&!(!1===t(e[a],a,e)););return e}},function(e,t,a){'use strict';var n=a(117),o=a(70);t.a=function(e,t){return e&&Object(n.a)(t,Object(o.a)(t),e)}},function(e,t){'use strict';var a=Object.keys;t.a=function(e){return a(Object(e))}},function(e,t){'use strict';t.a=function(e,t){if(t)return e.slice();var a=new e.constructor(e.length);return e.copy(a),a}},function(e,t,a){'use strict';var n=a(117),o=a(171);t.a=function(e,t){return Object(n.a)(e,Object(o.a)(e),t)}},function(e,t,a){'use strict';var n=a(330),o=a(171),i=a(70);t.a=function(e){return Object(n.a)(e,i.a,o.a)}},function(e,t,a){'use strict';var n=a(89),o=a(15);t.a=function(e,t,a){var i=t(e);return Object(o.a)(e)?i:Object(n.a)(i,a(e))}},function(e,t,a){'use strict';var n=a(56),o=a(33),i=Object(n.a)(o.a,'DataView');t.a=i},function(e,t,a){'use strict';var n=a(56),o=a(33),i=Object(n.a)(o.a,'Promise');t.a=i},function(e,t,a){'use strict';var n=a(56),o=a(33),i=Object(n.a)(o.a,'WeakMap');t.a=i},function(e,t){'use strict';var a=Object.prototype,n=a.hasOwnProperty;t.a=function(e){var t=e.length,a=e.constructor(t);return t&&'string'==typeof e[0]&&n.call(e,'index')&&(a.index=e.index,a.input=e.input),a}},function(e,t,a){'use strict';var n=a(125),o=a(336),i=a(337),r=a(339),s=a(340),l=a(342),d=a(343);t.a=function(e,t,a,c){var m=e.constructor;return t==='[object ArrayBuffer]'?Object(n.a)(e):t==='[object Boolean]'||t==='[object Date]'?new m(+e):t==='[object DataView]'?Object(o.a)(e,c):t==='[object Float32Array]'||t==='[object Float64Array]'||t==='[object Int8Array]'||t==='[object Int16Array]'||t==='[object Int32Array]'||t==='[object Uint8Array]'||t==='[object Uint8ClampedArray]'||t==='[object Uint16Array]'||t==='[object Uint32Array]'?Object(d.a)(e,c):t==='[object Map]'?Object(i.a)(e,c,a):t==='[object Number]'||t==='[object String]'?new m(e):t==='[object RegExp]'?Object(r.a)(e):t==='[object Set]'?Object(s.a)(e,c,a):t==='[object Symbol]'?Object(l.a)(e):void 0}},function(e,t,a){'use strict';var n=a(125);t.a=function(e,t){var a=t?Object(n.a)(e.buffer):e.buffer;return new e.constructor(a,e.byteOffset,e.byteLength)}},function(e,t,a){'use strict';var n=a(338),o=a(174),i=a(126);t.a=function(e,t,a){var r=t?a(Object(i.a)(e),!0):Object(i.a)(e);return Object(o.a)(r,n.a,new e.constructor)}},function(e,t){'use strict';t.a=function(e,t){return e.set(t[0],t[1]),e}},function(e,t){'use strict';var a=/\w*$/;t.a=function(e){var t=new e.constructor(e.source,a.exec(e));return t.lastIndex=e.lastIndex,t}},function(e,t,a){'use strict';var n=a(341),o=a(174),i=a(90);t.a=function(e,t,a){var r=t?a(Object(i.a)(e),!0):Object(i.a)(e);return Object(o.a)(r,n.a,new e.constructor)}},function(e,t){'use strict';t.a=function(e,t){return e.add(t),e}},function(e,t,a){'use strict';var n=a(127),o=n.a?n.a.prototype:void 0,i=o?o.valueOf:void 0;t.a=function(e){return i?Object(i.call(e)):{}}},function(e,t,a){'use strict';var n=a(125);t.a=function(e,t){var a=t?Object(n.a)(e.buffer):e.buffer;return new e.constructor(a,e.byteOffset,e.length)}},function(e,t,a){'use strict';var n=a(345),o=a(116),i=a(82);t.a=function(e){return'function'!=typeof e.constructor||Object(i.a)(e)?{}:Object(n.a)(Object(o.a)(e))}},function(e,t,a){'use strict';var n=a(17),o=Object.create;t.a=function(e){return Object(n.a)(e)?o(e):{}}},function(e,t,a){'use strict';(function(e){var n=a(347),o=a(33),i={function:!0,object:!0},r=i[typeof exports]&&exports&&!exports.nodeType?exports:void 0,s=i[typeof e]&&e&&!e.nodeType?e:void 0,l=s&&s.exports===r?r:void 0,d=l?o.a.Buffer:void 0,c=d?function(e){return e instanceof d}:Object(n.a)(!1);t.a=c}).call(t,a(160)(e))},function(e,t){'use strict';t.a=function(e){return function(){return e}}},function(e,t,a){'use strict';var n=a(0);class o{constructor(e,t,a){if(this.textNode=e,0>t||t>e.data.length)throw new n.b('view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.');if(0>a||t+a>e.data.length)throw new n.b('view-textproxy-wrong-length: Given length value is incorrect.');this.data=e.data.substring(t,t+a),this.offsetInText=t}get isPartial(){return this.data.length!==this.textNode.data.length}get parent(){return this.textNode.parent}get root(){return this.textNode.root}get document(){return this.textNode.document}is(e){return'textProxy'==e}getAncestors(e={includeSelf:!1,parentFirst:!1}){const t=[];for(let a=e.includeSelf?this.textNode:this.parent;null!==a;)t[e.parentFirst?'push':'unshift'](a),a=a.parent;return t}}t.a=o},function(e,t,a){'use strict';var n=a(67);t.a=class{constructor(){this._consumable=new Map,this._textProxyRegistry=new Map}add(e,t){e instanceof n.a&&(e=this._getSymbolForTextProxy(e)),this._consumable.has(e)||this._consumable.set(e,new Map),this._consumable.get(e).set(t,!0)}consume(e,t){return e instanceof n.a&&(e=this._getSymbolForTextProxy(e)),!!this.test(e,t)&&(this._consumable.get(e).set(t,!1),!0)}test(e,t){e instanceof n.a&&(e=this._getSymbolForTextProxy(e));const a=this._consumable.get(e);if(a===void 0)return null;const o=a.get(t);return void 0===o?null:o}revert(e,t){e instanceof n.a&&(e=this._getSymbolForTextProxy(e));const a=this.test(e,t);return!1===a?(this._consumable.get(e).set(t,!0),!0):!0!==a&&null}_getSymbolForTextProxy(e){let t=null;const a=this._textProxyRegistry.get(e.startOffset);if(a){const n=a.get(e.endOffset);n&&(t=n.get(e.parent))}return t||(t=this._addSymbolForTextProxy(e.startOffset,e.endOffset,e.parent)),t}_addSymbolForTextProxy(e,t,a){const n=Symbol('textProxySymbol');let o,i;return o=this._textProxyRegistry.get(e),o||(o=new Map,this._textProxyRegistry.set(e,o)),i=o.get(t),i||(i=new Map,o.set(t,i)),i.set(a,n),n}}},function(e,t){'use strict';const a=navigator.userAgent.toLowerCase(),n={mac:function(e){return-1<e.indexOf('macintosh')}(a)};t.a=n},function(e,t,a){'use strict';function n(e){const t=new Set,a=new Map,n=new s.a({startPosition:r.a.createAt(e,0),ignoreElementEnd:!0});for(const a of n)'$marker'==a.item.name&&t.add(a.item);for(const n of t){const e=n.getAttribute('data-name'),t=r.a.createBefore(n);a.has(e)?a.get(e).end=r.a.createFromPosition(t):a.set(e,new i.a(r.a.createFromPosition(t))),Object(c.d)(i.a.createOn(n))}return a}var o=a(352),i=a(3),r=a(1),s=a(54),l=a(66),d=a(39),c=a(23),m=a(8),u=a(4),p=a(45),g=a(16);class f{constructor(e={}){this.conversionApi=Object(p.a)({},e),this.conversionApi.convertItem=this._convertItem.bind(this),this.conversionApi.convertChildren=this._convertChildren.bind(this)}convert(e,t={}){this.fire('viewCleanup',e);const a=o.a.createFrom(e);let i=this._convertItem(e,a,t);return i?(i.is('documentFragment')||(i=new d.a([i])),i.markers=n(i),i):new d.a}_convertItem(e,t,a={}){const n=Object(p.a)({},a,{input:e,output:null});return e.is('element')?this.fire('element:'+e.name,n,t,this.conversionApi):e.is('text')?this.fire('text',n,t,this.conversionApi):this.fire('documentFragment',n,t,this.conversionApi),n.output&&!(n.output instanceof l.a||n.output instanceof d.a)?(g.a.warn('view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.',[e,n.output]),null):n.output}_convertChildren(e,t,a={}){const n=Array.from(e.getChildren()),o=n.map((e)=>this._convertItem(e,t,a)).filter((e)=>e instanceof l.a||e instanceof d.a).reduce((e,t)=>e.concat(t.is('documentFragment')?Array.from(t.getChildren()):t),[]);return new d.a(o)}}t.a=f,Object(u.a)(f,m.c)},function(e,t,a){'use strict';var n=a(15),o=a(0);class i{constructor(){this._consumables=new Map}add(e,t){let a;return e.is('text')||e.is('documentFragment')?void this._consumables.set(e,!0):void(this._consumables.has(e)?a=this._consumables.get(e):(a=new r,this._consumables.set(e,a)),a.add(t))}test(e,t){const a=this._consumables.get(e);return void 0===a?null:e.is('text')||e.is('documentFragment')?a:a.test(t)}consume(e,t){return!!this.test(e,t)&&(e.is('text')||e.is('documentFragment')?this._consumables.set(e,!1):this._consumables.get(e).consume(t),!0)}revert(e,t){const a=this._consumables.get(e);a!==void 0&&(e.is('text')||e.is('documentFragment')?this._consumables.set(e,!0):a.revert(t))}static consumablesFromElement(e){const t={name:!0,attribute:[],class:[],style:[]},a=e.getAttributeKeys();for(const n of a)'style'!=n&&'class'!=n&&t.attribute.push(n);const n=e.getClassNames();for(const a of n)t.class.push(a);const o=e.getStyleNames();for(const a of o)t.style.push(a);return t}static createFrom(e,t){if(t||(t=new i),e.is('text'))return t.add(e),t;e.is('element')&&t.add(e,i.consumablesFromElement(e)),e.is('documentFragment')&&t.add(e);for(const a of e.getChildren())t=i.createFrom(a,t);return t}}t.a=i;class r{constructor(){this._canConsumeName=null,this._consumables={attribute:new Map,style:new Map,class:new Map}}add(e){for(const t in e.name&&(this._canConsumeName=!0),this._consumables)t in e&&this._add(t,e[t])}test(e){if(e.name&&!this._canConsumeName)return this._canConsumeName;for(const t in this._consumables)if(t in e){const a=this._test(t,e[t]);if(!0!==a)return a}return!0}consume(e){for(const t in e.name&&(this._canConsumeName=!1),this._consumables)t in e&&this._consume(t,e[t])}revert(e){for(const t in e.name&&(this._canConsumeName=!0),this._consumables)t in e&&this._revert(t,e[t])}_add(e,t){const a=Object(n.a)(t)?t:[t],i=this._consumables[e];for(const n of a){if('attribute'===e&&('class'===n||'style'===n))throw new o.b('viewconsumable-invalid-attribute: Classes and styles should be handled separately.');i.set(n,!0)}}_test(e,t){const a=Object(n.a)(t)?t:[t],o=this._consumables[e];for(const n of a)if('attribute'===e&&('class'===n||'style'===n)){const e=this._test(n,[...this._consumables[n].keys()]);if(!0!==e)return e}else{const e=o.get(n);if(e===void 0)return null;if(!e)return!1}return!0}_consume(e,t){const a=Object(n.a)(t)?t:[t],o=this._consumables[e];for(const n of a)'attribute'===e&&('class'===n||'style'===n)?this._consume(n,[...this._consumables[n].keys()]):o.set(n,!1)}_revert(e,t){const a=Object(n.a)(t)?t:[t],o=this._consumables[e];for(const n of a)if('attribute'===e&&('class'===n||'style'===n))this._revert(n,[...this._consumables[n].keys()]);else{const e=o.get(n);!1===e&&o.set(n,!0)}}}},function(e,t,a){'use strict';t.b=function(){return(e,t,a,o)=>{if(!t.output&&a.consume(t.input,{name:!0})){const e=o.convertChildren(t.input,a,t);t.output=new n.a(Object(i.c)(e))}}},t.a=function(){return(e,t,a,n)=>{const i={name:'$text',inside:t.context};n.schema.check(i)&&a.consume(t.input)&&(t.output=new o.a(t.input.data))}};var n=a(39),o=a(26),i=a(23)},function(e,t,a){'use strict';function n(e){return e.is('text')?'$text':e.name}t.a=function(e,t,a,n){n||(n=e.model.batch()),a.isCollapsed||e.deleteContent(a,n);const o=new d(e,n,a.anchor);let i;i=t.is('documentFragment')?t.getChildren():[t],o.handleNodes(i,{isFirst:!0,isLast:!0});const r=o.getSelectionRange();r?a.setRanges([r]):l.a.warn('insertcontent-no-range: Cannot determine a proper selection range after insertion.')};var o=a(1),i=a(178),r=a(5),s=a(3),l=a(16);class d{constructor(e,t,a){this.dataController=e,this.batch=t,this.position=a,this.canMergeWith=new Set([this.position.parent]),this.schema=e.model.schema}handleNodes(e,t){e=Array.from(e);for(let a=0;a<e.length;a++){const n=e[a];this._handleNode(n,{isFirst:0===a&&t.isFirst,isLast:a===e.length-1&&t.isLast})}}getSelectionRange(){return this.nodeToSelect?s.a.createOn(this.nodeToSelect):this.dataController.model.getNearestSelectionRange(this.position)}_handleNode(e,t){if(this._checkIsObject(e))return void this._handleObject(e,t);const a=this._checkAndSplitToAllowedPosition(e,t);return a?void(this._insert(e),this._mergeSiblingsOf(e,t)):void this._handleDisallowedNode(e,t)}_handleObject(e,t){this._checkAndSplitToAllowedPosition(e)?this._insert(e):this._tryAutoparagraphing(e,t)}_handleDisallowedNode(e,t){e.is('element')?this.handleNodes(e.getChildren(),t):this.schema.check({name:'$text',inside:this.position})?(this.schema.removeDisallowedAttributes([e],this.position),this._handleNode(e,t)):this._tryAutoparagraphing(e,t)}_insert(e){if(!this._checkIsAllowed(e,this.position))return void l.a.error('insertcontent-wrong-position: The node cannot be inserted on the given position.',{node:e,position:this.position});const t=i.a.createFromPosition(this.position);this.batch.insert(this.position,e),this.position=o.a.createFromPosition(t),t.detach(),this.nodeToSelect=this._checkIsObject(e)&&!this.schema.check({name:'$text',inside:this.position})?e:null}_mergeSiblingsOf(e,t){if(e instanceof r.a){const a=t.isFirst&&e.previousSibling instanceof r.a&&this.canMergeWith.has(e.previousSibling),n=t.isLast&&e.nextSibling instanceof r.a&&this.canMergeWith.has(e.nextSibling),s=i.a.createBefore(e),d=i.a.createAfter(e);if(a){const e=i.a.createFromPosition(this.position);this.batch.merge(s);const t=e.nodeBefore;this.schema.removeDisallowedAttributes(t.getChildren(),o.a.createAt(t),this.batch),this.position=o.a.createFromPosition(e),e.detach()}if(n){this.position.isEqual(d)||l.a.error('insertcontent-wrong-position-on-merge: The insertion position should equal the merge position'),this.position=o.a.createAt(d.nodeBefore,'end');const e=new i.a(this.position.root,this.position.path,'sticksToPrevious');this.batch.merge(d),this.schema.removeDisallowedAttributes(e.parent.getChildren(),e,this.batch),this.position=o.a.createFromPosition(e),e.detach()}s.detach(),d.detach(),a||n||this.schema.removeDisallowedAttributes(e.getChildren(),o.a.createAt(e),this.batch)}}_tryAutoparagraphing(e,t){const a=new r.a('paragraph');this._getAllowedIn(a,this.position.parent)&&(e.is('text')&&!this._checkIsAllowed(e,[a])&&this.schema.removeDisallowedAttributes([e],[a]),this._checkIsAllowed(e,[a])&&(a.appendChildren(e),this._handleNode(a,t)))}_checkAndSplitToAllowedPosition(e){const t=this._getAllowedIn(e,this.position.parent);if(!t)return!1;for(;t!=this.position.parent;){if(this.schema.limits.has(this.position.parent.name))return!1;if(this.position.isAtStart){const e=this.position.parent;this.position=o.a.createBefore(e),e.isEmpty&&this.batch.remove(e)}else if(this.position.isAtEnd)this.position=o.a.createAfter(this.position.parent);else{const e=o.a.createAfter(this.position.parent);this.batch.split(this.position),this.position=e,this.canMergeWith.add(this.position.nodeAfter)}}return!0}_getAllowedIn(e,t){return this._checkIsAllowed(e,[t])?t:t.parent?this._getAllowedIn(e,t.parent):null}_checkIsAllowed(e,t){return this.schema.check({name:n(e),attributes:Array.from(e.getAttributeKeys()),inside:t})}_checkIsObject(e){return this.schema.objects.has(n(e))}}},function(e,t,a){'use strict';function n(e,t,a){const o=t.parent,r=a.parent;if(o!=r&&o.parent&&r.parent&&i(t,a)){for(t=c.a.createAfter(o),a=c.a.createBefore(r),r.isEmpty?e.remove(r):(!a.isEqual(t)&&e.move(r,t),e.merge(t));a.parent.isEmpty;){const t=a.parent;a=c.a.createBefore(t),e.remove(t)}n(e,t,a)}}function o(e,t){const a=e.check({name:'$text',inside:t}),n=e.check({name:'paragraph',inside:t});return!a&&n}function i(e,t){const a=e.root.document.schema,n=new m.a(e,t);for(const o of n.getWalker())if(a.objects.has(o.item.name)||a.limits.has(o.item.name))return!1;return!0}function r(e,t,a){const n=new u.a('paragraph');e.insert(t,n),a.setCollapsedAt(n)}function s(e,t){const a=e.document.schema.getLimitElement(t);e.remove(m.a.createIn(a)),r(e,c.a.createAt(a),t)}function l(e,t){const a=e.getLimitElement(t);if(!t.containsEntireContent(a))return!1;const n=t.getFirstRange();return n.start.parent!=n.end.parent&&e.check({name:'paragraph',inside:a.name})}t.a=function(e,t,a={}){if(!e.isCollapsed){const i=t.document.schema;if(!a.doNotResetEntireContent&&l(i,e))return void s(t,e);const c=e.getFirstRange(),m=c.start,u=d.a.createFromPosition(c.end);c.start.isTouching(c.end)||t.remove(c),a.leaveUnmerged||(n(t,m,u),i.removeDisallowedAttributes(m.parent.getChildren(),m,t)),e.setCollapsedAt(m),o(i,m)&&r(t,m,e),u.detach()}};var d=a(178),c=a(1),m=a(3),u=a(5)},function(e,t,a){'use strict';function n(e,t){if('text'==t.type)return o(e.walker,e.unit);if(t.type==(e.isForward?'elementStart':'elementEnd')){if(e.schema.objects.has(t.item.name))return r.a.createAt(t.item,e.isForward?'after':'before');if(e.schema.check({name:'$text',inside:t.nextPosition}))return t.nextPosition}else{if(e.schema.limits.has(t.item.name))return void e.walker.skip(()=>!0);if(e.schema.check({name:'$text',inside:t.nextPosition}))return t.nextPosition}}function o(e,t){const a=e.position.textNode;if(a){const n=a.data;for(let o=e.position.offset-a.startOffset;Object(d.b)(n,o)||'character'==t&&Object(d.a)(n,o);)e.next(),o=e.position.offset-a.startOffset}return e.position}function i(e,t){const a=e.root,n=r.a.createAt(a,t?'end':0);return t?new l.a(e,n):new l.a(n,e)}t.a=function(e,t,a={}){const o=e.model.schema,r='backward'!=a.direction,l=a.unit?a.unit:'character',d=t.focus,c=new s.a({boundaries:i(d,r),singleCharacters:!0,direction:r?'forward':'backward'}),m={walker:c,schema:o,isForward:r,unit:l};for(let o;o=c.next();){if(o.done)return;const e=n(m,o.value);if(e)return void t.moveFocusTo(e)}};var r=a(1),s=a(54),l=a(3),d=a(179)},function(e,t,a){'use strict';function n(e){const t=[];Array.from(e.getItems({direction:'backward'})).map((e)=>i.a.createOn(e)).filter((t)=>{const a=(t.start.isAfter(e.start)||t.start.isEqual(e.start))&&(t.end.isBefore(e.end)||t.end.isEqual(e.end));return a}).forEach((e)=>{t.push(e.start.parent),Object(l.d)(e)}),t.forEach((e)=>{for(let t=e;t.parent&&t.isEmpty;){const e=i.a.createOn(t);t=t.parent,Object(l.d)(e)}})}t.a=function(e){const t=new o.a,a=e.getFirstRange();if(!a||a.isCollapsed)return t;const l=a.start.root,d=a.start.getCommonPath(a.end),c=l.getNodeByPath(d);let m=a.start.parent==a.end.parent?a:i.a.createFromParentsAndOffsets(c,a.start.path[d.length],c,a.end.path[d.length]+1);const u=m.end.offset-m.start.offset;for(const a of m.getItems({shallow:!0}))a.is('textProxy')?t.appendChildren(new s.a(a.data,a.getAttributes())):t.appendChildren(a.clone(!0));if(m!=a){const e=a._getTransformedByMove(m.start,r.a.createAt(t,0),u)[0],o=new i.a(r.a.createAt(t),e.start),s=new i.a(e.end,r.a.createAt(t,'end'));n(s),n(o)}return t};var o=a(39),i=a(3),r=a(1),s=a(26),l=a(23)},function(e,t,a){'use strict';function n(e){const t=e.textNode;if(t){const a=t.data,n=e.offset-t.startOffset;return!Object(w.b)(a,n)&&!Object(w.a)(a,n)}return!0}function*o(e,t){for(let a=!1;!a;){if(a=!0,e){const t=e.next();t.done||(a=!1,yield{walker:e,value:t.value})}if(t){const e=t.next();e.done||(a=!1,yield{walker:t,value:e.value})}}}var i=a(359),r=a(369),s=a(3),l=a(1),d=a(403),c=a(20),m=a(404),u=a(250),p=a(406),g=a(54),f=a(407),h=a(182),b=a(69),_=a(8),k=a(0),y=a(4),w=a(179);const v='$graveyard';class x{constructor(){this.version=0,this.schema=new p.a,this.history=new m.a(this),this.markers=new f.a,this.selection=new u.a(this),this._pendingChanges=[],this.roots=new Map,this.selection.on('change:range',()=>{for(const e of this.selection.getRanges())if(!this._validateSelectionRange(e))throw new k.b('document-selection-wrong-position: Range from document selection starts or ends at incorrect position.',{range:e})}),this.createRoot('$root',v)}get graveyard(){return this.getRoot(v)}applyOperation(e){if(e.baseVersion!==this.version)throw new k.b('model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.',{operation:e});const t=e._execute();this.version++,this.history.addDelta(e.delta),this.fire('change',e.type,t,e.delta.batch,e.delta.type)}batch(e){return new c.a(this,e)}createRoot(e='$root',t='main'){if(this.roots.has(t))throw new k.b('model-document-createRoot-name-exists: Root with specified name already exists.',{name:t});const a=new d.a(this,e,t);return this.roots.set(t,a),a}destroy(){this.selection.destroy(),this.stopListening()}enqueueChanges(e){if(this._pendingChanges.push(e),1==this._pendingChanges.length){for(;this._pendingChanges.length;)this._pendingChanges[0](),this._pendingChanges.shift();this.fire('changesDone')}}getRoot(e='main'){if(!this.roots.has(e))throw new k.b('model-document-getRoot-root-not-exist: Root with specified name does not exist.',{name:e});return this.roots.get(e)}hasRoot(e){return this.roots.has(e)}getRootNames(){return Array.from(this.roots.keys()).filter((e)=>e!=v)}getNearestSelectionRange(e,t='both'){if(this.schema.check({name:'$text',inside:e}))return new s.a(e);let a,n;('both'==t||'backward'==t)&&(a=new g.a({startPosition:e,direction:'backward'})),('both'==t||'forward'==t)&&(n=new g.a({startPosition:e}));for(const i of o(a,n)){const e=i.walker==a?'elementEnd':'elementStart',t=i.value;if(t.type==e&&this.schema.objects.has(t.item.name))return s.a.createOn(t.item);if(this.schema.check({name:'$text',inside:t.nextPosition}))return new s.a(t.nextPosition)}return null}transformDeltas(e,t,a=!1){return h.a.transformDeltaSets(e,t,a?this:null)}toJSON(){const e=Object(b.a)(this);return e.selection='[engine.model.DocumentSelection]',e}_getDefaultRoot(){for(const e of this.roots.values())if(e!==this.graveyard)return e;return this.graveyard}_getDefaultRange(){const e=this._getDefaultRoot(),t=new l.a(e,[0]),a=this.getNearestSelectionRange(t);return a||new s.a(t)}_validateSelectionRange(e){return n(e.start)&&n(e.end)}}t.a=x,Object(y.a)(x,_.c)},function(e,t,a){'use strict';var n=a(129),o=a(133),i=a(101),r=a(100),s=a(99),l=a(134),d=a(102),c=a(103),m=a(181),u=a(104)},function(e,t,a){'use strict';var n=a(95),o=a(48),i=a(130),r=a(29),s=a(72),l=a(40),d=a(98),c=a(41),m=a(131),u=a(132);const p={};p[n.a.className]=n.a,p[o.a.className]=o.a,p[i.a.className]=i.a,p[r.a.className]=r.a,p[s.a.className]=s.a,p[l.a.className]=l.a,p[d.a.className]=d.a,p[c.a.className]=c.a,p[m.a.className]=m.a,p[u.a.className]=u.a;t.a=class{static fromJSON(e,t){return p[e.__className].fromJSON(e,t)}}},function(e,t,a){'use strict';var n=a(96);t.a=function(e,t){return Object(n.a)(e,t)}},function(e,t,a){'use strict';var n=a(122),o=a(180),i=a(366),r=a(367),s=a(124),l=a(15),d=a(78),c=a(368),m='[object Arguments]',u='[object Array]',p='[object Object]',g=Object.prototype,f=g.hasOwnProperty;t.a=function(e,t,a,g,h,b){var _=Object(l.a)(e),k=Object(l.a)(t),y=u,w=u;_||(y=Object(s.a)(e),y=y==m?p:y),k||(w=Object(s.a)(t),w=w==m?p:w);var v=y==p&&!Object(d.a)(e),x=w==p&&!Object(d.a)(t),A=y==w;if(A&&!v)return b||(b=new n.a),_||Object(c.a)(e)?Object(o.a)(e,t,a,g,h,b):Object(i.a)(e,t,y,a,g,h,b);if(!(h&2)){var C=v&&f.call(e,'__wrapped__'),T=x&&f.call(t,'__wrapped__');if(C||T){var P=C?e.value():e,E=T?t.value():t;return b||(b=new n.a),a(P,E,g,h,b)}}return!!A&&(b||(b=new n.a),Object(r.a)(e,t,a,g,h,b))}},function(e,t){'use strict';t.a=function(e){return this.__data__.set(e,'__lodash_hash_undefined__'),this}},function(e,t){'use strict';t.a=function(e){return this.__data__.has(e)}},function(e,t){'use strict';t.a=function(e,t){for(var a=-1,n=e.length;++a<n;)if(t(e[a],a,e))return!0;return!1}},function(e,t,a){'use strict';var n=a(127),o=a(173),i=a(180),r=a(126),s=a(90),l=n.a?n.a.prototype:void 0,d=l?l.valueOf:void 0;t.a=function(e,t,a,n,l,c,m){switch(a){case'[object DataView]':if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case'[object ArrayBuffer]':return e.byteLength==t.byteLength&&n(new o.a(e),new o.a(t));case'[object Boolean]':case'[object Date]':return+e==+t;case'[object Error]':return e.name==t.name&&e.message==t.message;case'[object Number]':return e==+e?e==+t:t!=+t;case'[object RegExp]':case'[object String]':return e==t+'';case'[object Map]':var u=r.a;case'[object Set]':var p=c&2;if(u||(u=s.a),e.size!=t.size&&!p)return!1;var g=m.get(e);return g?g==t:(c|=1,m.set(e,t),Object(i.a)(u(e),u(t),n,l,c,m));case'[object Symbol]':if(d)return d.call(e)==d.call(t);}return!1}},function(e,t,a){'use strict';var n=a(169),o=a(70);t.a=function(e,t,a,i,r,s){var l=r&2,d=Object(o.a)(e),c=d.length,m=Object(o.a)(t),u=m.length;if(c!=u&&!l)return!1;for(var p=c,g;p--;)if(g=d[p],l?!(g in t):!Object(n.a)(t,g))return!1;var f=s.get(e);if(f)return f==t;var h=!0;s.set(e,t);for(var b=l;++p<c;){g=d[p];var _=e[g],k=t[g];if(i)var y=l?i(k,_,g,t,e,s):i(_,k,g,e,t,s);if(void 0===y?!(_===k||a(_,k,i,r,s)):!y){h=!1;break}b||(b='constructor'==g)}if(h&&!b){var w=e.constructor,v=t.constructor;w!=v&&'constructor'in e&&'constructor'in t&&!('function'==typeof w&&w instanceof w&&'function'==typeof v&&v instanceof v)&&(h=!1)}return s['delete'](e),h}},function(e,t,a){'use strict';var n=a(81),o=a(44),i={};i['[object Float32Array]']=i['[object Float64Array]']=i['[object Int8Array]']=i['[object Int16Array]']=i['[object Int32Array]']=i['[object Uint8Array]']=i['[object Uint8ClampedArray]']=i['[object Uint16Array]']=i['[object Uint32Array]']=!0,i['[object Arguments]']=i['[object Array]']=i['[object ArrayBuffer]']=i['[object Boolean]']=i['[object DataView]']=i['[object Date]']=i['[object Error]']=i['[object Function]']=i['[object Map]']=i['[object Number]']=i['[object Object]']=i['[object RegExp]']=i['[object Set]']=i['[object String]']=i['[object WeakMap]']=!1;var r=Object.prototype,s=r.toString;t.a=function(e){return Object(o.a)(e)&&Object(n.a)(e.length)&&!!i[s.call(e)]}},function(e,t,a){'use strict';function n(e,t){const a=e.clone(),n=a.operations[0];return n.oldRange&&(n.oldRange=n.oldRange.getTransformedByDelta(t)[0]),n.newRange&&(n.newRange=n.newRange.getTransformedByDelta(t)[0]),[a]}function o(e,t){function a(){const a=new s.a(e.position.getShiftedBy(l),e.position.getShiftedBy(d)),o=new c.a(a,t.key,r,t.value,0);n.addOperation(o)}const n=new g.a,o=e.nodes;let r=o.getNode(0).getAttribute(t.key),l=0,d=o.getNode(0).offsetSize;for(let n=1;n<o.length;n++){const e=o.getNode(n),i=e.getAttribute(t.key);i!=r&&(r!=t.value&&a(),r=i,l=d),d+=e.offsetSize}return a(),n}function i(){const e=new p.a;return e.addOperation(new d.a(0)),e}var r=a(182),s=a(3),l=a(1),d=a(72),c=a(95),m=a(48),u=a(98),p=a(24),g=a(129),f=a(133),h=a(402),b=a(101),_=a(100),k=a(102),y=a(181),w=a(104),v=a(103),x=a(134),A=a(99),C=a(55);const T=r.a.addTransformationCase,P=r.a.defaultTransform;T(g.a,y.a,(e,t,a)=>{const n=P(e,t,a);return e.range.containsPosition(t.position)&&n.push(o(t,e)),n}),T(g.a,k.a,(e,t,a)=>{if(!t.position)return P(e,t,a);const n=a.undoMode,o=new l.a(t.position.root,t.position.path.slice(0,-1)),i=P(e,t,a);if(n||!(t._cloneOperation instanceof m.a))return i;for(const n of e.operations)if(n.range.containsPosition(o)||n.range.start.isEqual(o)){const e=new g.a,a=o.getShiftedBy(1),r=l.a.createFromPosition(a);r.path.push(0);const d=t._cloneOperation.nodes.getNode(0).getAttribute(n.key);e.addOperation(new c.a(new s.a(a,r),n.key,d===void 0?null:d,n.newValue,0)),i.push(e);break}return i}),T(f.a,b.a,(e,t,a)=>{if(!t.position)return P(e,t,a);const n=a.undoMode;return!n&&e.position.isEqual(t.position)?[t.getReversed(),e.clone()]:P(e,t,a)}),T(h.a,k.a,n),T(h.a,b.a,n),T(h.a,w.a,n),T(h.a,v.a,n),T(h.a,_.a,n),T(h.a,x.a,n),T(_.a,b.a,(e,t,a)=>{const n=a.undoMode;if(n||!t.position)return P(e,t,a);const o=e.sourcePosition.root==t.position.root&&'same'===Object(C.a)(e.sourcePosition.getParentPath(),t.position.getParentPath()),i=e.sourcePosition.offset<=t.position.offset&&e.sourcePosition.offset+e.howMany>t.position.offset;return o&&i?[t.getReversed(),e.clone()]:P(e,t,a)}),T(b.a,f.a,(e,t,a)=>{if(!e.position)return P(e,t,a);const n=a.undoMode;return!n&&e.position.isEqual(t.position)?[i()]:P(e,t,a)}),T(b.a,_.a,(e,t,a)=>{const n=a.undoMode;if(n||!e.position)return P(e,t,a);const o=e.position.root==t.sourcePosition.root&&'same'===Object(C.a)(e.position.getParentPath(),t.sourcePosition.getParentPath()),r=t.sourcePosition.offset<=e.position.offset&&t.sourcePosition.offset+t.howMany>e.position.offset;return o&&r?[i()]:P(e,t,a)}),T(k.a,k.a,(e,t,a)=>{const n=a.undoMode;if(n)return P(e,t,a);if(!e.position||!t.position)return P(e,t,a);const o=e.position.getParentPath(),i=t.position.getParentPath();if(e.position.root==t.position.root&&'same'==Object(C.a)(o,i))if(e=e.clone(),e.position.offset<t.position.offset||e.position.offset==t.position.offset&&a.isStrong){e._cloneOperation instanceof u.a&&t._cloneOperation instanceof u.a&&e._cloneOperation.sourcePosition.offset>t._cloneOperation.sourcePosition.offset&&e._cloneOperation.sourcePosition.offset--;const a=s.a.createFromPositionAndShift(e.position,e._moveOperation.howMany),n=s.a.createFromPositionAndShift(t.position,t._moveOperation.howMany),o=a.getDifference(n);let i=0;for(const e of o)i+=e.end.offset-e.start.offset;return 0==i?(e.operations.pop(),e.addOperation(new d.a(e.operations[0].baseVersion+1))):e.operations[1].howMany=i,[e]}else{const n=Object.assign({},a);return n.isStrong=!0,n.insertBefore=!0,P(e,t,n)}return P(e,t,a)}),T(k.a,v.a,(e,t,a)=>e.position?e.position.root==t.position.root&&'same'===Object(C.a)(t.position.path,e.position.getParentPath())?[i()]:P(e,t,a):P(e,t,a)),T(k.a,w.a,(e,t,a)=>{if(!e.position)return P(e,t,a);const n=e.position.root==t.range.start.root,o=n&&'same'===Object(C.a)(e.position.getParentPath(),t.range.start.getParentPath()),r=t.range.start.offset<e.position.offset&&t.range.end.offset>=e.position.offset;if(o&&r)return[i()];if(n&&'same'===Object(C.a)(e.position.getParentPath(),t.range.end.getShiftedBy(-1).path)){const a=e.clone(),n=l.a.createFromPosition(t.range.start);n.path.push(t.howMany-1);const o=n.getShiftedBy(1);a._cloneOperation.position=o;const i=l.a.createFromPosition(n);i.path.push(e.position.offset),a._moveOperation.sourcePosition=i;const r=l.a.createFromPosition(o);return r.path.push(0),a._moveOperation.targetPosition=r,[a]}return P(e,t,a)}),T(k.a,g.a,(e,t,a)=>{if(!e.position)return P(e,t,a);e=e.clone();const n=a.undoMode,o=new l.a(e.position.root,e.position.path.slice(0,-1));if(n||!(e._cloneOperation instanceof m.a))return[e];for(const n of t.operations)if(n.range.containsPosition(o)||n.range.start.isEqual(o)){null===n.newValue?e._cloneOperation.nodes.getNode(0).removeAttribute(n.key):e._cloneOperation.nodes.getNode(0).setAttribute(n.key,n.newValue);break}return[e]}),T(v.a,k.a,(e,t,a)=>t.position?e.position.root==t.position.root&&'same'===Object(C.a)(e.position.path,t.position.getParentPath())?[t.getReversed(),e.clone()]:P(e,t,a):P(e,t,a)),T(y.a,g.a,(e,t)=>{const a=[e.clone()];return t.range.containsPosition(e.position)&&a.push(o(e,t)),a}),T(w.a,k.a,(e,t,a)=>{if(!t.position)return P(e,t,a);const n=e.range.start.root==t.position.root,o=n&&'same'===Object(C.a)(e.range.start.getParentPath(),t.position.getParentPath()),i=e.range.start.offset<t.position.offset&&e.range.end.offset>=t.position.offset;if(o&&i)return[t.getReversed(),e.clone()];if(n&&'same'===Object(C.a)(t.position.getParentPath(),e.range.end.getShiftedBy(-1).path)){const t=e.clone();return t._insertOperation.position.offset++,t._moveOperation.howMany++,t._moveOperation.targetPosition.path[t._moveOperation.targetPosition.path.length-2]++,[t]}return P(e,t,a)}),T(x.a,k.a,(e,t,a)=>{const n=a.undoMode,o=P(e,t,a);if(n||!(t._cloneOperation instanceof m.a))return o;const i=t._cloneOperation.position.getShiftedBy(-1);if(i&&e.operations[0].position.isEqual(i)){const t=e.clone();t.operations[0].position=i.getShiftedBy(1),o.push(t)}return o}),T(k.a,x.a,(e,t,a)=>{e=e.clone();const n=a.undoMode;if(n||!(e._cloneOperation instanceof m.a))return[e];const o=e._cloneOperation.position.getShiftedBy(-1);if(o&&!n&&t.operations[0].position.isEqual(o)){const a=t.clone();return a.operations[0].position=o.getShiftedBy(1),a.operations[0].oldName=e._cloneOperation.nodes.getNode(0).name,[e,a]}return[e]}),T(A.a,k.a,(e,t,a)=>{const n=P(e,t,a),o=t._cloneOperation.position||t._cloneOperation.targetPosition;if(!o)return P(e,t,a);const i=a.undoMode;if(i)return n;for(const i of n)if(i instanceof A.a){const e=i._moveOperation,t=e.sourcePosition.getShiftedBy(e.howMany);t.isEqual(o)&&(e.howMany+=1)}return n}),T(k.a,A.a,(e,t,a)=>{const n=a.undoMode;if(n)return P(e,t,a);const o=e._cloneOperation.position||e._cloneOperation.targetPosition;if(!o)return P(e,t,a);t=t.clone();const i=t._moveOperation,r=i.sourcePosition.getShiftedBy(i.howMany);return r.isEqual(o)&&(i.howMany+=1),P(e,t,a)})},function(e,t,a){'use strict';function n(e){return[e.clone()]}function o(e,t){for(let a=0;a<t.length;a++)t[a].baseVersion=e+a+1;return t}function i(e,t){return null===e.targetPosition._getTransformedByDeletion(t.sourcePosition,t.howMany)}function r(e){return 0===e.length?null:1==e.length?e[0]:(e[0].end=e[e.length-1].end,e[0])}function s(e,t,n){const a=[];for(let o=0;o<e.length;o++){const i=l(e[o],t,n.isSticky);a.push(i);for(let t=o+1;t<e.length;t++)e[t]=e[t]._getTransformedByMove(i.sourcePosition,i.targetPosition,i.howMany)[0];t=t._getTransformedByMove(i.sourcePosition,i.targetPosition,i.howMany,!0,!1)}return a}function l(e,t,a){let n='$graveyard'==t.root.rootName?f.a:'$graveyard'==e.start.root.rootName?h.a:g.a;const o=new n(e.start,e.end.offset-e.start.offset,t,0);return o.isSticky=a,o}var d=a(48),c=a(95),m=a(132),u=a(131),p=a(130),g=a(29),f=a(41),h=a(98),_=a(72),k=a(3),y=a(55);t.a=function(e,t,a={isStrong:!1}){let i,r;e instanceof d.a?i=w.InsertOperation:e instanceof c.a?i=w.AttributeOperation:e instanceof m.a?i=w.RootAttributeOperation:e instanceof u.a?i=w.RenameOperation:e instanceof p.a?i=w.MarkerOperation:e instanceof g.a?i=w.MoveOperation:r=n,i&&(t instanceof d.a?r=i.InsertOperation:t instanceof c.a?r=i.AttributeOperation:t instanceof m.a?r=i.RootAttributeOperation:t instanceof u.a?r=i.RenameOperation:t instanceof p.a?r=i.MarkerOperation:t instanceof g.a?r=i.MoveOperation:r=n);const s=r(e,t,a);return o(e.baseVersion,s)};const w={InsertOperation:{InsertOperation(e,t,a){const n=e.clone(),o=void 0===a.insertBefore?!a.isStrong:a.insertBefore;return n.position=n.position._getTransformedByInsertion(t.position,t.nodes.maxOffset,o),[n]},AttributeOperation:n,RootAttributeOperation:n,RenameOperation:n,MarkerOperation:n,MoveOperation(e,t,a){const n=e.clone(),o=void 0===a.insertBefore?!a.isStrong:a.insertBefore;return n.position=e.position._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,o,t.isSticky&&!a.forceNotSticky),[n]}},AttributeOperation:{InsertOperation(e,t){const a=e.range._getTransformedByInsertion(t.position,t.nodes.maxOffset,!0,!1);return a.reverse().map((t)=>new c.a(t,e.key,e.oldValue,e.newValue,e.baseVersion))},AttributeOperation(e,t,a){if(e.key===t.key){const n=e.range.getDifference(t.range).map((t)=>new c.a(t,e.key,e.oldValue,e.newValue,e.baseVersion)),o=e.range.getIntersection(t.range);return o&&(a.isStrong?n.push(new c.a(o,t.key,t.newValue,e.newValue,e.baseVersion)):0===n.length&&n.push(new _.a(0))),n}return[e.clone()]},RootAttributeOperation:n,RenameOperation:n,MarkerOperation:n,MoveOperation(e,t){const a=k.a.createFromPositionAndShift(t.sourcePosition,t.howMany);let n=[];const o=r(e.range.getDifference(a)),i=e.range.getIntersection(a);return null!==o&&(o.start=o.start._getTransformedByDeletion(t.sourcePosition,t.howMany),o.end=o.end._getTransformedByDeletion(t.sourcePosition,t.howMany),n=o._getTransformedByInsertion(t.getMovedRangeStart(),t.howMany,!0,!1).reverse()),null!==i&&(i.start=i.start._getCombined(t.sourcePosition,t.getMovedRangeStart()),i.end=i.end._getCombined(t.sourcePosition,t.getMovedRangeStart()),n.push(i)),n.map((t)=>new c.a(t,e.key,e.oldValue,e.newValue,e.baseVersion))}},RootAttributeOperation:{InsertOperation:n,AttributeOperation:n,RootAttributeOperation(e,t,a){return e.root!==t.root||e.key!==t.key||(e.newValue===t.newValue||a.isStrong)&&e.newValue!==t.newValue?[e.clone()]:[new _.a(e.baseVersion)]},RenameOperation:n,MarkerOperation:n,MoveOperation:n},RenameOperation:{InsertOperation(e,t){const a=e.clone();return a.position=a.position._getTransformedByInsertion(t.position,t.nodes.maxOffset,!0),[a]},AttributeOperation:n,RootAttributeOperation:n,RenameOperation(e,t,a){const n=e.clone();if(e.position.isEqual(t.position))if(a.isStrong)n.oldName=t.newName;else return[new _.a(e.baseVersion)];return[n]},MarkerOperation:n,MoveOperation(e,t){const a=e.clone(),n=a.position.isEqual(t.sourcePosition);return a.position=a.position._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,!0,n),[a]}},MarkerOperation:{InsertOperation(e,t){const a=e.clone();return a.oldRange&&(a.oldRange=a.oldRange._getTransformedByInsertion(t.position,t.nodes.maxOffset,!1,!1)[0]),a.newRange&&(a.newRange=a.newRange._getTransformedByInsertion(t.position,t.nodes.maxOffset,!1,!1)[0]),[a]},AttributeOperation:n,RootAttributeOperation:n,RenameOperation:n,MarkerOperation(e,t,a){const n=e.clone();if(e.name==t.name)if(a.isStrong)n.oldRange=t.newRange;else return[new _.a(e.baseVersion)];return[n]},MoveOperation(e,t){const a=e.clone();if(a.oldRange){const e=a.oldRange._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany);a.oldRange=k.a.createFromRanges(e)}if(a.newRange){const e=a.newRange._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany);a.newRange=k.a.createFromRanges(e)}return[a]}},MoveOperation:{InsertOperation(e,t,a){let n=k.a.createFromPositionAndShift(e.sourcePosition,e.howMany);n=n._getTransformedByInsertion(t.position,t.nodes.maxOffset,!1,e.isSticky&&!a.forceNotSticky)[0];const o=void 0===a.insertBefore?!a.isStrong:a.insertBefore,i=new e.constructor(n.start,n.end.offset-n.start.offset,e.targetPosition._getTransformedByInsertion(t.position,t.nodes.maxOffset,o),e.baseVersion);return i.isSticky=e.isSticky,[i]},AttributeOperation:n,RootAttributeOperation:n,RenameOperation:n,MarkerOperation:n,MoveOperation(e,t,a){const n=k.a.createFromPositionAndShift(e.sourcePosition,e.howMany),o=k.a.createFromPositionAndShift(t.sourcePosition,t.howMany);let r=a.isStrong;const l=e.isSticky&&!a.forceNotSticky,d=void 0===a.insertBefore?!r:a.insertBefore,c=e.targetPosition._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,d,t.isSticky&&!a.forceNotSticky);if(i(e,t)&&i(t,e))return[t.getReversed()];const m=n.containsPosition(t.targetPosition)||n.start.isEqual(t.targetPosition)&&l||n.end.isEqual(t.targetPosition)&&l;if(m&&n.containsRange(o,!0))return n.start=n.start._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,!l),n.end=n.end._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,l),s([n],c,e);const u=o.containsPosition(e.targetPosition)||o.start.isEqual(e.targetPosition)&&t.isSticky&&!a.forceNotSticky||o.end.isEqual(e.targetPosition)&&t.isSticky&&!a.forceNotSticky;if(u&&o.containsRange(n,!0))return n.start=n.start._getCombined(t.sourcePosition,t.getMovedRangeStart()),n.end=n.end._getCombined(t.sourcePosition,t.getMovedRangeStart()),s([n],c,e);const p=Object(y.a)(e.sourcePosition.getParentPath(),t.sourcePosition.getParentPath());if('prefix'==p||'extension'==p)return n.start=n.start._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,!l),n.end=n.end._getTransformedByMove(t.sourcePosition,t.targetPosition,t.howMany,l),s([n],c,e);a.forceWeakRemove||(e instanceof f.a&&!(t instanceof f.a)?r=!0:!(e instanceof f.a)&&t instanceof f.a&&(r=!1));const g=[],h=n.getDifference(o);for(const n of h){n.start=n.start._getTransformedByDeletion(t.sourcePosition,t.howMany),n.end=n.end._getTransformedByDeletion(t.sourcePosition,t.howMany);const e='same'==Object(y.a)(n.start.getParentPath(),t.getMovedRangeStart().getParentPath()),a=n._getTransformedByInsertion(t.getMovedRangeStart(),t.howMany,e,l);g.push(...a)}const b=n.getIntersection(o);return null!==b&&r&&!m&&(b.start=b.start._getCombined(t.sourcePosition,t.getMovedRangeStart()),b.end=b.end._getCombined(t.sourcePosition,t.getMovedRangeStart()),0===g.length?g.push(b):1==g.length?o.start.isBefore(n.start)||o.start.isEqual(n.start)?g.unshift(b):g.push(b):g.splice(1,0,b)),0===g.length?[new _.a(e.baseVersion)]:s(g,c,e)}}}},function(e,t,a){'use strict';var n=a(183),o=a(184),i=a(185),r=a(186),s=a(188),l=a(193),d=a(141),c=a(142),m=a(194),u=a(195),p=a(196),g=a(197),f=a(199),h=a(200),b=a(201),_=a(202),k=a(203),y=a(204),w=a(143),v=a(205),x=a(206),A=a(207),C=a(208),T=a(209),P=a(210),E=a(18),S=a(211),O=a(212),V=a(213),R=a(146),F=a(214),I=a(215),N=a(216),B=a(218),M=a(219),D=a(220),L=a(221),j=a(222),z=a(223),q=a(224),H=a(225),W=a(226),$=a(227),U=a(229),K=a(230),Q=a(231),J=a(232),Y=a(233),G=a(234),X=a(235),Z=a(236),ee=a(237),te=a(238),ae=a(239),ne=a(240),oe=a(108),ie=a(149),re=a(241),se=a(242),le=a(243),de=a(244),ce=a(245),me=a(246),ue=a(248),pe=a(249),ge=a(401);a.d(t,'a',function(){return ge.a})},function(e,t,a){'use strict';var n=a(119),o=a(15);t.a=function(e){return Object(o.a)(e)||Object(n.a)(e)}},function(e,t,a){'use strict';var n=a(374),o=a(375),i=a(190);t.a=function(e){var t=Object(o.a)(e);return 1==t.length&&t[0][2]?Object(i.a)(t[0][0],t[0][1]):function(a){return a===e||Object(n.a)(a,e,t)}}},function(e,t,a){'use strict';var n=a(122),o=a(96);t.a=function(e,t,a,i){var r=a.length,s=r,l=!i;if(null==e)return!s;for(e=Object(e);r--;){var d=a[r];if(l&&d[2]?d[1]!==e[d[0]]:!(d[0]in e))return!1}for(;++r<s;){d=a[r];var c=d[0],m=e[c],u=d[1];if(!(l&&d[2])){var p=new n.a;if(i)var g=i(m,u,c,e,t,p);if(void 0===g?!Object(o.a)(u,m,i,1|2,p):!g)return!1}else if(void 0===m&&!(c in e))return!1}return!0}},function(e,t,a){'use strict';var n=a(189),o=a(376);t.a=function(e){for(var t=Object(o.a)(e),a=t.length;a--;)t[a][2]=Object(n.a)(t[a][1]);return t}},function(e,t,a){'use strict';var n=a(377),o=a(70),i=Object(n.a)(o.a);t.a=i},function(e,t,a){'use strict';var n=a(378),o=a(124),i=a(126),r=a(379);t.a=function(e){return function(t){var a=Object(o.a)(t);return a=='[object Map]'?Object(i.a)(t):a=='[object Set]'?Object(r.a)(t):Object(n.a)(t,e(t))}}},function(e,t,a){'use strict';var n=a(30);t.a=function(e,t){return Object(n.a)(t,function(t){return[t,e[t]]})}},function(e,t){'use strict';t.a=function(e){var t=-1,a=Array(e.size);return e.forEach(function(e){a[++t]=[e,e]}),a}},function(e,t,a){'use strict';var n=a(96),o=a(191),i=a(385),r=a(57),s=a(189),l=a(190),d=a(58);t.a=function(e,t){return Object(r.a)(e)&&Object(s.a)(t)?Object(l.a)(Object(d.a)(e),t):function(a){var r=Object(o.a)(a,e);return r===void 0&&r===t?Object(i.a)(a,e):Object(n.a)(t,r,void 0,1|2)}}},function(e,t,a){'use strict';var n=a(382),o=a(383),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g,r=/\\(\\)?/g,s=Object(n.a)(function(e){var t=[];return Object(o.a)(e).replace(i,function(e,a,n,o){t.push(n?o.replace(r,'$1'):a||e)}),t});t.a=s},function(e,t,a){'use strict';function n(e,t){if('function'!=typeof e||t&&'function'!=typeof t)throw new TypeError(i);var a=function(){var n=arguments,o=t?t.apply(this,n):n[0],i=a.cache;if(i.has(o))return i.get(o);var r=e.apply(this,n);return a.cache=i.set(o,r),r};return a.cache=new(n.Cache||o.a),a}var o=a(123),i='Expected a function';n.Cache=o.a,t.a=n},function(e,t,a){'use strict';var n=a(384);t.a=function(e){return null==e?'':Object(n.a)(e)}},function(e,t,a){'use strict';var n=a(127),o=a(46),i=n.a?n.a.prototype:void 0,r=i?i.toString:void 0;t.a=function(e){if('string'==typeof e)return e;if(Object(o.a)(e))return r?r.call(e):'';var t=e+'';return'0'==t&&1/e==-(1/0)?'-0':t}},function(e,t,a){'use strict';var n=a(386),o=a(387);t.a=function(e,t){return null!=e&&Object(o.a)(e,t,n.a)}},function(e,t){'use strict';t.a=function(e,t){return t in Object(e)}},function(e,t,a){'use strict';var n=a(105),o=a(119),i=a(15),r=a(37),s=a(57),l=a(81),d=a(120),c=a(58);t.a=function(e,t,a){t=Object(s.a)(t,e)?[t]:Object(n.a)(t);for(var m=-1,u=t.length,p;++m<u;){var g=Object(c.a)(t[m]);if(!(p=null!=e&&a(e,g)))break;e=e[g]}if(p)return p;var u=e?e.length:0;return!!u&&Object(l.a)(u)&&Object(r.a)(g,u)&&(Object(i.a)(e)||Object(d.a)(e)||Object(o.a)(e))}},function(e,t,a){'use strict';var n=a(118),o=a(389),i=a(57),r=a(58);t.a=function(e){return Object(i.a)(e)?Object(n.a)(Object(r.a)(e)):Object(o.a)(e)}},function(e,t,a){'use strict';var n=a(140);t.a=function(e){return function(t){return Object(n.a)(t,e)}}},function(e,t,a){'use strict';var n=a(13),o=a(391);t.a=function(e,t,a,i){var r=e.length;for(a=Object(n.a)(a),0>a&&(a=-a>r?0:r+a),i=void 0===i||i>r?r:Object(n.a)(i),0>i&&(i+=r),i=a>i?0:Object(o.a)(i);a<i;)e[a++]=t;return e}},function(e,t,a){'use strict';var n=a(392),o=a(13);t.a=function(e){return e?Object(n.a)(Object(o.a)(e),0,4294967295):0}},function(e,t){'use strict';t.a=function(e,t,a){return e===e&&(void 0!==a&&(e=e<=a?e:a),void 0!==t&&(e=e>=t?e:t)),e}},function(e,t,a){'use strict';var o=a(37);t.a=function(e,t){var a=e.length;if(a)return t+=0>t?a:0,Object(o.a)(t,a)?e[t]:void 0}},function(e,t){'use strict';t.a=function(e,t,a,n){for(var o=a-1,i=e.length;++o<i;)if(n(e[o],t))return o;return-1}},function(e,t,a){'use strict';var n=a(191);t.a=function(e,t){for(var a=-1,o=t.length,i=Array(o);++a<o;)i[a]=null==e?void 0:Object(n.a)(e,t[a]);return i}},function(e,t,a){'use strict';var n=a(140),o=a(42);t.a=function(e,t){return 1==t.length?e:Object(n.a)(e,Object(o.a)(t,0,-1))}},function(e,t,a){'use strict';var n=a(46);t.a=function(e,t){if(e!==t){var a=e!==void 0,o=null===e,i=e===e,r=Object(n.a)(e),s=t!==void 0,l=null===t,d=t===t,c=Object(n.a)(t);if(!l&&!c&&!r&&e>t||r&&s&&d&&!l&&!c||o&&s&&d||!a&&d||!i)return 1;if(!o&&!r&&!c&&e<t||c&&a&&i&&!o&&!r||l&&a&&i||!s&&i||!d)return-1}return 0}},function(e,t,a){'use strict';var n=a(172),o=a(399),i=a(90),r=n.a&&1/Object(i.a)(new n.a([,-0]))[1]==1/0?function(e){return new n.a(e)}:o.a;t.a=r},function(e,t){'use strict';t.a=function(){}},function(e,t,a){'use strict';var n=a(64),o=a(105),i=a(37),r=a(57),s=a(17),l=a(58);t.a=function(e,t,a,d){t=Object(r.a)(t,e)?[t]:Object(o.a)(t);for(var c=-1,m=t.length,u=e;null!=u&&++c<m;){var p=Object(l.a)(t[c]);if(Object(s.a)(u)){var g=a;if(c!=m-1){var f=u[p];g=d?d(f,p,u):void 0,g===void 0&&(g=null==f?Object(i.a)(t[c+1])?[]:{}:f)}Object(n.a)(u,p,g)}u=u[p]}return e}},function(e,t,a){'use strict';var n=a(183),o=a(184),i=a(185),r=a(186),s=a(188),l=a(193),d=a(141),c=a(142),m=a(194),u=a(195),p=a(196),g=a(197),f=a(199),h=a(200),b=a(201),_=a(202),k=a(203),y=a(204),w=a(143),v=a(205),x=a(206),A=a(207),C=a(208),T=a(209),P=a(210),E=a(18),S=a(211),O=a(212),V=a(213),R=a(146),F=a(214),I=a(215),N=a(216),B=a(218),M=a(219),D=a(220),L=a(221),j=a(222),z=a(223),q=a(224),H=a(225),W=a(226),$=a(227),U=a(229),K=a(230),Q=a(231),J=a(232),Y=a(233),G=a(234),X=a(235),Z=a(236),ee=a(237),te=a(238),ae=a(239),ne=a(240),oe=a(108),ie=a(149),re=a(241),se=a(242),le=a(243),de=a(244),ce=a(245),me=a(246),ue=a(248),pe=a(249);t.a={chunk:n.a,compact:o.a,concat:i.a,difference:r.a,differenceBy:s.a,differenceWith:l.a,drop:d.a,dropRight:c.a,dropRightWhile:m.a,dropWhile:u.a,fill:p.a,findIndex:g.a,findLastIndex:f.a,first:h.a,flatten:b.a,flattenDeep:_.a,flattenDepth:k.a,fromPairs:y.a,head:w.a,indexOf:v.a,initial:x.a,intersection:A.a,intersectionBy:C.a,intersectionWith:T.a,join:P.a,last:E.a,lastIndexOf:S.a,nth:O.a,pull:V.a,pullAll:R.a,pullAllBy:F.a,pullAllWith:I.a,pullAt:N.a,remove:B.a,reverse:M.a,slice:D.a,sortedIndex:L.a,sortedIndexBy:j.a,sortedIndexOf:z.a,sortedLastIndex:q.a,sortedLastIndexBy:H.a,sortedLastIndexOf:W.a,sortedUniq:$.a,sortedUniqBy:U.a,tail:K.a,take:Q.a,takeRight:J.a,takeRightWhile:Y.a,takeWhile:G.a,union:X.a,unionBy:Z.a,unionWith:ee.a,uniq:te.a,uniqBy:ae.a,uniqWith:ne.a,unzip:oe.a,unzipWith:ie.a,without:re.a,xor:se.a,xorBy:le.a,xorWith:de.a,zip:ce.a,zipObject:me.a,zipObjectDeep:ue.a,zipWith:pe.a}},function(e,t,a){'use strict';function n(e,t,a,n){const o=e.document,i=new d,r=new s.a(t,a,n,o.markers,o.version);e.addDelta(i),i.addOperation(r),o.applyOperation(r)}var o=a(24),i=a(19),r=a(20),s=a(130),l=a(0);class d extends o.a{get type(){return'marker'}get _reverseDeltaClass(){return d}static get className(){return'engine.model.delta.MarkerDelta'}}t.a=d,Object(r.b)('setMarker',function(e,t){const a='string'==typeof e?e:e.name,o=this.document.markers.get(a);if(!t&&!o)throw new l.b('batch-setMarker-no-range: Range parameter is required when adding a new marker.');const i=o?o.getRange():null;return t?n(this,a,i,t):n(this,a,null,i),this}),Object(r.b)('removeMarker',function(e){const t='string'==typeof e?e:e.name;if(!this.document.markers.has(t))throw new l.b('batch-removeMarker-no-marker: Trying to remove marker which does not exist.');const a=this.document.markers.get(t).getRange();return n(this,t,a,null),this}),i.a.register(d)},function(e,t,a){'use strict';var n=a(5);class o extends n.a{constructor(e,t,a='main'){super(t),this._doc=e,this.rootName=a}get document(){return this._doc}is(e,t){return t?'rootElement'==e&&t==this.name||super.is(e,t):'rootElement'==e||super.is(e)}toJSON(){return this.rootName}}t.a=o},function(t,a,n){'use strict';var o=n(0);a.a=class{constructor(){this._deltas=[],this._historyPoints=new Map,this._undoPairs=new Map,this._undoneDeltas=new Set}addDelta(e){if(0<e.operations.length&&!this._historyPoints.has(e.baseVersion)){const t=this._deltas.length;this._deltas[t]=e,this._historyPoints.set(e.baseVersion,t)}}*getDeltas(t=0,a=e){if(0!==this._deltas.length){let e=this._getIndex(t);if(-1!=e)for(;e<this._deltas.length;){const t=this._deltas[e++];if(t.baseVersion>=a)break;yield t}}}getDelta(e){const t=this._historyPoints.get(e);return t===void 0?null:this._deltas[t]}setDeltaAsUndone(e,t){this._undoPairs.set(t,e),this._undoneDeltas.add(e)}isUndoingDelta(e){return this._undoPairs.has(e)}isUndoneDelta(e){return this._undoneDeltas.has(e)}getUndoneDelta(e){return this._undoPairs.get(e)}_getIndex(e){const t=this._historyPoints.get(e);if(t===void 0){const t=this._deltas[this._deltas.length-1],a=t.baseVersion+t.operations.length;if(0>e||e>=a)return-1;throw new o.b('model-history-wrong-version: Given base version points to the middle of a delta.')}return t}}},function(e,t){'use strict';t.a=function(e,t){if(e.size!=t.size)return!1;for(const a of e.entries()){const e=JSON.stringify(a[1]),n=JSON.stringify(t.get(a[0]));if(e!==n)return!1}return!0}},function(e,t,a){'use strict';function n(e,t,a){for(let n=a.length-1,o=t.length-1;0<=n&&0<=o;){const i=t[o];if(!e.hasItem(i))return!1;const r=e._extensionChains.get(i);if(r.includes(a[n]))n--,o--;else return!1}return!0}var o=a(1),i=a(5),r=a(3),s=a(250),l=a(69),d=a(15),c=a(120),m=a(0);class u{constructor(){this.objects=new Set,this.limits=new Set,this._items=new Map,this._extensionChains=new Map,this.registerItem('$root'),this.registerItem('$block'),this.registerItem('$inline'),this.registerItem('$text','$inline'),this.allow({name:'$block',inside:'$root'}),this.allow({name:'$inline',inside:'$block'}),this.limits.add('$root'),this.registerItem('$clipboardHolder','$root'),this.allow({name:'$inline',inside:'$clipboardHolder'})}allow(e){this._getItem(e.name).allow(u._normalizeQueryPath(e.inside),e.attributes)}disallow(e){this._getItem(e.name).disallow(u._normalizeQueryPath(e.inside),e.attributes)}requireAttributes(e,t){this._getItem(e).requireAttributes(t)}check(e){if(!this.hasItem(e.name))return!1;Object(d.a)(e.attributes)?0===e.attributes.length&&e.attributes.push(void 0):e.attributes=[e.attributes];const t=u._normalizeQueryPath(e.inside),a=this._extensionChains.get(e.name).map((e)=>this._getItem(e));if(!this._getItem(e.name)._checkRequiredAttributes(e.attributes))return!1;for(const n of e.attributes)for(const e of a)if(e._hasMatchingPath('disallow',t,n))return!1;for(const n of e.attributes){if(n&&s.a._isStoreAttributeKey(n))continue;let e=!1;for(const o of a)if(o._hasMatchingPath('allow',t,n)){e=!0;break}if(!e)return!1}return!0}hasItem(e){return this._items.has(e)}registerItem(e,t){if(this.hasItem(e))throw new m.b('model-schema-item-exists: Item with specified name already exists in schema.');if(!!t&&!this.hasItem(t))throw new m.b('model-schema-no-item: Item with specified name does not exist in schema.');this._items.set(e,new p(this));const a=this.hasItem(t)?this._extensionChains.get(t).concat(e):[e];this._extensionChains.set(e,a)}itemExtends(e,t){if(!this.hasItem(e)||!this.hasItem(t))throw new m.b('model-schema-no-item: Item with specified name does not exist in schema.');const a=this._extensionChains.get(e);return a.some((e)=>e==t)}checkAttributeInSelection(e,t){if(e.isCollapsed)return this.check({name:'$text',inside:e.getFirstPosition(),attributes:t});else{const a=e.getRanges();for(const e of a)for(const a of e){const e=a.item.name||'$text',n=Array.from(a.item.getAttributeKeys()).concat(t);if(this.check({name:e,inside:a.previousPosition,attributes:n}))return!0}}return!1}getValidRanges(e,t){const a=[];for(const n of e){let e=n.start,i=n.start;const s=n.end;for(const s of n.getWalker()){const n=s.item.name||'$text',l=o.a.createBefore(s.item);this.check({name:n,inside:l,attributes:t})||(!i.isEqual(e)&&a.push(new r.a(i,e)),i=s.nextPosition),e=s.nextPosition}i&&!i.isEqual(s)&&a.push(new r.a(i,s))}return a}getLimitElement(e){let t=Array.from(e.getRanges()).reduce((e,t)=>e?e.getCommonAncestor(t.getCommonAncestor()):t.getCommonAncestor(),null);for(;!this.limits.has(t.name)&&t.parent;)t=t.parent;return t}removeDisallowedAttributes(e,t,a){for(const n of e){const e=n.is('text')?'$text':n.name,o=Array.from(n.getAttributeKeys()),i=u._normalizeQueryPath(t);if(!this.check({name:e,attributes:o,inside:i}))for(const t of n.getAttributeKeys())this.check({name:e,attributes:t,inside:i})||(a?a.removeAttribute(n,t):n.removeAttribute(t));n.is('element')&&this.removeDisallowedAttributes(n.getChildren(),i.concat(n.name),a)}}_getItem(e){if(!this.hasItem(e))throw new m.b('model-schema-no-item: Item with specified name does not exist in schema.');return this._items.get(e)}static _normalizeQueryPath(e){let t=[];if(Object(d.a)(e))for(const a of e)a instanceof i.a?t.push(a.name):Object(c.a)(a)&&t.push(a);else if(e instanceof o.a){for(let a=e.parent;null!==a;)t.push(a.name),a=a.parent;t.reverse()}else Object(c.a)(e)&&(t=e.split(' '));return t}}t.a=u;class p{constructor(e){this._schema=e,this._allowed=[],this._disallowed=[],this._requiredAttributes=[]}allow(e,t){this._addPath('_allowed',e,t)}disallow(e,t){this._addPath('_disallowed',e,t)}requireAttributes(e){this._requiredAttributes.push(e)}toJSON(){const e=Object(l.a)(this);return e._schema='[model.Schema]',e}_addPath(e,t,a){t=t.slice(),Object(d.a)(a)||(a=[a]);for(const n of a)this[e].push({path:t,attribute:n})}_getPaths(e,t){const a='allow'===e?this._allowed:this._disallowed,n=[];for(const o of a)o.attribute===t&&n.push(o.path);return n}_checkRequiredAttributes(e){let t=!0;for(const a of this._requiredAttributes){t=!0;for(const n of a)if(-1==e.indexOf(n)){t=!1;break}if(t)break}return t}_hasMatchingPath(e,t,a){const o=this._getPaths(e,a);for(const i of o)if(n(this._schema,t,i))return!0;return!1}}},function(e,t,a){'use strict';var n=a(151),o=a(1),i=a(3),r=a(8),s=a(0),l=a(4);class d{constructor(){this._markers=new Map}[Symbol.iterator](){return this._markers.values()}has(e){return this._markers.has(e)}get(e){return this._markers.get(e)||null}set(e,t){const a=e instanceof c?e.name:e,o=this._markers.get(a);if(o){const e=o.getRange();if(e.isEqual(t))return o;this.remove(a)}const i=n.a.createFromRange(t),r=new c(a,i);return this._markers.set(a,r),this.fire('add:'+a,r),r}remove(e){const t=e instanceof c?e.name:e,a=this._markers.get(t);return!!a&&(this._markers.delete(t),this.fire('remove:'+t,a),this._destroyMarker(a),!0)}*getMarkersAtPosition(e){for(const t of this)t.getRange().containsPosition(e)&&(yield t)}destroy(){for(const e of this._markers.values())this._destroyMarker(e);this._markers=null,this.stopListening()}*getMarkersGroup(e){for(const t of this._markers.values())t.name.startsWith(e+':')&&(yield t)}_destroyMarker(e){e.stopListening(),e._liveRange.detach(),e._liveRange=null}}t.a=d,Object(l.a)(d,r.c);class c{constructor(e,t){this.name=e,this._liveRange=t,this._liveRange.delegate('change:range').to(this),this._liveRange.delegate('change:content').to(this)}getStart(){if(!this._liveRange)throw new s.b('marker-destroyed: Cannot use a destroyed marker instance.');return o.a.createFromPosition(this._liveRange.start)}getEnd(){if(!this._liveRange)throw new s.b('marker-destroyed: Cannot use a destroyed marker instance.');return o.a.createFromPosition(this._liveRange.end)}getRange(){if(!this._liveRange)throw new s.b('marker-destroyed: Cannot use a destroyed marker instance.');return i.a.createFromRange(this._liveRange)}}Object(l.a)(c,r.c)},function(e,t,a){'use strict';var n=a(50);class o extends n.a{constructor(e){super(),this.editor=e}set(e,t,a={}){if('string'==typeof t){const e=t;t=(t,a)=>{this.editor.execute(e),a()}}super.set(e,t,a)}}t.a=o},function(e,t,a){'use strict';var n=a(410),o=a(163),i=a(176),r=a(71),s=a(424),l=a(259),d=a(12),c=a(4);class m{constructor(e){this.model=e,this.view=new n.a,this.mapper=new o.a,this.modelToView=new i.a(this.model,{mapper:this.mapper,viewSelection:this.view.selection}),this.listenTo(this.model,'change',(e,t,a)=>{this.modelToView.convertChange(t,a)},{priority:'low'}),this.listenTo(this.model,'changesDone',()=>{const e=this.model.selection;this.modelToView.convertSelection(e),this.view.render()},{priority:'low'}),this.listenTo(this.model.markers,'add',(e,t)=>{this.modelToView.convertMarker('addMarker',t.name,t.getRange())}),this.listenTo(this.model.markers,'remove',(e,t)=>{this.modelToView.convertMarker('removeMarker',t.name,t.getRange())}),this.listenTo(this.view,'selectionChange',Object(s.a)(this.model,this.mapper)),this.modelToView.on('insert:$text',Object(r.f)(),{priority:'lowest'}),this.modelToView.on('remove',Object(r.h)(),{priority:'low'}),this.modelToView.on('selection',Object(l.a)(),{priority:'low'}),this.modelToView.on('selection',Object(l.b)(),{priority:'low'}),this.modelToView.on('selection',Object(l.d)(),{priority:'low'}),this.modelToView.on('selection',Object(l.c)(),{priority:'low'})}createRoot(e,t='main'){const a=this.view.createRoot(e,t),n=this.model.getRoot(t);return this.mapper.bindElements(n,a),a}destroy(){this.view.destroy(),this.stopListening()}}t.a=m,Object(c.a)(m,d.a)},function(e,t,a){'use strict';var n=a(111),o=a(411),i=a(153),r=a(253),s=a(74),l=a(94),d=a(16),c=a(254),m=a(417),u=a(419),p=a(420),g=a(421),f=a(4),h=a(12),b=a(422);class _{constructor(){this.domRoots=new Map,this.selection=new n.a,this.domConverter=new i.a,this.roots=new Map,this.set('isReadOnly',!1),this.set('isFocused',!1),this.renderer=new o.a(this.domConverter,this.selection),this.renderer.bind('isFocused').to(this),this._observers=new Map,this.addObserver(c.a),this.addObserver(m.a),this.addObserver(u.a),this.addObserver(p.a),this.addObserver(g.a),Object(s.f)(this),Object(l.b)(this),this.decorate('render')}addObserver(e){let t=this._observers.get(e);if(t)return t;t=new e(this),this._observers.set(e,t);for(const[a,n]of this.domRoots)t.observe(n,a);return t.enable(),t}getObserver(e){return this._observers.get(e)}createRoot(e,t='main'){const a='string'==typeof e?e:e.tagName,n=new r.a(a.toLowerCase(),t);return n.document=this,this.roots.set(t,n),n.on('change:children',(e,t)=>this.renderer.markToSync('children',t)),n.on('change:attributes',(e,t)=>this.renderer.markToSync('attributes',t)),n.on('change:text',(e,t)=>this.renderer.markToSync('text',t)),this.domConverter.isElement(e)&&this.attachDomRoot(e,t),n}attachDomRoot(e,t='main'){const a=this.getRoot(t);this.domRoots.set(t,e),this.domConverter.bindElements(e,a),this.renderer.markToSync('children',a),this.renderer.domDocuments.add(e.ownerDocument);for(const a of this._observers.values())a.observe(e,t)}getRoot(e='main'){return this.roots.get(e)}getDomRoot(e='main'){return this.domRoots.get(e)}render(){this.disableObservers(),this.renderer.render(),this.enableObservers()}focus(){if(!this.isFocused){const e=this.selection.editableElement;e?(this.domConverter.focus(e),this.render()):d.a.warn('view-focus-no-selection: There is no selection in any editable to focus.')}}scrollToTheSelection(){const e=this.selection.getFirstRange();e&&Object(b.a)({target:this.domConverter.viewRangeToDom(e),viewportOffset:20})}disableObservers(){for(const e of this._observers.values())e.disable()}enableObservers(){for(const e of this._observers.values())e.enable()}destroy(){for(const e of this._observers.values())e.destroy()}}t.a=_,Object(f.a)(_,h.a)},function(e,t,a){'use strict';var n=a(35),o=a(22),i=a(74),r=a(4),s=a(251),l=a(412),d=a(413),c=a(16),m=a(12),u=a(0);class p{constructor(e,t){this.domDocuments=new Set,this.domConverter=e,this.markedAttributes=new Set,this.markedChildren=new Set,this.markedTexts=new Set,this.selection=t,this._inlineFiller=null,this.isFocused=!1,this._fakeSelectionContainer=null}markToSync(e,t){if('text'===e)this.domConverter.mapViewToDom(t.parent)&&this.markedTexts.add(t);else{if(!this.domConverter.mapViewToDom(t))return;if('attributes'===e)this.markedAttributes.add(t);else if('children'===e)this.markedChildren.add(t);else throw new u.b('view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.')}}render(){let e;this._inlineFiller&&!this._isSelectionInInlineFiller()&&this._removeInlineFiller(),this._inlineFiller?e=this._getInlineFillerPosition():this._needsInlineFillerAtSelection()&&(e=this.selection.getFirstPosition(),this.markedChildren.add(e.parent));for(const t of this.markedTexts)!this.markedChildren.has(t.parent)&&this.domConverter.mapViewToDom(t.parent)&&this._updateText(t,{inlineFillerPosition:e});for(const e of this.markedAttributes)this._updateAttrs(e);for(const t of this.markedChildren)this._updateChildren(t,{inlineFillerPosition:e});if(e){const t=this.domConverter.viewPositionToDom(e),a=t.parent.ownerDocument;this._inlineFiller=Object(i.i)(t.parent)?t.parent:this._addInlineFiller(a,t.parent,t.offset)}else this._inlineFiller=null;this._updateSelection(),this._updateFocus(),this.markedTexts.clear(),this.markedAttributes.clear(),this.markedChildren.clear()}_addInlineFiller(e,t,a){const n=t instanceof Array?t:t.childNodes,o=n[a];if(this.domConverter.isText(o))return o.data=i.b+o.data,o;else{const o=e.createTextNode(i.b);return Array.isArray(t)?n.splice(a,0,o):Object(l.a)(t,a,o),o}}_getInlineFillerPosition(){const e=this.selection.getFirstPosition();return e.parent.is('text')?o.a.createBefore(this.selection.getFirstPosition().parent):e}_isSelectionInInlineFiller(){if(1!=this.selection.rangeCount||!this.selection.isCollapsed)return!1;const e=this.selection.getFirstPosition(),t=this.domConverter.viewPositionToDom(e);return t&&this.domConverter.isText(t.parent)&&Object(i.i)(t.parent)}_removeInlineFiller(){const e=this._inlineFiller;if(!Object(i.i)(e))throw new u.b('view-renderer-filler-was-lost: The inline filler node was lost.');Object(i.h)(e)?e.parentNode.removeChild(e):e.data=e.data.substr(i.c),this._inlineFiller=null}_needsInlineFillerAtSelection(){if(1!=this.selection.rangeCount||!this.selection.isCollapsed)return!1;const e=this.selection.getFirstPosition(),t=e.parent,a=e.offset;if(!this.domConverter.mapViewToDom(t.root))return!1;if(!t.is('element'))return!1;if(a===t.getFillerOffset())return!1;const o=e.nodeBefore,i=e.nodeAfter;return o instanceof n.a||i instanceof n.a?!1:!0}_updateText(e,t){const a=this.domConverter.findCorrespondingDomText(e),n=this.domConverter.viewToDom(e,a.ownerDocument),o=a.data;let r=n.data;const s=t.inlineFillerPosition;s&&s.parent==e.parent&&s.offset==e.index&&(r=i.b+r),o!=r&&(a.data=r)}_updateAttrs(e){const t=this.domConverter.mapViewToDom(e),a=Array.from(t.attributes).map((e)=>e.name),n=e.getAttributeKeys();for(const a of n)t.setAttribute(a,e.getAttribute(a));for(const n of a)e.hasAttribute(n)||t.removeAttribute(n)}_updateChildren(e,t){function a(e,t){if(e===t)return!0;return n.isText(e)&&n.isText(t)?e.data===t.data:Object(i.g)(e,n.blockFiller)&&Object(i.g)(t,n.blockFiller)}const n=this.domConverter,o=n.mapViewToDom(e);if(o){const r=o.ownerDocument,c=t.inlineFillerPosition,m=o.childNodes,u=Array.from(n.viewChildrenToDom(e,r,{bind:!0}));c&&c.parent==e&&this._addInlineFiller(r,u,c.offset);const p=Object(s.a)(m,u,a);let g=0;const i=new Set;for(const e of p)'insert'===e?(Object(l.a)(o,g,u[g]),g++):'delete'===e?(i.add(m[g]),Object(d.a)(m[g])):g++;for(const e of i)e.parentNode||this.domConverter.unbindDomElement(e)}}_updateSelection(){if(0===this.selection.rangeCount)return this._removeDomSelection(),void this._removeFakeSelection();const e=this.domConverter.mapViewToDom(this.selection.editableElement);this.isFocused&&e&&(this.selection.isFake?this._updateFakeSelection(e):(this._removeFakeSelection(),this._updateDomSelection(e)))}_updateFakeSelection(e){const t=e.ownerDocument;this._fakeSelectionContainer||(this._fakeSelectionContainer=t.createElement('div'),this._fakeSelectionContainer.style.position='fixed',this._fakeSelectionContainer.style.top=0,this._fakeSelectionContainer.style.left='-9999px',this._fakeSelectionContainer.appendChild(t.createTextNode('\xA0'))),this._fakeSelectionContainer.parentElement||e.appendChild(this._fakeSelectionContainer);const a=this.selection.fakeSelectionLabel||'\xA0';this._fakeSelectionContainer.firstChild.data=a;const n=t.getSelection();n.removeAllRanges();const o=t.createRange();o.selectNodeContents(this._fakeSelectionContainer),n.addRange(o),this.domConverter.bindFakeSelection(this._fakeSelectionContainer,this.selection)}_updateDomSelection(e){const t=e.ownerDocument.defaultView.getSelection();if(this._domSelectionNeedsUpdate(t)){const e=this.domConverter.viewPositionToDom(this.selection.anchor),a=this.domConverter.viewPositionToDom(this.selection.focus);t.collapse(e.parent,e.offset),t.extend(a.parent,a.offset)}}_domSelectionNeedsUpdate(e){if(!this.domConverter.isDomSelectionCorrect(e))return!0;const t=e&&this.domConverter.domSelectionToView(e);if(t&&this.selection.isEqual(t))return!1;if(!this.selection.isCollapsed&&this.selection.isSimilar(t)){const e={oldSelection:t,currentSelection:this.selection};return c.a.warn('renderer-skipped-selection-rendering: The selection was not rendered due to its similarity to the current one.',e),!1}return!0}_removeDomSelection(){for(const e of this.domDocuments){const t=e.getSelection();if(t.rangeCount){const t=e.activeElement,a=this.domConverter.mapDomToView(t);t&&a&&e.getSelection().removeAllRanges()}}}_removeFakeSelection(){const e=this._fakeSelectionContainer;e&&e.remove()}_updateFocus(){if(this.isFocused){const e=this.selection.editableElement;e&&this.domConverter.focus(e)}}}t.a=p,Object(r.a)(p,m.a)},function(e,t){'use strict';t.a=function(e,t,a){e.insertBefore(a,e.childNodes[t]||null)}},function(e,t){'use strict';t.a=function(e){const t=e.parentNode;t&&t.removeChild(e)}},function(e,t){'use strict';t.a=function(e){let t=0;for(;e.previousSibling;)e=e.previousSibling,t++;return t}},function(e,t,a){'use strict';t.a=function(e,t){const a=Object(n.a)(e),o=Object(n.a)(t);let r=0;for(;a[r]==o[r]&&a[r];)r++;return 0==r?null:a[r-1]};var n=a(252)},function(e,t,a){'use strict';var n=a(96);t.a=function(e,t,a){a='function'==typeof a?a:void 0;var o=a?a(e,t):void 0;return o===void 0?Object(n.a)(e,t,a):!!o}},function(e,t,a){'use strict';var n=a(61),o=a(254),i=a(16),r=a(255);class s extends n.a{constructor(e){super(e),this.mutationObserver=e.getObserver(o.a),this.document=e,this.selection=e.selection,this.domConverter=e.domConverter,this._documents=new WeakSet,this._fireSelectionChangeDoneDebounced=Object(r.a)((e)=>this.document.fire('selectionChangeDone',e),200),this._clearInfiniteLoopInterval=setInterval(()=>this._clearInfiniteLoop(),1e3),this._loopbackCounter=0}observe(e){const t=e.ownerDocument;this._documents.has(t)||(this.listenTo(t,'selectionchange',()=>{this._handleSelectionChange(t)}),this._documents.add(t))}destroy(){super.destroy(),clearInterval(this._clearInfiniteLoopInterval),this._fireSelectionChangeDoneDebounced.cancel()}_handleSelectionChange(e){if(this.isEnabled&&(this.document.isFocused||this.document.isReadOnly)){this.mutationObserver.flush();const t=e.defaultView.getSelection(),a=this.domConverter.domSelectionToView(t);if(!(this.selection.isEqual(a)&&this.domConverter.isDomSelectionCorrect(t))){if(60<++this._loopbackCounter)return void i.a.warn('selectionchange-infinite-loop: Selection change observer detected an infinite rendering loop.');if(this.selection.isSimilar(a))this.document.render();else{const e={oldSelection:this.selection,newSelection:a,domSelection:t};this.document.fire('selectionChange',e),this._fireSelectionChangeDoneDebounced(e)}}}}_clearInfiniteLoop(){this._loopbackCounter=0}}t.a=s},function(e,t){'use strict';var a=Date.now;t.a=a},function(e,t,a){'use strict';var n=a(75);class o extends n.a{constructor(e){super(e),this.domEventType=['focus','blur'],this.useCapture=!0,e.on('focus',()=>{e.isFocused=!0,this._renderTimeoutId=setTimeout(()=>e.render(),0)}),e.on('blur',(t,a)=>{const n=e.selection.editableElement;(null===n||n===a.target)&&(e.isFocused=!1,e.render())})}onDomEvent(e){this.fire(e.type,e)}destroy(){this._renderTimeoutId&&clearTimeout(this._renderTimeoutId),super.destroy()}}t.a=o},function(e,t,a){'use strict';var n=a(75),o=a(28);class i extends n.a{constructor(e){super(e),this.domEventType=['keydown','keyup']}onDomEvent(e){this.fire(e.type,e,{keyCode:e.keyCode,altKey:e.altKey,ctrlKey:e.ctrlKey||e.metaKey,shiftKey:e.shiftKey,get keystroke(){return Object(o.a)(this)}})}}t.a=i},function(e,t,a){'use strict';function n(e){return e==r.c.arrowright||e==r.c.arrowleft||e==r.c.arrowup||e==r.c.arrowdown}var o=a(61),i=a(111),r=a(28),s=a(255);class l extends o.a{constructor(e){super(e),this._fireSelectionChangeDoneDebounced=Object(s.a)((e)=>this.document.fire('selectionChangeDone',e),200)}observe(){const e=this.document;e.on('keydown',(t,a)=>{const o=e.selection;o.isFake&&n(a.keyCode)&&this.isEnabled&&(a.preventDefault(),this._handleSelectionMove(a.keyCode))},{priority:'lowest'})}destroy(){super.destroy(),this._fireSelectionChangeDoneDebounced.cancel()}_handleSelectionMove(e){const t=this.document.selection,a=i.a.createFromSelection(t);a.setFake(!1),(e==r.c.arrowleft||e==r.c.arrowup)&&a.collapseToStart(),(e==r.c.arrowright||e==r.c.arrowdown)&&a.collapseToEnd();const n={oldSelection:t,newSelection:a,domSelection:null};this.document.fire('selectionChange',n),this._fireSelectionChangeDoneDebounced(n)}}t.a=l},function(e,t,a){'use strict';function n({target:e,viewportOffset:t=0}){const a=c(e);for(let n=a,r=null;n;){let s;s=n==a?m(e):m(r),i(s,()=>u(e,n));const l=u(e,n);o(n,l,t),n.parent==n?n=null:(r=n.frameElement,n=n.parent)}}function o(e,t,a){const n=t.clone().moveBy(0,a),o=t.clone().moveBy(0,-a),i=new g.a(e).excludeScrollbarsAndBorders();if(![o,n].every((e)=>i.contains(e))){let{scrollX:c,scrollY:m}=e;s(o,i)?m-=i.top-t.top+a:r(n,i)&&(m+=t.bottom-i.bottom+a),l(t,i)?c-=i.left-t.left+a:d(t,i)&&(c+=t.right-i.right+a),e.scrollTo(c,m)}}function i(e,t){const a=c(e);for(let n,o;e!=a.document.body;)o=t(),n=new g.a(e).excludeScrollbarsAndBorders(),n.contains(o)||(s(o,n)?e.scrollTop-=n.top-o.top:r(o,n)&&(e.scrollTop+=o.bottom-n.bottom),l(o,n)?e.scrollLeft-=n.left-o.left:d(o,n)&&(e.scrollLeft+=o.right-n.right)),e=e.parentNode}function r(e,t){return e.bottom>t.bottom}function s(e,t){return e.top<t.top}function l(e,t){return e.left<t.left}function d(e,t){return e.right>t.right}function c(e){return Object(p.a)(e)?e.startContainer.ownerDocument.defaultView:e.ownerDocument.defaultView}function m(e){if(Object(p.a)(e)){let t=e.commonAncestorContainer;return t.nodeType==Node.TEXT_NODE&&(t=t.parentNode),t}return e.parentNode}function u(e,t){const a=c(e),n=new g.a(e);if(a===t)return n;for(let o=a;o!=t;){const e=o.frameElement,t=new g.a(e).excludeScrollbarsAndBorders();n.moveBy(t.left,t.top),o=o.parent}return n}t.a=n;var p=a(155),g=a(256);Object.assign({},{scrollViewportToShowTarget:n,scrollAncestorsToShowTarget:function(e){const t=m(e);i(t,()=>new g.a(e))}})},function(e,t){'use strict';t.a=function(e){return'[object Window]'==Object.prototype.toString.apply(e)}},function(e,t,a){'use strict';t.a=function(e,t){return(a,o)=>{const i=o.newSelection,r=new n.a,s=[];for(const e of i.getRanges())s.push(t.toModelRange(e));r.setRanges(s,i.isBackward),r.isEqual(e.selection)||e.enqueueChanges(()=>{e.selection.setTo(r)})}};var n=a(59)},function(e,t){'use strict';t.a=function(e){return e instanceof HTMLTextAreaElement?e.value:e.innerHTML}},function(e,t){'use strict';t.a=function(e,t){e instanceof HTMLTextAreaElement&&(e.value=t),e.innerHTML=t}},function(e,t){'use strict';t.a=class{getHtml(e){const t=document.implementation.createHTMLDocument(''),a=t.createElement('div');return a.appendChild(e),a.innerHTML}}},function(e,t,a){'use strict';var n=a(429),o=a(62),i=a(430),r=a(431);t.a=class{constructor(e,t){this.editor=e,this.view=t,this.componentFactory=new n.a(e),this.focusTracker=new o.a,this._toolbarConfig=Object(r.a)(e.config.get('toolbar')),t.set('width',e.config.get('ui.width')),t.set('height',e.config.get('ui.height')),t.stickyPanel.bind('isActive').to(this.focusTracker,'isFocused'),t.stickyPanel.limiterElement=t.element,this._toolbarConfig&&this._toolbarConfig.viewportTopOffset&&(t.stickyPanel.viewportTopOffset=this._toolbarConfig.viewportTopOffset);const a=e.editing.createRoot('div');t.editable.bind('isReadOnly').to(a),t.editable.bind('isFocused').to(e.editing.view),t.editable.name=a.rootName,this.focusTracker.add(t.editableElement)}init(){const e=this.editor;this.view.init(),this._toolbarConfig&&this.view.toolbar.fillFromConfig(this._toolbarConfig.items,this.componentFactory),Object(i.a)({origin:e.editing.view,originFocusTracker:this.focusTracker,originKeystrokeHandler:e.keystrokes,toolbar:this.view.toolbar})}destroy(){this.view.destroy()}}},function(e,t,a){'use strict';var n=a(0);t.a=class{constructor(e){this.editor=e,this._components=new Map}*names(){yield*this._components.keys()}add(e,t){if(this.has(e))throw new n.b('componentfactory-item-exists: The item already exists in the component factory.',{name:e});this._components.set(e,t)}create(e){if(!this.has(e))throw new n.b('componentfactory-item-missing: The required component is not registered in the factory.',{name:e});return this._components.get(e)(this.editor.locale)}has(e){return this._components.has(e)}}},function(e,t){'use strict';t.a=function({origin:e,originKeystrokeHandler:t,originFocusTracker:a,toolbar:n,beforeFocus:o,afterBlur:i}){a.add(n.element),t.set('Alt+F10',(e,t)=>{a.isFocused&&!n.focusTracker.isFocused&&(o&&o(),n.focus(),t())}),n.keystrokes.set('Esc',(t,a)=>{n.focusTracker.isFocused&&(e.focus(),i&&i(),a())})}},function(e,t){'use strict';t.a=function(e){return Array.isArray(e)?{items:e}:e?Object.assign({items:[]},e):{items:[]}}},function(e,t,a){'use strict';var n=a(433),o=a(436),i=a(438),r=a(262),s=a(6);class l extends n.a{constructor(e){super(e),this.stickyPanel=new i.a(e),this.toolbar=new r.a(e),s.a.extend(this.toolbar.template,{attributes:{class:'ck-editor-toolbar'}}),this.stickyPanel.content.add(this.toolbar),this.editable=new o.a(e),this.top.add(this.stickyPanel),this.main.add(this.editable)}get editableElement(){return this.editable.element}}t.a=l},function(e,t,a){'use strict';var n=a(434),o=a(52),i=a(6);class r extends n.a{constructor(e){super(e);const a=this.t,t=Object(o.a)();this.set('width',null),this.set('height',null),this.top=this.createCollection(),this.main=this.createCollection(),this.template=new i.a({tag:'div',attributes:{class:['ck-reset','ck-editor','ck-rounded-corners'],role:'application',dir:'ltr',lang:e.lang,"aria-labelledby":`cke-editor__aria-label_${t}`},children:[{tag:'span',attributes:{id:`cke-editor__aria-label_${t}`,class:'cke-voice-label'},children:[a('Rich Text Editor')]},{tag:'div',attributes:{class:'ck-editor__top ck-reset_all',role:'presentation'},children:this.top},{tag:'div',attributes:{class:'ck-editor__main',role:'presentation'},children:this.main}]})}}t.a=r},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(e){super(e),this.body=this.createCollection()}init(){this._renderBodyCollection(),super.init()}destroy(){return this._bodyCollectionContainer.remove(),super.destroy()}_renderBodyCollection(){const e=this._bodyCollectionContainer=new o.a({tag:'div',attributes:{class:['ck-body','ck-rounded-corners','ck-reset_all']},children:this.body}).render();document.body.appendChild(e)}}t.a=i},function(e,t,a){'use strict';var n=a(165);t.a=function(e,t){return Object(n.a)(e,!0,!0,t)}},function(e,t,a){'use strict';var n=a(437),o=a(6);class i extends n.a{constructor(e,a){super(e,a);const n=this.bindTemplate,i=this.t;this.set('name',null);o.a.extend(this.template,{attributes:{role:'textbox',"aria-label":n.to('name',(e)=>i('Rich Text Editor, %0',[e])),class:'ck-editor__editable_inline'}})}}t.a=i},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(e,t){super(e);const a=this.bindTemplate;t&&(this.element=this.editableElement=t),this.template=new o.a({tag:'div',attributes:{class:[a.to('isFocused',(e)=>e?'ck-focused':'ck-blurred'),'ck-editor__editable','ck-rounded-corners'],contenteditable:a.to('isReadOnly',(e)=>!e)}}),this.set('isReadOnly',!1),this.set('isFocused',!1),this.externalElement=t}init(){this.externalElement?this.template.apply(this.externalElement):this.editableElement=this.element,super.init()}destroy(){this.externalElement&&this.template.revert(this.externalElement),super.destroy()}}t.a=i},function(e,t,a){'use strict';var n=a(60),o=a(7),i=a(6),r=a(261);const s=Object(r.a)('px');class l extends o.a{constructor(e){super(e);const t=this.bindTemplate;this.set('isActive',!1),this.set('isSticky',!1),this.set('limiterElement',null),this.set('limiterBottomOffset',50),this.set('viewportTopOffset',0),this.set('_marginLeft',null),this.set('_isStickyToTheLimiter',!1),this.set('_hasViewportTopOffset',!1),this.content=this.createCollection(),this.template=new i.a({tag:'div',attributes:{class:['ck-sticky-panel',t.if('isSticky','ck-sticky-panel_sticky'),t.if('_isStickyToTheLimiter','ck-sticky-panel_sticky_bottom-limit')],style:{width:t.to('isSticky',(e)=>e?s(this._elementPlaceholder.getBoundingClientRect().width):null),top:t.to('_hasViewportTopOffset',(e)=>e?s(this.viewportTopOffset):null),bottom:t.to('_isStickyToTheLimiter',(e)=>e?s(this.limiterBottomOffset):null),marginLeft:t.to('_marginLeft')}},children:this.content}),this._elementPlaceholder=new i.a({tag:'div',attributes:{class:['ck-sticky-panel__placeholder'],style:{display:t.to('isSticky',(e)=>e?'block':'none'),height:t.to('isSticky',(e)=>e?s(this._panelRect.height):null)}}}).render()}init(){super.init(),this.element.parentNode.insertBefore(this._elementPlaceholder,this.element),this._checkIfShouldBeSticky(),this.listenTo(n.a.window,'scroll',()=>{this._checkIfShouldBeSticky()}),this.listenTo(this,'change:isActive',()=>{this._checkIfShouldBeSticky()})}destroy(){super.destroy(),this._elementPlaceholder.remove()}_checkIfShouldBeSticky(){const e=this._limiterRect=this.limiterElement.getBoundingClientRect(),t=this._panelRect=this.element.getBoundingClientRect();this.isSticky=this.isActive&&e.top<this.viewportTopOffset&&this._panelRect.height+this.limiterBottomOffset<e.height,this.isSticky?(this._isStickyToTheLimiter=e.bottom<t.height+this.limiterBottomOffset+this.viewportTopOffset,this._hasViewportTopOffset=!this._isStickyToTheLimiter&&!!this.viewportTopOffset,this._marginLeft=this._isStickyToTheLimiter?null:s(-n.a.window.scrollX)):(this._isStickyToTheLimiter=!1,this._hasViewportTopOffset=!1,this._marginLeft=null)}}t.a=l},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(e){super(e),this.template=new o.a({tag:'span',attributes:{class:['ck-toolbar__separator']}})}}t.a=i},function(e,t){'use strict';t.a=function(e){return e.bindTemplate.to((t)=>{t.target===e.element&&t.preventDefault()})}},function(e,t){'use strict';t.a=class{constructor(){this._replacedElements=[]}replace(e,t){this._replacedElements.push({element:e,newElement:t}),e.style.display='none',t&&e.parentNode.insertBefore(t,e.nextSibling)}restore(){this._replacedElements.forEach(({element:e,newElement:t})=>{e.style.display='',t&&t.remove()}),this._replacedElements=[]}}},function(e,t,a){var n=a(443);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.ck-hidden{display:none!important}.ck-reset,.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{box-sizing:border-box;width:auto;height:auto;position:static}svg.ck-icon{min-width:20px;min-height:20px;font-size:1em;vertical-align:middle}svg.ck-icon,svg.ck-icon *{color:inherit;cursor:inherit}svg.ck-icon *{fill:currentColor}.ck-tooltip,.ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:999}.ck-tooltip__text{display:inline-block}.ck-tooltip__text:after{content:"";width:0;height:0}.ck-button,a.ck-button{display:inline-block;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.ck-button .ck-tooltip,a.ck-button .ck-tooltip{display:block}.ck-button:hover .ck-tooltip,a.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck-button .ck-button__label,.ck-button:focus:not(:hover) .ck-tooltip,a.ck-button .ck-button__label,a.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck-toolbar__separator{display:inline-block}.ck-toolbar__newline{display:block;clear:left}.ck-dropdown{display:inline-block;position:relative}.ck-dropdown:after{content:"";width:0;height:0;pointer-events:none;z-index:1;position:absolute;top:50%;transform:translateY(-50%)}.ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:999;position:absolute;left:0;transform:translateY(100%)}.ck-dropdown__panel-visible{display:inline-block}.ck-label,.ck-list__item{display:block}.cke-voice-label{display:none}.ck-balloon-panel{display:none;position:absolute;z-index:999}.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:2}.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after{z-index:2}.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after{z-index:2}.ck-balloon-panel_visible{display:block}.ck-editor .ck-sticky-panel.ck-sticky-panel_sticky{z-index:999;position:fixed;top:0}.ck-editor .ck-sticky-panel.ck-sticky-panel_sticky.ck-sticky-panel_sticky_bottom-limit{top:auto;position:absolute}.ck-reset,.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{border-collapse:collapse;font:normal normal normal 12px/1.67 Helvetica,Arial,Tahoma,Verdana,Sans-Serif;color:#333;text-align:left;white-space:nowrap;cursor:auto;float:none}.ck-reset_all .ck-rtl *{text-align:right}.ck-reset_all iframe{vertical-align:inherit}.ck-reset_all textarea{white-space:pre-wrap}.ck-reset_all input[type=password],.ck-reset_all input[type=text],.ck-reset_all textarea{cursor:text}.ck-reset_all input[type=password][disabled],.ck-reset_all input[type=text][disabled],.ck-reset_all textarea[disabled]{cursor:default}.ck-reset_all fieldset{padding:10px;border:2px groove #e0dfe3}.ck-reset_all button::-moz-focus-inner{padding:0;border:0}svg.ck-icon{width:1.67em;height:1.67em}.ck-tooltip{left:50%}.ck-tooltip__text{font-size:.9em;line-height:1.5;color:#fff;padding:.4em .64em;background:#333;position:relative;left:-50%}.ck-rounded-corners .ck-tooltip__text,.ck-tooltip__text.ck-rounded-corners{border-radius:2px}.ck-tooltip__text:after{border-style:solid;left:50%}.ck-tooltip.ck-tooltip_s{bottom:-5px;transform:translateY(100%)}.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after{top:-5px;transform:translateX(-50%);border-color:transparent transparent #333;border-width:0 5px 5px}.ck-tooltip.ck-tooltip_n{top:-5px;transform:translateY(-100%)}.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:-5px;transform:translateX(-50%);border-color:#333 transparent transparent;border-width:5px 5px 0}.ck-tooltip,.ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s}.ck-button,a.ck-button{background:#fff;border:1px solid #bfbfbf;white-space:nowrap;cursor:default;vertical-align:middle;padding:.4em;font-size:inherit}.ck-button:not(.ck-disabled):focus,.ck-button:not(.ck-disabled):hover,a.ck-button:not(.ck-disabled):focus,a.ck-button:not(.ck-disabled):hover{background:#e6e6e6;border-color:#acacac}.ck-button:not(.ck-disabled):active,a.ck-button:not(.ck-disabled):active{background:#d9d9d9;border-color:#a3a3a3;box-shadow:inset 0 2px 2px #bfbfbf}.ck-button.ck-disabled,a.ck-button.ck-disabled{background:#fff;border-color:#c6c6c6}.ck-button.ck-rounded-corners,.ck-rounded-corners .ck-button,.ck-rounded-corners a.ck-button,a.ck-button.ck-rounded-corners{border-radius:2px}.ck-button:focus,a.ck-button:focus{outline:none;border:1px solid #48a3f5;box-shadow:0 0 3px 2px #78bbf8}.ck-button .ck-icon,a.ck-button .ck-icon{float:left}.ck-button.ck-disabled .ck-button__label,.ck-button.ck-disabled .ck-icon,a.ck-button.ck-disabled .ck-button__label,a.ck-button.ck-disabled .ck-icon{opacity:.5}.ck-button.ck-button_with-text,a.ck-button.ck-button_with-text{padding:.4em .8em}.ck-button.ck-button_with-text .ck-icon,a.ck-button.ck-button_with-text .ck-icon{margin-left:-.4em;margin-right:.4em}.ck-button.ck-button_with-text .ck-button__label,a.ck-button.ck-button_with-text .ck-button__label{display:block}.ck-button.ck-on,a.ck-button.ck-on{background:#f7f7f7;border-color:#b9b9b9}.ck-button.ck-on:not(.ck-disabled):focus,.ck-button.ck-on:not(.ck-disabled):hover,a.ck-button.ck-on:not(.ck-disabled):focus,a.ck-button.ck-on:not(.ck-disabled):hover{background:#dedede;border-color:#a7a7a7}.ck-button.ck-on:not(.ck-disabled):active,a.ck-button.ck-on:not(.ck-disabled):active{background:#d2d2d2;border-color:#9d9d9d;box-shadow:inset 0 2px 2px #b9b9b9}.ck-button.ck-on.ck-disabled,a.ck-button.ck-on.ck-disabled{background:#f8f8f8;border-color:silver}.ck-button-action,a.ck-button-action{background:#61b145;border-color:#4e8e37;text-shadow:0 -1px #4e8e37;color:#fff}.ck-button-action:not(.ck-disabled):focus,.ck-button-action:not(.ck-disabled):hover,a.ck-button-action:not(.ck-disabled):focus,a.ck-button-action:not(.ck-disabled):hover{background:#579f3e;border-color:#467f32}.ck-button-action:not(.ck-disabled):active,a.ck-button-action:not(.ck-disabled):active{background:#52963b;border-color:#42782f;box-shadow:inset 0 2px 2px #498534}.ck-button-action.ck-disabled,a.ck-button-action.ck-disabled{background:#6fbc54;border-color:#5aa440}.ck-button-action:active,.ck-button-action:focus,.ck-button-action:hover,a.ck-button-action:active,a.ck-button-action:focus,a.ck-button-action:hover{text-shadow:0 -1px #3a6a29}.ck-button-bold,a.ck-button-bold{font-weight:700}.ck-button .ck-icon use,.ck-button .ck-icon use *,a.ck-button .ck-icon use,a.ck-button .ck-icon use *{color:inherit}.ck-button .ck-button__label,a.ck-button .ck-button__label{font-size:inherit;float:left;height:1.67em;line-height:inherit;font-weight:inherit;color:inherit;cursor:inherit}.ck-toolbar{padding:.4em;border:1px solid #bfbfbf;white-space:normal;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.ck-toolbar_floating{white-space:nowrap}.ck-rounded-corners .ck-toolbar,.ck-toolbar.ck-rounded-corners{border-radius:2px}.ck-toolbar__separator{width:1px;height:2.28em;vertical-align:middle;background:#bfbfbf}.ck-toolbar__newline{height:.4em}.ck-toolbar>*{margin-right:.4em}.ck-toolbar>:last-child{margin-right:0}.ck-toolbar-container .ck-toolbar{border:0}.ck-dropdown{font-size:inherit}.ck-dropdown:after{border-style:solid;border-width:.4em .4em 0;border-color:#707070 transparent;right:.8em}.ck-dropdown .ck-button.ck-dropdown__button{padding-right:1.6em}.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:.5}.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck-dropdown__panel{background:#fff;border:1px solid #bfbfbf;bottom:1px;box-shadow:0 1px 2px 0 rgba(0,0,0,.2)}.ck-dropdown__panel.ck-rounded-corners,.ck-rounded-corners .ck-dropdown__panel{border-radius:2px}.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;overflow:hidden;list-style-type:none;background:#fff}.ck-list.ck-rounded-corners,.ck-rounded-corners .ck-list{border-radius:2px}.ck-list__item{padding:.64em;cursor:default;min-width:12em}.ck-list__item:focus,.ck-list__item:hover{background:#f7f7f7}.ck-list__item:focus{box-shadow:0 0 3px 2px #78bbf8;position:relative;z-index:1;outline:none}.ck-list__item_active{background:#1a8bf1;color:#fff}.ck-list__item_active:focus,.ck-list__item_active:hover{background:#0e7ee2}.ck-label{font-weight:700}.ck-input-text{box-shadow:inset 2px 2px 3px rgba(0,0,0,.1);background:#fff;border:1px solid #bfbfbf;padding:.4em .64em;min-width:21em}.ck-input-text.ck-rounded-corners,.ck-rounded-corners .ck-input-text{border-radius:2px}.ck-input-text:focus{outline:none;border:1px solid #48a3f5;box-shadow:0 0 3px 2px #78bbf8,inset 2px 2px 3px rgba(0,0,0,.1)}.ck-input-text[readonly]{border:1px solid #c6c6c6;background:#f2f2f2;color:#5c5c5c}.ck-editor__editable.ck-focused{outline:none;border:1px solid #48a3f5;box-shadow:inset 2px 2px 3px rgba(0,0,0,.1)}.ck-editor__editable_inline{overflow:auto;padding:0 .8em;border:1px solid transparent}.ck-editor-toolbar .ck-button{border-width:0}.ck-editor-toolbar .ck-button.ck-disabled,.ck-editor-toolbar .ck-button:not(:hover):not(:focus):not(.ck-on){background:#f7f7f7}.ck-editor-toolbar .ck-button.ck-on{background:#dedede;border-color:#acacac}.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):focus,.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):hover{background:#c6c6c6;border-color:#999}.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):active{background:#b9b9b9;border-color:#8f8f8f;box-shadow:inset 0 2px 2px #a1a1a1}.ck-editor-toolbar .ck-button.ck-on.ck-disabled{background:#f7f7f7;border-color:#bfbfbf}.ck-editor-toolbar .ck-button.ck-dropdown__button{border-width:1px}.ck-editor-toolbar .ck-button.ck-dropdown__button:not(:hover):not(:focus):not(.ck-on){background:#fff}.ck-toolbar-container .ck-editor-toolbar{background:#f7f7f7}.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_n:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_ne:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_nw:after{border-bottom-color:#f7f7f7}.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_s:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_se:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_sw:after{border-top-color:#f7f7f7}.ck-balloon-panel{box-shadow:0 1px 2px 0 rgba(0,0,0,.2);min-height:15px;background:#fff;border:1px solid #bfbfbf}.ck-balloon-panel.ck-rounded-corners,.ck-rounded-corners .ck-balloon-panel{border-radius:2px}.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{border-width:0 10px 15px}.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{border-color:transparent transparent #bfbfbf}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after{border-color:transparent transparent #fff;margin-top:2px}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{border-width:15px 10px 0}.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{border-color:#bfbfbf transparent transparent}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after{border-color:#fff transparent transparent;margin-bottom:2px}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:-10px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:20px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:20px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:-10px;bottom:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:20px;bottom:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:20px;bottom:-15px}.ck-editor .ck-sticky-panel.ck-sticky-panel_sticky{box-shadow:0 1px 2px 0 rgba(0,0,0,.2);border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}.ck-editor{position:relative}.ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:999;background:#f7f7f7;border-bottom-width:0}.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners,.ck-rounded-corners .ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:2px;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck-editor__top .ck-sticky-panel_sticky .ck-toolbar{border-bottom-width:1px}.ck-editor__top .ck-sticky-panel_sticky .ck-toolbar.ck-rounded-corners,.ck-rounded-corners .ck-editor__top .ck-sticky-panel_sticky .ck-toolbar{border-radius:2px;border-radius:0}.ck-editor__editable{border:1px solid #bfbfbf}.ck-editor__editable.ck-rounded-corners,.ck-rounded-corners .ck-editor__editable{border-radius:2px;border-top-left-radius:0;border-top-right-radius:0}',''])},function(e){e.exports=function(e){var t='undefined'!=typeof window&&window.location;if(!t)throw new Error('fixUrls requires window.location');if(!e||'string'!=typeof e)return e;var a=t.protocol+'//'+t.host,n=a+t.pathname.replace(/\/[^\/]*$/,'/'),o=e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,t){var o=t.trim().replace(/^"(.*)"$/,function(e,t){return t}).replace(/^'(.*)'$/,function(e,t){return t});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(o))return e;var i;return i=0===o.indexOf('//')?o:0===o.indexOf('/')?a+o:n+o.replace(/^\.\//,''),'url('+JSON.stringify(i)+')'});return o}},function(e,t,a){'use strict';var n=a(2),o=a(446),i=a(452),r=a(455),s=a(462);class l extends n.a{static get requires(){return[o.a,i.a,r.a,s.a]}}t.a=l},function(e,t,a){'use strict';var n=a(2),o=a(447),i=a(449),r=a(450),s=a(451),l=a(260);class d extends n.a{static get pluginName(){return'Clipboard'}init(){function e(e,o){const i=o.dataTransfer,r=t.data.toView(t.data.getSelectedContent(a.selection));o.preventDefault(),n.fire('clipboardOutput',{dataTransfer:i,content:r,method:e.name})}const t=this.editor,a=t.document,n=t.editing.view;this._htmlDataProcessor=new l.a,n.addObserver(o.a),this.listenTo(n,'clipboardInput',(e,a)=>{if(t.isReadOnly)return;const o=a.dataTransfer;let s='';o.getData('text/html')?s=Object(r.a)(o.getData('text/html')):o.getData('text/plain')&&(s=Object(i.a)(o.getData('text/plain'))),s=this._htmlDataProcessor.toView(s),this.fire('inputTransformation',{content:s}),n.scrollToTheSelection()},{priority:'low'}),this.listenTo(this,'inputTransformation',(e,t)=>{if(!t.content.isEmpty){const e=this.editor.data,n=e.toModel(t.content,'$clipboardHolder');if(0==n.childCount)return;a.enqueueChanges(()=>{e.insertContent(n,a.selection)})}},{priority:'low'}),this.listenTo(n,'copy',e,{priority:'low'}),this.listenTo(n,'cut',(a,n)=>{t.isReadOnly?n.preventDefault():e(a,n)},{priority:'low'}),this.listenTo(n,'clipboardOutput',(e,n)=>{n.content.isEmpty||(n.dataTransfer.setData('text/html',this._htmlDataProcessor.toData(n.content)),n.dataTransfer.setData('text/plain',Object(s.a)(n.content))),'cut'==n.method&&a.enqueueChanges(()=>{t.data.deleteContent(a.selection,a.batch())})},{priority:'low'})}}t.a=d},function(e,t,a){'use strict';function n(e,t){const a=t.target.ownerDocument,n=t.clientX,o=t.clientY;let i;return a.caretRangeFromPoint&&a.caretRangeFromPoint(n,o)?i=a.caretRangeFromPoint(n,o):t.rangeParent&&(i=a.createRange(),i.setStart(t.rangeParent,t.rangeOffset),i.collapse(!0)),i?e.domConverter.domRangeToView(i):e.selection.getFirstRange()}var o=a(75),i=a(448);class r extends o.a{constructor(e){function t(t,a){a.preventDefault();const n=a.dropRange?[a.dropRange]:Array.from(e.selection.getRanges());e.fire('clipboardInput',{dataTransfer:a.dataTransfer,targetRanges:n})}super(e),this.domEventType=['paste','copy','cut','drop','dragover'],this.listenTo(e,'paste',t,{priority:'low'}),this.listenTo(e,'drop',t,{priority:'low'})}onDomEvent(e){const t={dataTransfer:new i.a(e.clipboardData?e.clipboardData:e.dataTransfer)};'drop'==e.type&&(t.dropRange=n(this.document,e)),this.fire(e.type,e,t)}}t.a=r},function(e,t){'use strict';function a(e){const t=e.files?Array.from(e.files):[],a=e.items?Array.from(e.items):[];return t.length?t:a.filter((e)=>'file'===e.kind).map((e)=>e.getAsFile())}class n{constructor(e){this.files=a(e),this._native=e}get types(){return this._native.types}getData(e){return this._native.getData(e)}setData(e,t){this._native.setData(e,t)}}t.a=n},function(e,t){'use strict';t.a=function(e){return e=e.replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n\n/g,'</p><p>').replace(/\n/g,' ').replace(/^\s/,'&nbsp;').replace(/\s$/,'&nbsp;').replace(/\s\s/g,' &nbsp;'),-1<e.indexOf('</p><p>')&&(e=`<p>${e}</p>`),e}},function(e,t){'use strict';t.a=function(e){return e.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,(e,t)=>1==t.length?' ':t)}},function(e,t){'use strict';function a(e){let t='';if(e.is('text')||e.is('textProxy'))t=e.data;else if(e.is('img')&&e.hasAttribute('alt'))t=e.getAttribute('alt');else{let o=null;for(const i of e.getChildren()){const e=a(i);o&&(o.is('containerElement')||i.is('containerElement'))&&(n.includes(o.name)||n.includes(i.name)?t+='\n':t+='\n\n'),t+=e,o=i}}return t}t.a=a;const n=['figcaption','li']},function(e,t,a){'use strict';var n=a(2),o=a(453),i=a(454);class r extends n.a{static get pluginName(){return'Enter'}init(){const e=this.editor,t=e.editing.view;t.addObserver(i.a),e.commands.add('enter',new o.a(e)),this.listenTo(t,'enter',(a,n)=>{e.execute('enter'),n.preventDefault(),t.scrollToTheSelection()},{priority:'low'})}}t.a=r},function(e,t,a){'use strict';function n(e,t,a,n){const i=a.isCollapsed,r=a.getFirstRange(),s=r.start.parent,l=r.end.parent;if(n.limits.has(s.name)||n.limits.has(l.name))return void(i||s!=l||e.deleteContent(a,t));if(i)o(t,a,r.start);else{const n=!(r.start.isAtStart&&r.end.isAtEnd);e.deleteContent(a,t,{leaveUnmerged:n}),n&&(s==l?o(t,a,a.focus):a.setCollapsedAt(l))}}function o(e,t,a){const n=a.parent,o=new n.constructor(n.name,n.getAttributes());a.isAtEnd?e.insert(r.a.createAfter(a.parent),o):a.isAtStart?e.insert(r.a.createBefore(a.parent),o):e.split(a),t.setCollapsedAt(a.parent.nextSibling)}var i=a(11),r=a(1);class s extends i.a{execute(){const e=this.editor.document,t=e.batch();e.enqueueChanges(()=>{n(this.editor.data,t,e.selection,e.schema),this.fire('afterExecute',{batch:t})})}}t.a=s},function(e,t,a){'use strict';var n=a(61),o=a(154),i=a(28);class r extends n.a{constructor(e){super(e),e.on('keydown',(t,a)=>{this.isEnabled&&a.keyCode==i.c.enter&&e.fire('enter',new o.a(e,a.domEvent))})}observe(){}}t.a=r},function(e,t,a){'use strict';var n=a(2),o=a(456),i=a(459);class r extends n.a{static get requires(){return[o.a,i.a]}static get pluginName(){return'Typing'}}t.a=r},function(e,t,a){'use strict';function n(e){return!!e.ctrlKey||w.includes(e.keyCode)}function o(e,t){return e instanceof p.a&&t instanceof p.a?e.data===t.data:e===t}function i(e){if(1==e.newChildren.length-e.oldChildren.length){const t=Object(g.a)(e.oldChildren,e.newChildren,o),a=Object(f.a)(t,e.newChildren);if(!(1<a.length)){const e=a[0];return e.values[0]instanceof p.a?e:void 0}}}function r(e){const t=e.map((e)=>e.node).reduce((e,t)=>e.getCommonAncestor(t,{includeSelf:!0}));return t?t.getAncestors({includeSelf:!0,parentFirst:!0}).find((e)=>e.is('containerElement')||e.is('rootElement')):void 0}function s(e){if(0==e.length)return!1;for(const t of e)if('children'===t.type&&!i(t))return!0;return!1}function l(e){return e.every((e)=>e.is('text'))}function d(e){let t=null,a=null;for(let n=0;n<e.length;n++){const o=e[n];'equal'!=o&&(t=null==t?n:t,a=n)}let n=0,o=0;for(let r=t;r<=a;r++)'insert'!=e[r]&&n++,'delete'!=e[r]&&o++;return{insertions:o,deletions:n,firstChangeAt:t}}var c=a(2),m=a(3),u=a(22),p=a(35),g=a(251),f=a(457),h=a(28),b=a(153),_=a(458);class k extends c.a{static get pluginName(){return'Input'}init(){const e=this.editor,t=e.editing.view,a=new _.a(e,e.config.get('typing.undoStep')||20);e.commands.add('input',a),this.listenTo(t,'keydown',(e,t)=>{this._handleKeydown(t,a)},{priority:'lowest'}),this.listenTo(t,'mutations',(e,t,a)=>{this._handleMutations(t,a)})}_handleKeydown(e,t){const a=this.editor.document,o=t.buffer;!t.isEnabled||n(e)||a.selection.isCollapsed||(o.lock(),a.enqueueChanges(()=>{this.editor.data.deleteContent(a.selection,o.batch)}),o.unlock())}_handleMutations(e,t){new y(this.editor).handle(e,t)}}t.a=k;class y{constructor(e){this.editor=e,this.editing=this.editor.editing}handle(e,t){if(s(e))this._handleContainerChildrenMutations(e,t);else for(const a of e)this._handleTextMutation(a,t),this._handleTextNodeInsertion(a)}_handleContainerChildrenMutations(e,t){const a=r(e);if(!a)return;const n=this.editor.editing.view.domConverter,o=n.mapViewToDom(a);if(!o)return;const i=new b.a,s=this.editor.data.toModel(i.domToView(o)).getChild(0),c=this.editor.editing.mapper.toModelElement(a),u=Array.from(s.getChildren()),p=Array.from(c.getChildren());if(!l(u)||!l(p))return;const f=u.map((e)=>e.data).join('').replace(/\u00A0/g,' '),h=p.map((e)=>e.data).join('');if(h===f)return;const _=Object(g.a)(h,f),{firstChangeAt:k,insertions:y,deletions:w}=d(_);let v=null;t&&(v=this.editing.mapper.toModelRange(t.getFirstRange()));const x=f.substr(k,y),A=m.a.createFromParentsAndOffsets(c,k,c,k+w);this.editor.execute('input',{text:x,range:A,resultRange:v})}_handleTextMutation(e,t){if('text'!=e.type)return;const a=e.newText.replace(/\u00A0/g,' '),n=e.oldText.replace(/\u00A0/g,' '),o=Object(g.a)(n,a),{firstChangeAt:i,insertions:r,deletions:s}=d(o);let l=null;t&&(l=this.editing.mapper.toModelRange(t.getFirstRange()));const c=new u.a(e.node,i),p=this.editing.mapper.toModelPosition(c),f=m.a.createFromPositionAndShift(p,s),h=a.substr(i,r);this.editor.execute('input',{text:h,range:f,resultRange:l})}_handleTextNodeInsertion(e){if('children'==e.type){const t=i(e),a=new u.a(e.node,t.index),n=this.editing.mapper.toModelPosition(a),o=t.values[0].data;this.editor.execute('input',{text:o.replace(/\u00A0/g,' '),range:new m.a(n)})}}}const w=[Object(h.a)('arrowUp'),Object(h.a)('arrowRight'),Object(h.a)('arrowDown'),Object(h.a)('arrowLeft'),9,16,17,18,20,27,33,34,35,36,229];for(let n=112;135>=n;n++)w.push(n)},function(e,t){'use strict';t.a=function(e,t){function a(){r&&(o.push(r),r=null)}function n(e){return r&&r.type==e}const o=[];let i=0,r;return e.forEach((e)=>{'equal'==e?(a(),i++):'insert'==e?(n('insert')?r.values.push(t[i]):(a(),r={type:'insert',index:i,values:[t[i]]}),i++):n('delete')?r.howMany++:(a(),r={type:'delete',index:i,howMany:1})}),a(),o}},function(e,t,a){'use strict';var n=a(11),o=a(263);class i extends n.a{constructor(e,t){super(e),this._buffer=new o.a(e.document,t)}get buffer(){return this._buffer}destroy(){super.destroy(),this._buffer.destroy()}execute(e={}){const t=this.editor.document,a=e.text||'',n=a.length,o=e.range||t.selection.getFirstRange(),i=e.resultRange;t.enqueueChanges(()=>{const e=o.isCollapsed;this._buffer.lock(),e||this._buffer.batch.remove(o),a&&this._buffer.batch.weakInsert(o.start,a),i?this.editor.data.model.selection.setRanges([i]):e&&this.editor.data.model.selection.setCollapsedAt(o.start.getShiftedBy(n)),this._buffer.unlock(),this._buffer.input(n)})}}t.a=i},function(e,t,a){'use strict';var n=a(2),o=a(460),i=a(461);class r extends n.a{static get pluginName(){return'Delete'}init(){const e=this.editor,t=e.editing.view;t.addObserver(i.a),e.commands.add('forwardDelete',new o.a(e,'forward')),e.commands.add('delete',new o.a(e,'backward')),this.listenTo(t,'delete',(a,n)=>{e.execute('forward'==n.direction?'forwardDelete':'delete',{unit:n.unit,sequence:n.sequence}),n.preventDefault(),t.scrollToTheSelection()})}}t.a=r},function(e,t,a){'use strict';var n=a(11),o=a(59),i=a(5),r=a(1),s=a(3),l=a(263),d=a(152);class c extends n.a{constructor(e,t){super(e),this.direction=t,this._buffer=new l.a(e.document,e.config.get('typing.undoStep'))}execute(e={}){const t=this.editor.document,a=this.editor.data;t.enqueueChanges(()=>{this._buffer.lock();const n=o.a.createFromSelection(t.selection),i=n.isCollapsed;if(n.isCollapsed&&a.modifySelection(n,{direction:this.direction,unit:e.unit}),this._shouldEntireContentBeReplacedWithParagraph(e.sequence||1))return void this._replaceEntireContentWithParagraph();if(n.isCollapsed)return;let r=0;n.getFirstRange().getMinimalFlatRanges().forEach((e)=>{r+=Object(d.a)(e.getWalker({singleCharacters:!0,ignoreElementEnd:!0,shallow:!0}))}),a.deleteContent(n,this._buffer.batch,{doNotResetEntireContent:i}),this._buffer.input(r),t.selection.setRanges(n.getRanges(),n.isBackward),this._buffer.unlock()})}_shouldEntireContentBeReplacedWithParagraph(e){if(1<e)return!1;const t=this.editor.document,a=t.selection,n=t.schema.getLimitElement(a),o=a.isCollapsed&&a.containsEntireContent(n);if(!o)return!1;if(!t.schema.check({name:'paragraph',inside:n.name}))return!1;const i=n.getChild(0);return i&&'paragraph'===i.name?!1:!0}_replaceEntireContentWithParagraph(){const e=this.editor.document,t=e.selection,a=e.schema.getLimitElement(t),n=new i.a('paragraph');this._buffer.batch.remove(s.a.createIn(a)),this._buffer.batch.insert(r.a.createAt(a),n),t.setCollapsedAt(n)}}t.a=c},function(e,t,a){'use strict';var n=a(61),o=a(154),i=a(28);class r extends n.a{constructor(e){super(e);let t=0;e.on('keyup',(e,a)=>{(a.keyCode==i.c.delete||a.keyCode==i.c.backspace)&&(t=0)}),e.on('keydown',(a,n)=>{const r={};if(n.keyCode==i.c.delete)r.direction='forward',r.unit='character';else if(n.keyCode==i.c.backspace)r.direction='backward',r.unit='codePoint';else return;r.unit=n.altKey?'word':r.unit,r.sequence=++t,e.fire('delete',new o.a(e,n.domEvent,r))})}observe(){}}t.a=r},function(e,t,a){'use strict';var n=a(2),o=a(463),i=a(21),r=a(468),s=a.n(r),l=a(469),d=a.n(l);class c extends n.a{static get requires(){return[o.a]}static get pluginName(){return'Undo'}init(){const e=this.editor,a=e.t;this._addButton('undo',a('Undo'),'CTRL+Z',s.a),this._addButton('redo',a('Redo'),'CTRL+Y',d.a),e.keystrokes.set('CTRL+Z','undo'),e.keystrokes.set('CTRL+Y','redo'),e.keystrokes.set('CTRL+SHIFT+Z','redo')}_addButton(e,t,a,n){const o=this.editor,r=o.commands.get(e);o.ui.componentFactory.add(e,(s)=>{const l=new i.a(s);return l.set({label:t,icon:n,keystroke:a,tooltip:!0}),l.bind('isEnabled').to(r,'isEnabled'),this.listenTo(l,'execute',()=>o.execute(e)),l})}}t.a=c},function(e,t,a){'use strict';var n=a(2),o=a(464),i=a(465);class r extends n.a{constructor(e){super(e),this._batchRegistry=new WeakSet}init(){this._undoCommand=new o.a(this.editor),this._redoCommand=new i.a(this.editor),this.editor.commands.add('undo',this._undoCommand),this.editor.commands.add('redo',this._redoCommand),this.listenTo(this.editor.document,'change',(e,t,a,n)=>{this._batchRegistry.has(n)||'transparent'==n.type||(this._redoCommand._createdBatches.has(n)?this._undoCommand.addBatch(n):!this._undoCommand._createdBatches.has(n)&&(this._undoCommand.addBatch(n),this._redoCommand.clearStack()),this._batchRegistry.add(n))},{priority:'highest'}),this.listenTo(this._undoCommand,'revert',(e,t,a)=>{this._redoCommand.addBatch(a)})}}t.a=r},function(e,t,a){'use strict';var n=a(264);class o extends n.a{execute(e=null){const t=e?this._stack.findIndex((t)=>t.batch==e):this._stack.length-1,a=this._stack.splice(t,1)[0];this.editor.document.enqueueChanges(()=>{const e=this._undo(a.batch),t=this.editor.document.history.getDeltas(a.batch.baseVersion);this._restoreSelection(a.selection.ranges,a.selection.isBackward,t),this.fire('revert',a.batch,e)}),this.refresh()}}t.a=o},function(e,t,a){'use strict';var n=a(264);class o extends n.a{execute(){const e=this._stack.pop();this.editor.document.enqueueChanges(()=>{const t=e.batch.deltas[e.batch.deltas.length-1],a=t.baseVersion+t.operations.length,n=this.editor.document.history.getDeltas(a);this._restoreSelection(e.selection.ranges,e.selection.isBackward,n),this._undo(e.batch)}),this.refresh()}}t.a=o},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(){super();const e=this.bindTemplate;this.set('content'),this.set('viewBox','0 0 20 20'),this.template=new o.a({tag:'svg',ns:'http://www.w3.org/2000/svg',attributes:{class:'ck-icon',viewBox:e.to('viewBox')}}),this.on('change:content',(e,t,a)=>{for(const n=new DOMParser().parseFromString(a.trim(),'image/svg+xml').firstChild;0<n.childNodes.length;)this.element.appendChild(n.childNodes[0])})}}t.a=i},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(e){super(e),this.set('text',''),this.set('position','s');const t=this.bindTemplate;this.template=new o.a({tag:'span',attributes:{class:['ck-tooltip',t.to('position',(e)=>'ck-tooltip_'+e),t.if('text','ck-hidden',(e)=>!e.trim())]},children:[{tag:'span',attributes:{class:['ck-tooltip__text']},children:[{text:t.to('text')}]}]})}}t.a=i},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 10l8 6-1-3.982c3.417 0 8.616.869 10 3.982 0-5.983-6.601-7.96-10-7.96 0-.85 1-3.32 1-4.04l-8 6z" fill="#454545" fill-rule="evenodd"/></svg>'},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 16l1-3.982c-3.417 0-8.616.869-10 3.982 0-5.983 6.601-7.96 10-7.96 0-.85-1-3.32-1-4.04l8 6-8 6z" fill="#454545" fill-rule="evenodd"/></svg>'},function(e,t,a){'use strict';var n=a(2),o=a(76),i=a(472);class r extends n.a{static get requires(){return[o.a]}static get pluginName(){return'CKFinderUploadAdapter'}init(){const e=this.editor.config.get('ckfinder.uploadUrl');e&&(this.editor.plugins.get(o.a).createAdapter=(t)=>new s(t,e,this.editor.t))}}t.a=r;class s{constructor(e,a,n){this.loader=e,this.url=a,this.t=n}upload(){return new Promise((e,t)=>{this._initRequest(),this._initListeners(e,t),this._sendRequest()})}abort(){this.xhr&&this.xhr.abort()}_initRequest(){const e=this.xhr=new XMLHttpRequest;e.open('POST',this.url,!0),e.responseType='json'}_initListeners(e,a){const n=this.xhr,o=this.loader,i=this.t,t=i('Cannot upload file:')+` ${o.file.name}.`;n.addEventListener('error',()=>a(t)),n.addEventListener('abort',()=>a()),n.addEventListener('load',()=>{const o=n.response;return o&&o.uploaded?void e({default:o.url}):a(o&&o.error&&o.error.message?o.error.message:t)}),n.upload&&n.upload.addEventListener('progress',(e)=>{e.lengthComputable&&(o.uploadTotal=e.total,o.uploaded=e.loaded)})}_sendRequest(){const e=new FormData;e.append('upload',this.loader.file),e.append('ckCsrfToken',Object(i.a)()),this.xhr.send(e)}}},function(e,t,a){'use strict';var n=a(12),o=a(4);class i{constructor(){const e=new window.FileReader;this._reader=e,this.set('loaded',0),e.onprogress=(e)=>{this.loaded=e.loaded}}get error(){return this._reader.error}read(e){const t=this._reader;return this.total=e.size,new Promise((a,n)=>{t.onload=()=>{a(t.result)},t.onerror=()=>{n('error')},t.onabort=()=>{n('aborted')},this._reader.readAsDataURL(e)})}abort(){this._reader.abort()}}t.a=i,Object(o.a)(i,n.a)},function(e,t){'use strict';function a(e){e=e.toLowerCase();const t=document.cookie.split(';');for(const a of t){const t=a.split('='),n=decodeURIComponent(t[0].trim().toLowerCase());if(n===e)return decodeURIComponent(t[1])}return null}function n(e,t){document.cookie=encodeURIComponent(e)+'='+encodeURIComponent(t)+';path=/'}function o(e){let t='';const a=new Uint8Array(e);window.crypto.getRandomValues(a);for(let n=0;n<a.length;n++){const e=s.charAt(a[n]%s.length);t+=0.5<Math.random()?e.toUpperCase():e}return t}t.a=function(){let e=a(i);return e&&e.length==r||(e=o(r),n(i,e)),e};const i='ckCsrfToken',r=40,s='abcdefghijklmnopqrstuvwxyz0123456789'},function(e,t,a){'use strict';var n=a(474),o=a(475),i=a(2);class r extends i.a{static get pluginName(){return'Autoformat'}afterInit(){this._addListAutoformats(),this._addBasicStylesAutoformats(),this._addHeadingAutoformats(),this._addBlockQuoteAutoformats()}_addListAutoformats(){const e=this.editor.commands;e.get('bulletedList')&&new n.a(this.editor,/^[*-]\s$/,'bulletedList'),e.get('numberedList')&&new n.a(this.editor,/^\d+[.|)]?\s$/,'numberedList')}_addBasicStylesAutoformats(){const e=this.editor.commands;e.get('bold')&&(new o.a(this.editor,/(\*\*)([^*]+)(\*\*)$/g,'bold'),new o.a(this.editor,/(__)([^_]+)(__)$/g,'bold')),e.get('italic')&&(new o.a(this.editor,/(?:^|[^*])(\*)([^*_]+)(\*)$/g,'italic'),new o.a(this.editor,/(?:^|[^_])(_)([^_]+)(_)$/g,'italic')),e.get('code')&&new o.a(this.editor,/(`)([^`]+)(`)$/g,'code')}_addHeadingAutoformats(){Array.from(this.editor.commands.names()).filter((e)=>e.match(/^heading[1-6]$/)).forEach((e)=>{const t=e[7],a=new RegExp(`^(#{${t}})\\s$`);new n.a(this.editor,a,(t)=>{const{batch:a}=t;this.editor.execute(e,{batch:a})})})}_addBlockQuoteAutoformats(){this.editor.commands.get('blockQuote')&&new n.a(this.editor,/^>\s$/,'blockQuote')}}t.a=r},function(e,t,a){'use strict';var n=a(3),o=a(67);t.a=class{constructor(e,t,a){let i;if('function'==typeof a)i=a;else{i=(t)=>{const{batch:n}=t;e.execute(a,{batch:n})}}e.document.on('change',(a,r,s,l)=>{if('transparent'==l.type)return;if('insert'!=r)return;const d=s.range.getItems().next().value;if(!(d instanceof o.a))return;const c=d.textNode,m=c.data;if('paragraph'!==c.parent.name||!m)return;const u=t.exec(m);u&&e.document.enqueueChanges(()=>{const t=e.document.batch(),a=n.a.createFromParentsAndOffsets(c.parent,0,c.parent,u[0].length);t.remove(a),i({fixBatch:t,match:u})})})}}},function(e,t,a){'use strict';function n(e){return Array.from(e.getChildren()).reduce((e,t)=>e+t.data,'')}var o=a(151);t.a=class{constructor(e,t,a){let i,r,s,l;t instanceof RegExp?i=t:s=t,'string'==typeof a?r=a:l=a,s=s||((e)=>{let t;const a=[],n=[];for(;null!==(t=i.exec(e))&&!(t&&4>t.length);){let{index:e,1:o,2:i,3:r}=t;e+=t[0].length-(o+i+r).length;const s=[e,e+o.length],l=[e+o.length+i.length,e+o.length+i.length+r.length];a.push(s),a.push(l),n.push([e+o.length,e+o.length+i.length])}return{remove:a,format:n}}),l=l||((e,t)=>{for(const a of t)e.setAttribute(a,r,!0)}),e.document.on('change',(t,a,i,d)=>{if('transparent'==d.type)return;if('insert'!==a)return;const c=e.document.selection;if(!c.isCollapsed||!c.focus||!c.focus.parent)return;const m=c.focus.parent,u=n(m).slice(0,c.focus.offset),p=s(u),g=[];p.format.forEach((e)=>{void 0===e[0]||void 0===e[1]||g.push(o.a.createFromParentsAndOffsets(m,e[0],m,e[1]))});const f=[];p.remove.slice().reverse().forEach((e)=>{void 0===e[0]||void 0===e[1]||f.push(o.a.createFromParentsAndOffsets(m,e[0],m,e[1]))});g.length&&f.length&&e.document.enqueueChanges(()=>{const t=e.document.batch(),a=e.document.schema.getValidRanges(g,r);l(t,a);for(const e of f)t.remove(e)})})}}},function(e,t,a){'use strict';var n=a(2),o=a(477),i=a(21),r=a(478),s=a.n(r);class l extends n.a{static get requires(){return[o.a]}static get pluginName(){return'Bold'}init(){const e=this.editor,a=e.t,t=e.commands.get('bold'),n='CTRL+B';e.ui.componentFactory.add('bold',(o)=>{const r=new i.a(o);return r.set({label:a('Bold'),icon:s.a,keystroke:n,tooltip:!0}),r.bind('isOn','isEnabled').to(t,'value','isEnabled'),this.listenTo(r,'execute',()=>e.execute('bold')),r}),e.keystrokes.set(n,'bold')}}t.a=l},function(e,t,a){'use strict';var n=a(2),o=a(51),i=a(43),r=a(265);const s='bold';class l extends n.a{init(){const e=this.editor,t=e.data,a=e.editing;e.document.schema.allow({name:'$inline',attributes:s,inside:'$block'}),e.document.schema.allow({name:'$inline',attributes:s,inside:'$clipboardHolder'}),Object(o.a)().for(t.modelToView,a.modelToView).fromAttribute(s).toElement('strong'),Object(i.a)().for(t.viewToModel).fromElement('strong').fromElement('b').fromAttribute('style',{"font-weight":'bold'}).toAttribute(s,!0),e.commands.add(s,new r.a(e,s))}}t.a=l},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.135 10.409c.361.248.654.56.88.934.225.375.338.816.338 1.324 0 .609-.128 1.123-.385 1.543-.256.42-.624.751-1.103.994a5.908 5.908 0 0 1-1.755.55c-.663.107-1.442.16-2.338.16H4.539v-.66a22.5 22.5 0 0 0 .66-.076c.265-.033.45-.073.558-.118.208-.085.35-.196.427-.334.076-.138.114-.317.114-.537V5.732c0-.203-.031-.372-.093-.507s-.211-.254-.448-.355a3.326 3.326 0 0 0-.61-.182 14.136 14.136 0 0 0-.608-.114v-.66h6.52c1.64 0 2.825.226 3.552.677.727.45 1.09 1.116 1.09 1.995 0 .406-.08.763-.244 1.07a2.388 2.388 0 0 1-.702.8 4.214 4.214 0 0 1-.99.54c-.383.153-.795.28-1.234.381v.16c.44.046.896.143 1.37.292.473.15.885.343 1.234.58zm-2.723-3.611c0-.665-.187-1.184-.562-1.556-.375-.372-.937-.558-1.687-.558-.107 0-.247.004-.419.012l-.444.021v4.449h.44c.913 0 1.587-.213 2.021-.639.434-.425.651-1.002.651-1.73zm.592 5.759c0-.835-.248-1.475-.744-1.92-.496-.445-1.21-.668-2.14-.668a22.977 22.977 0 0 0-.82.034v4.389c.05.208.209.385.474.528.265.144.586.216.964.216.67 0 1.216-.225 1.636-.676.42-.452.63-1.086.63-1.903z" fill="#454545" fill-rule="evenodd"/></svg>'},function(e,t,a){'use strict';var n=a(2),o=a(480),i=a(21),r=a(481),s=a.n(r);class l extends n.a{static get requires(){return[o.a]}static get pluginName(){return'Italic'}init(){const e=this.editor,a=e.t,t=e.commands.get('italic'),n='CTRL+I';e.ui.componentFactory.add('italic',(o)=>{const r=new i.a(o);return r.set({label:a('Italic'),icon:s.a,keystroke:n,tooltip:!0}),r.bind('isOn','isEnabled').to(t,'value','isEnabled'),this.listenTo(r,'execute',()=>e.execute('italic')),r}),e.keystrokes.set(n,'italic')}}t.a=l},function(e,t,a){'use strict';var n=a(2),o=a(51),i=a(43),r=a(265);const s='italic';class l extends n.a{init(){const e=this.editor,t=e.data,a=e.editing;e.document.schema.allow({name:'$inline',attributes:s,inside:'$block'}),e.document.schema.allow({name:'$inline',attributes:s,inside:'$clipboardHolder'}),Object(o.a)().for(t.modelToView,a.modelToView).fromAttribute(s).toElement('i'),Object(i.a)().for(t.viewToModel).fromElement('em').fromElement('i').fromAttribute('style',{"font-style":'italic'}).toAttribute(s,!0),e.commands.add(s,new r.a(e,s))}}t.a=l},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M13.825 3.914l-.126.558a5.701 5.701 0 0 0-.685.076c-.282.045-.49.088-.626.127-.237.073-.406.186-.508.338a1.586 1.586 0 0 0-.22.5l-2.03 8.769a1.24 1.24 0 0 0-.034.27c.001.13.03.24.086.33.056.09.157.17.304.237.085.04.27.086.558.14.288.053.502.086.643.097l-.127.558H5.656l.127-.558.677-.05c.293-.023.501-.057.625-.102a1.11 1.11 0 0 0 .5-.326c.112-.138.188-.306.228-.503l2.02-8.778a1.428 1.428 0 0 0 .035-.305.59.59 0 0 0-.072-.295c-.048-.085-.148-.161-.3-.229a3.457 3.457 0 0 0-.622-.19 5.001 5.001 0 0 0-.58-.106l.128-.558h5.403z" fill="#454545" fill-rule="evenodd"/></svg>'},function(e,t,a){'use strict';var n=a(2),o=a(483),i=a(21),r=a(485),s=a.n(r),l=a(486),d=a.n(l);class c extends n.a{static get requires(){return[o.a]}static get pluginName(){return'BlockQuote'}init(){const e=this.editor,a=e.t,t=e.commands.get('blockQuote');e.ui.componentFactory.add('blockQuote',(n)=>{const o=new i.a(n);return o.set({label:a('Block quote'),icon:s.a,tooltip:!0}),o.bind('isOn','isEnabled').to(t,'value','isEnabled'),this.listenTo(o,'execute',()=>e.execute('blockQuote')),o})}afterInit(){const e=this.editor,t=e.commands.get('blockQuote');this.listenTo(this.editor.editing.view,'enter',(e,a)=>{const n=this.editor.document,o=n.selection.getLastPosition().parent;n.selection.isCollapsed&&o.isEmpty&&t.value&&(this.editor.execute('blockQuote'),this.editor.editing.view.scrollToTheSelection(),a.preventDefault(),e.stop())})}}t.a=c},function(e,t,a){'use strict';var n=a(2),o=a(484),i=a(43),r=a(51);class s extends n.a{init(){const e=this.editor,t=e.document.schema;e.commands.add('blockQuote',new o.a(e)),t.registerItem('blockQuote'),t.allow({name:'blockQuote',inside:'$root'}),t.allow({name:'$block',inside:'blockQuote'}),Object(i.a)().for(e.data.viewToModel).fromElement('blockquote').toElement('blockQuote'),Object(r.a)().for(e.data.modelToView,e.editing.modelToView).fromElement('blockQuote').toElement('blockquote')}afterInit(){const e=this.editor.document.schema;e.hasItem('listItem')&&e.allow({name:'listItem',inside:'blockQuote',attributes:['type','indent']})}}t.a=s},function(e,t,a){'use strict';function n(e){return'blockQuote'==e.parent.name?e.parent:null}function o(e){let t=0,a;const n=[];for(;t<e.length;){const o=e[t],i=e[t+1];a||(a=s.a.createBefore(o)),i&&o.nextSibling==i||(n.push(new d.a(a,s.a.createAfter(o))),a=null),t++}return n}function i(e,t){const a=e.check({name:'blockQuote',inside:s.a.createBefore(t)}),n=e.check({name:t.name,attributes:Array.from(t.getAttributeKeys()),inside:'blockQuote'});return a&&n}var r=a(11),s=a(1),l=a(5),d=a(3),c=a(63);class m extends r.a{refresh(){this.value=this._getValue(),this.isEnabled=this._checkEnabled()}execute(e={}){const t=this.editor.document,a=t.schema,o=e.batch||t.batch(),r=Array.from(t.selection.getSelectedBlocks());t.enqueueChanges(()=>{if(this.value)this._removeQuote(o,r.filter(n));else{const e=r.filter((e)=>n(e)||i(a,e));this._applyQuote(o,e)}})}_getValue(){const e=Object(c.a)(this.editor.document.selection.getSelectedBlocks());return!!(e&&n(e))}_checkEnabled(){if(this.value)return!0;const e=this.editor.document.selection,t=this.editor.document.schema,a=Object(c.a)(e.getSelectedBlocks());return!!a&&i(t,a)}_removeQuote(e,t){o(t).reverse().forEach((t)=>{if(t.start.isAtStart&&t.end.isAtEnd)return void e.unwrap(t.start.parent);if(t.start.isAtStart){const a=s.a.createBefore(t.start.parent);return void e.move(t,a)}t.end.isAtEnd||e.split(t.end);const a=s.a.createAfter(t.end.parent);e.move(t,a)})}_applyQuote(e,t){const a=[];o(t).reverse().forEach((t)=>{let o=n(t.start);o||(o=new l.a('blockQuote'),e.wrap(t,o)),a.push(o)}),a.reverse().reduce((t,a)=>t.nextSibling==a?(e.merge(s.a.createAfter(t)),t):a)}}t.a=m},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.061 15.51v-.882c1.395-.847 2.345-1.633 2.85-2.358.37-.533.554-1.162.554-1.887 0-.437-.082-.759-.246-.964-.15-.205-.328-.307-.533-.307-.137 0-.328.048-.574.143-.37.123-.67.185-.902.185-.547 0-1.033-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.212-1.238.636-1.62a3.002 3.002 0 0 1 2.05-.78c.93 0 1.757.39 2.482 1.17.724.778 1.087 1.742 1.087 2.89 0 1.614-.602 3.084-1.805 4.41-.807.875-1.976 1.593-3.507 2.153zm-8.386 0v-.882c1.394-.847 2.345-1.633 2.85-2.358.37-.533.554-1.162.554-1.887 0-.437-.082-.759-.246-.964-.15-.205-.328-.307-.533-.307-.137 0-.328.048-.574.143-.37.123-.67.185-.903.185-.547 0-1.032-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.212-1.238.636-1.62a3.002 3.002 0 0 1 2.051-.78c.93 0 1.757.39 2.481 1.17.725.778 1.087 1.742 1.087 2.89 0 1.614-.601 3.084-1.804 4.41-.807.875-1.976 1.593-3.507 2.153z" fill="#454545" fill-rule="evenodd"/></svg>'},function(e,t,a){var n=a(487);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'blockquote{border-left:5px solid #ccc;padding-left:20px;margin-left:0;font-style:italic;overflow:hidden}',''])},function(e,t,a){'use strict';var n=a(2),o=a(489),i=a(266),r=a(274);class s extends n.a{static get requires(){return[o.a,i.a,r.a]}static get pluginName(){return'EasyImage'}}t.a=s},function(e,t,a){'use strict';var n=a(2),o=a(76),i=a(490);class r extends n.a{static get requires(){return[o.a]}init(){const e=this.editor,t=e.config;t.define('cloudServices.uploadUrl','https://files.cke-cs.com/upload/');const a=t.get('cloudServices.token'),n=t.get('cloudServices.uploadUrl');a&&n&&(this._uploadGateway=new r._UploadGateway(a,n),e.plugins.get(o.a).createAdapter=(e)=>new s(this._uploadGateway,e))}}t.a=r;class s{constructor(e,t){this.uploadGateway=e,this.loader=t}upload(){return this.fileUploader=this.uploadGateway.upload(this.loader.file),this.fileUploader.on('progress',(e,t)=>{this.loader.uploadTotal=t.total,this.loader.uploaded=t.uploaded}),this.fileUploader.send()}abort(){this.fileUploader.abort()}}r._UploadGateway=i.a},function(e,t,a){'use strict';var n=a(491);t.a=class{constructor(e,t){if(!e)throw new Error('Token must be provided');if(!t)throw new Error('Api address must be provided');this._token=e,this._apiAddress=t}upload(e){return new n.a(e,this._token,this._apiAddress)}}},function(e,t,a){'use strict';function n(e,t=512){try{const a=e.match(s)[1],n=atob(e.replace(s,'')),o=[];for(let e=0;e<n.length;e+=t){const a=n.slice(e,e+t),r=Array(a.length);for(let e=0;e<a.length;e++)r[e]=a.charCodeAt(e);o.push(new Uint8Array(r))}return new Blob(o,{type:a})}catch(e){throw new Error('Problem with decoding Base64 image data.')}}function o(e){if('string'!=typeof e)return!1;const t=e.match(s);return!!(t&&t.length)}var i=a(4),r=a(8);const s=/^data:(\S*?);base64,/;class l{constructor(e,t,a){if(!e)throw new Error('File must be provided');if(!t)throw new Error('Token must be provided');if(!a)throw new Error('Api address must be provided');this.file=o(e)?n(e):e,this._token=t,this._apiAddress=a}onProgress(e){return this.on('progress',(t,a)=>e(a)),this}onError(e){return this.once('error',(t,a)=>e(a)),this}abort(){this.xhr.abort()}send(){return this._prepareRequest(),this._attachXHRListeners(),this._sendRequest()}_prepareRequest(){const e=new XMLHttpRequest;e.open('POST',this._apiAddress),e.setRequestHeader('Authorization',this._token),e.responseType='json',this.xhr=e}_attachXHRListeners(){function e(e){return()=>t.fire('error',e)}const t=this,a=this.xhr;a.addEventListener('error',e('Network Error')),a.addEventListener('abort',e('Abort')),a.upload&&a.upload.addEventListener('progress',(e)=>{e.lengthComputable&&this.fire('progress',{total:e.total,uploaded:e.loaded})}),a.addEventListener('load',()=>{const e=a.status,t=a.response;if(200>e||299<e)return this.fire('error',t.message||t.error)})}_sendRequest(){const e=new FormData,t=this.xhr;return e.append('file',this.file),new Promise((a,n)=>{t.addEventListener('load',()=>{const e=t.status,o=t.response;return 200>e||299<e?n(o.message||o.error):a(o)}),t.addEventListener('error',()=>n('Network Error')),t.addEventListener('abort',()=>n('Abort')),t.send(e)})}}Object(i.a)(l,r.c),t.a=l},function(e,t,a){'use strict';function n(){return(e,t,a,n)=>{const o=e.name.split(':'),i=o[0]+':'+o[1],r=t.item;if(a.consume(r,i)){const e=n.mapper.toViewElement(r),a=e.getChild(0),i=o[0];'removeAttribute'==i?a.removeAttribute(t.attributeKey):a.setAttribute(t.attributeKey,t.attributeNewValue)}}}function o(e,t,a){t=t.slice();for(const n={name:e.name,attributes:e.attributes,inside:t};t.length&&!a.check(n);){const e=t.pop(),n='string'==typeof e?e:e.name;if(a.limits.has(n))return null}return t.length?t:null}t.e=function(){return(e,t,a,n)=>{if(a.test(t.input,{name:!0,class:'image'})&&n.schema.check({name:'image',inside:t.context,attributes:'src'})){const e=Array.from(t.input.getChildren()).find((e)=>e.is('img'));if(e&&e.hasAttribute('src')&&a.test(e,{name:!0})){const o=n.convertItem(e,a,t);t.context.push(o);const r=n.convertChildren(t.input,a,t);t.context.pop(),s.a.insert(i.a.createAt(o),r),t.output=o}}}},t.b=function(e,t,a=n){for(const n of e)n.on(`addAttribute:${t}:image`,a()),n.on(`changeAttribute:${t}:image`,a()),n.on(`removeAttribute:${t}:image`,a())},t.d=function(){return(e,t,a,n)=>{const o=e.name.split(':'),i=o[0]+':'+o[1],r=t.item;if(a.consume(r,i)){const e=n.mapper.toViewElement(r),a=e.getChild(0),i=o[0];if('removeAttribute'==i){const e=t.attributeOldValue;e.data&&(a.removeAttribute('srcset'),a.removeAttribute('sizes'),e.width&&a.removeAttribute('width'))}else{const e=t.attributeNewValue;e.data&&(a.setAttribute('srcset',e.data),a.setAttribute('sizes','100vw'),e.width&&a.setAttribute('width',e.width))}}}},t.a=function(e,t,a,n){const i=t.input;if(a.test(i,{name:!0,attribute:['src']})){const e=o({name:'image',attributes:['src']},t.context,n.schema);if(e){const o=Object.assign({},t);o.context=e,t.output=n.convertItem(i,a,o),l.add(t.output)}}},t.c=function(e,t){if(t.output&&t.output.is('element')){const e=[];for(let a=t.output.childCount-1;0<=a;a--){const n=t.output.getChild(a);if(l.has(n)){const o=t.output.childCount-a-1;let i=null;0<o&&(i=t.output.clone(!1),i.appendChildren(t.output.removeChildren(a+1,o))),n.remove(),e.shift(),i&&e.unshift(i),e.unshift(n),0<t.output.childCount&&e.unshift(t.output)}}e.length&&(t.output=new r.a(e))}};var i=a(1),r=a(39),s=a(23);const l=new WeakSet},function(e,t,a){'use strict';function n(e,t){return e&&t&&e.priority==t.priority&&i(e.class)==i(t.class)}function o(e,t){if(e.priority>t.priority)return!0;return!(e.priority<t.priority)&&i(e.class)>i(t.class)}function i(e){return Array.isArray(e)?e.sort().join(','):e}var r=a(8),s=a(4);class l{constructor(){this._stack=[]}add(e){const t=this._stack,a=t[0];this._insertDescriptor(e);const o=t[0];a===o||n(a,o)||this.fire('change:top',{oldDescriptor:a,newDescriptor:o})}remove(e){const t=this._stack,a=t[0];this._removeDescriptor(e);const o=t[0];a===o||n(a,o)||this.fire('change:top',{oldDescriptor:a,newDescriptor:o})}_insertDescriptor(e){const t=this._stack,a=t.findIndex((t)=>t.id===e.id);if(!n(e,t[a])){-1<a&&t.splice(a,1);let n=0;for(;t[n]&&o(t[n],e);)n++;t.splice(n,0,e)}}_removeDescriptor(e){const t=this._stack,a=t.findIndex((t)=>t.id===e.id);-1<a&&t.splice(a,1)}}t.a=l,Object(s.a)(l,r.c)},function(e,t,a){'use strict';function n(e){return e==f.c.arrowright||e==f.c.arrowleft||e==f.c.arrowup||e==f.c.arrowdown}function o(e){return e==f.c.delete||e==f.c.backspace}function i(e){return Object(f.a)(e)==_}function r(e){for(;e;){if(e instanceof u.a&&!(e instanceof p.a))return!0;e=e.parent}return!1}var s=a(2),l=a(495),d=a(3),c=a(59),m=a(5),u=a(91),p=a(253),g=a(156),f=a(28),h=a(496),b=a.n(h);const _=Object(f.d)('Ctrl+A');class k extends s.a{static get pluginName(){return'Widget'}init(){const e=this.editor.editing.view;let t;this.editor.editing.modelToView.on('selection',(e,a,n,o)=>{t&&t.hasClass(g.a)&&t.removeClass(g.a);const i=o.viewSelection,r=i.getSelectedElement();r&&Object(g.c)(r)&&(i.setFake(!0,{label:Object(g.b)(r)}),r.addClass(g.a),t=r)},{priority:'low'}),e.addObserver(l.a),this.listenTo(e,'mousedown',(...e)=>this._onMousedown(...e)),this.listenTo(e,'keydown',(...e)=>this._onKeydown(...e),{priority:'high'})}_onMousedown(e,t){const a=this.editor,n=a.editing.view;let o=t.target;if(r(o))return;if(!Object(g.c)(o)&&(o=o.findAncestor(g.c),!o))return;t.preventDefault(),n.isFocused||n.focus();const i=a.editing.mapper.toModelElement(o);a.document.enqueueChanges(()=>{this._setSelectionOverElement(i)})}_onKeydown(e,t){const a=t.keyCode,r=a==f.c.delete||a==f.c.arrowdown||a==f.c.arrowright;let s=!1;o(a)?s=this._handleDelete(r):n(a)?s=this._handleArrowKeys(r):i(t)&&(s=this._selectAllNestedEditableContent()),s&&(t.preventDefault(),e.stop())}_handleDelete(e){if(this.editor.isReadOnly)return;const t=this.editor.document,a=t.selection;if(!a.isCollapsed)return;const n=this._getObjectElementNextToSelection(e);if(n)return t.enqueueChanges(()=>{const e=t.batch();for(let t=a.anchor.parent;t.isEmpty;){const a=t;t=a.parent,e.remove(a)}this._setSelectionOverElement(n)}),!0}_handleArrowKeys(e){const t=this.editor.document,a=t.schema,n=t.selection,o=n.getSelectedElement();if(o&&a.objects.has(o.name)){const a=e?n.getLastPosition():n.getFirstPosition(),o=t.getNearestSelectionRange(a,e?'forward':'backward');return o&&t.enqueueChanges(()=>{n.setRanges([o])}),!0}if(!n.isCollapsed)return;const i=this._getObjectElementNextToSelection(e);if(i instanceof m.a&&t.schema.objects.has(i.name))return t.enqueueChanges(()=>{this._setSelectionOverElement(i)}),!0}_selectAllNestedEditableContent(){const e=this.editor.document,t=e.selection,a=e.schema,n=a.getLimitElement(t);return t.getFirstRange().root!=n&&(e.enqueueChanges(()=>{t.setIn(n)}),!0)}_setSelectionOverElement(e){this.editor.document.selection.setRanges([d.a.createOn(e)])}_getObjectElementNextToSelection(e){const t=this.editor.document,a=t.schema,n=t.selection,o=this.editor.data,i=c.a.createFromSelection(n);o.modifySelection(i,{direction:e?'forward':'backward'});const r=e?i.focus.nodeBefore:i.focus.nodeAfter;return r instanceof m.a&&a.objects.has(r.name)?r:null}}t.a=k},function(e,t,a){'use strict';var n=a(75);class o extends n.a{constructor(e){super(e),this.domEventType='mousedown'}onDomEvent(e){this.fire(e.type,e)}}t.a=o},function(e,t,a){var n=a(497);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.ck-widget{margin:.8em 0;padding:0}.ck-widget.ck-widget_selected,.ck-widget.ck-widget_selected:hover{outline:3px solid #48a3f5}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected{outline:3px solid #ddd}.ck-widget:hover{outline:3px solid #ffd25c}.ck-widget .ck-editable{border:1px solid transparent}.ck-widget .ck-editable.ck-editable_focused,.ck-widget .ck-editable:focus{outline:none;border:1px solid #48a3f5;box-shadow:inset 2px 2px 3px rgba(0,0,0,.1);background-color:#fff}',''])},function(e,t,a){'use strict';var n=a(2),o=a(21),i=a(499),r=a(268),s=a(501),l=a(157),d=a(505),c=a.n(d),m=a(273),u=a(36),p=a(506),g=a.n(p);class f extends n.a{static get requires(){return[i.a,l.a]}static get pluginName(){return'ImageTextAlternative'}init(){this._createButton(),this._createForm()}_createButton(){const e=this.editor,a=e.commands.get('imageTextAlternative'),n=e.t;e.ui.componentFactory.add('imageTextAlternative',(e)=>{const t=new o.a(e);return t.set({label:n('Change image text alternative'),icon:c.a,tooltip:!0}),t.bind('isEnabled').to(a,'isEnabled'),this.listenTo(t,'execute',()=>this._showForm()),t})}_createForm(){const e=this.editor,t=e.editing.view;this._balloon=this.editor.plugins.get('ContextualBalloon'),this._form=new s.a(e.locale),this.listenTo(this._form,'submit',()=>{e.execute('imageTextAlternative',{newValue:this._form.labeledInput.inputView.element.value}),this._hideForm(!0)}),this.listenTo(this._form,'cancel',()=>{this._hideForm(!0)}),this._form.keystrokes.set('Esc',(e,t)=>{this._hideForm(!0),t()}),this.listenTo(t,'render',()=>{Object(u.b)(t.selection)?this._isVisible&&Object(m.b)(e):this._hideForm(!0)},{priority:'low'}),Object(r.a)({emitter:this._form,activator:()=>this._isVisible,contextElements:[this._form.element],callback:()=>this._hideForm()})}_showForm(){if(!this._isVisible){const e=this.editor,t=e.commands.get('imageTextAlternative'),a=this._form.labeledInput;this._balloon.hasView(this._form)||this._balloon.add({view:this._form,position:Object(m.a)(e)}),a.value=a.inputView.element.value=t.value||'',this._form.labeledInput.select()}}_hideForm(e){this._isVisible&&(this._balloon.remove(this._form),e&&this.editor.editing.view.focus())}get _isVisible(){return this._balloon.visibleView==this._form}}t.a=f},function(e,t,a){'use strict';var n=a(500),o=a(2);class i extends o.a{init(){this.editor.commands.add('imageTextAlternative',new n.a(this.editor))}}t.a=i},function(e,t,a){'use strict';var n=a(11),o=a(36);class i extends n.a{refresh(){const e=this.editor.document.selection.getSelectedElement();this.isEnabled=Object(o.a)(e),this.value=Object(o.a)(e)&&e.hasAttribute('alt')&&e.getAttribute('alt')}execute(e){const t=this.editor.document,a=t.selection.getSelectedElement();t.enqueueChanges(()=>{const n=e.batch||t.batch();n.setAttribute(a,'alt',e.newValue)})}}t.a=i},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(112),r=a(21),s=a(269),l=a(270),d=a(271),c=a(50),m=a(62),u=a(114);class p extends n.a{constructor(e){super(e);const a=this.locale.t;this.focusTracker=new m.a,this.keystrokes=new c.a,this.labeledInput=this._createLabeledInputView(),this.saveButtonView=this._createButton(a('Save')),this.saveButtonView.type='submit',this.cancelButtonView=this._createButton(a('Cancel'),'cancel'),this._focusables=new i.a,this._focusCycler=new u.a({focusables:this._focusables,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:'shift + tab',focusNext:'tab'}}),o.a.extend(this.saveButtonView.template,{attributes:{class:['ck-button-action']}}),this.template=new o.a({tag:'form',attributes:{class:['cke-text-alternative-form'],tabindex:'-1'},children:[this.labeledInput,{tag:'div',attributes:{class:['cke-text-alternative-form__actions']},children:[this.saveButtonView,this.cancelButtonView]}]}),Object(d.a)({view:this}),[this.labeledInput,this.saveButtonView,this.cancelButtonView].forEach((e)=>{this._focusables.add(e),this.focusTracker.add(e.element)})}init(){super.init(),this.keystrokes.listenTo(this.element)}_createButton(e,t){const a=new r.a(this.locale);return a.label=e,a.withText=!0,t&&a.delegate('execute').to(this,t),a}_createLabeledInputView(){const e=this.locale.t,t=new s.a(this.locale,l.a);return t.label=e('Text alternative'),t}}t.a=p},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(e){super(e),this.set('text'),this.set('for');const t=this.bindTemplate;this.template=new o.a({tag:'label',attributes:{class:['ck-label'],for:t.to('for')},children:[{text:t.to('text')}]})}}t.a=i},function(e,t,a){'use strict';function n(e,t,a){const{left:n,top:o,name:i}=e(t,a);return[i,a.clone().moveTo(n,o)]}function o(e,t,a,o,i){let r=0,s=0,l,d;const c=a.getArea();return e.some((e)=>{function m(){s=f,r=g,l=p,d=u}const[u,p]=n(e,t,a);let g,f;if(o)if(i){const e=o.getIntersection(i);g=e?e.getIntersectionArea(p):0}else g=o.getIntersectionArea(p);return i&&(f=i.getIntersectionArea(p)),i&&!o?f>s&&m():!i&&o?g>r&&m():f>s&&g>=r?m():f>=s&&g>r&&m(),g===c}),l?[d,l]:null}function i({left:e,top:t}){const{scrollX:a,scrollY:n}=r.a.window;return{left:e+a,top:t+n}}t.a=function({element:e,target:t,positions:a,limiter:m,fitInViewport:u}){Object(c.a)(t)&&(t=t()),Object(c.a)(m)&&(m=m());const p=Object(l.a)(e.parentElement),g=new s.a(e),f=new s.a(t);let h,b;if(!m&&!u)[b,h]=n(a[0],f,g);else{const e=m&&new s.a(m).getVisible(),t=u&&new s.a(r.a.window);[b,h]=o(a,f,g,e,t)||n(a[0],f,g)}let{left:_,top:k}=i(h);if(p){const e=i(new s.a(p)),t=Object(d.a)(p);_-=e.left,k-=e.top,_+=p.scrollLeft,k+=p.scrollTop,_-=t.left,k-=t.top}return{left:_,top:k,name:b}};var r=a(60),s=a(256),l=a(504),d=a(258),c=a(65)},function(e,t,a){'use strict';t.a=function(e){for(;e&&'html'!=e.tagName.toLowerCase();){if('static'!=n.a.window.getComputedStyle(e).position)return e;e=e.parentElement}return null};var n=a(60)},function(e){e.exports='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M5.414 6.749L2.903 4.237a.49.49 0 1 1 .694-.694L6.394 6.34a10.662 10.662 0 0 1 2.127-.53c.366-.051.734-.081 1.103-.095a10.628 10.628 0 0 1 1.524.07c1.109.134 2.204.449 3.243.936a9.65 9.65 0 0 1 2.12 1.331c.276.231.542.484.784.766.18.211.349.439.488.692.169.307.301.664.301 1.039 0 .375-.132.732-.301 1.039a4.143 4.143 0 0 1-.488.691 6.668 6.668 0 0 1-.784.767 9.628 9.628 0 0 1-2.092 1.318l2.196 2.197a.49.49 0 1 1-.694.694l-2.485-2.484-.008.003-.931-.931.009-.003-6.215-6.215a9.887 9.887 0 0 0-.945.444l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.483 8.596a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2 1.497 1.497 0 0 0-.108.241.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226 2.613 2.613 0 0 0 .234.379l3.463 3.594a10.565 10.565 0 0 1-2.125-1 9.096 9.096 0 0 1-1.015-.721 6.672 6.672 0 0 1-.798-.764 4.325 4.325 0 0 1-.502-.69c-.184-.319-.329-.693-.329-1.089 0-.375.131-.732.301-1.039.139-.253.307-.481.488-.692.225-.263.471-.5.728-.719a9.538 9.538 0 0 1 2.096-1.341l.019-.009zm6.674.401a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112 6.86 6.86 0 0 0 .727-.613c.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286a1.966 1.966 0 0 0 .148-.292.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891 10.119 10.119 0 0 0-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.449 2.449 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>'},function(e,t,a){var n=a(507);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.cke-text-alternative-form{padding:1.2em;overflow:hidden}.cke-text-alternative-form:focus{outline:none}.cke-text-alternative-form .ck-label{margin-bottom:.4em}.cke-text-alternative-form__actions{clear:both;padding-top:1.2em}.cke-text-alternative-form__actions .ck-button{float:right}.cke-text-alternative-form__actions .ck-button+.ck-button{margin-right:.64em}.cke-text-alternative-form__actions .ck-button+.ck-button+.ck-button{float:left}',''])},function(e,t,a){var n=a(509);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.ck-editor__editable .image{text-align:center;clear:both}.ck-editor__editable .image.image-style-align-center,.ck-editor__editable .image.image-style-align-left,.ck-editor__editable .image.image-style-align-right,.ck-editor__editable .image.image-style-side{max-width:50%}.ck-editor__editable .image.image-style-side{float:right;margin-left:2em}.ck-editor__editable .image.image-style-align-left{float:left;margin-right:2em}.ck-editor__editable .image.image-style-align-center{margin-left:auto;margin-right:auto}.ck-editor__editable .image.image-style-align-right{float:right;margin-left:2em}.ck-editor__editable .image>img{display:block;margin:0 auto;max-width:100%}',''])},function(e,t,a){'use strict';var n=a(2),o=a(275),i=a(513),r=a(514),s=a.n(r),l=a(276);class d extends n.a{static get requires(){return[o.a]}init(){const e=this.editor,a=e.t;e.ui.componentFactory.add('insertImage',(t)=>{const n=new i.a(t),o=e.commands.get('imageUpload');return n.set({label:a('Insert image'),icon:s.a,tooltip:!0,acceptedType:'image/*',allowMultipleFiles:!0}),n.bind('isEnabled').to(o),n.on('done',(t,a)=>{for(const n of Array.from(a)){const t=Object(l.a)(e.document.selection);Object(l.b)(n)&&e.execute('imageUpload',{file:n,insertAt:t})}}),n})}}t.a=d},function(e,t,a){'use strict';var n=a(5),o=a(3),i=a(59),r=a(76),s=a(11);class l extends s.a{execute(e){const t=this.editor,a=t.document,s=e.batch||a.batch(),l=e.file,d=a.selection,c=t.plugins.get(r.a);a.enqueueChanges(()=>{const r=c.createLoader(l);if(!r)return;const m=new n.a('image',{uploadId:r.id});let u;u=e.insertAt?new i.a([new o.a(e.insertAt)]):a.selection,t.data.insertContent(m,u,s),m.parent&&d.setRanges([o.a.createOn(m)])})}}t.a=l},function(e,t,a){'use strict';var n=a(2);class o extends n.a{static get pluginName(){return'Notification'}init(){this.on('show:warning',(e,t)=>{window.alert(t.message)},{priority:'lowest'})}showSuccess(e,t={}){this._showNotification({message:e,type:'success',namespace:t.namespace,title:t.title})}showInfo(e,t={}){this._showNotification({message:e,type:'info',namespace:t.namespace,title:t.title})}showWarning(e,t={}){this._showNotification({message:e,type:'warning',namespace:t.namespace,title:t.title})}_showNotification(e){const t=`show:${e.type}`+(e.namespace?`:${e.namespace}`:'');this.fire(t,{message:e.message,type:e.type,title:e.title||''})}}t.a=o},function(e,t,a){'use strict';var n=a(21),o=a(7),i=a(6);class r extends n.a{constructor(e){super(e),this.fileInputView=new s(e),this.fileInputView.bind('acceptedType').to(this,'acceptedType'),this.set('allowMultipleFiles',!1),this.fileInputView.bind('allowMultipleFiles').to(this,'allowMultipleFiles'),this.fileInputView.delegate('done').to(this),this.on('execute',()=>{this.fileInputView.open()}),document.body.appendChild(this.fileInputView.element)}destroy(){document.body.removeChild(this.fileInputView.element),super.destroy()}}t.a=r;class s extends o.a{constructor(e){super(e),this.set('acceptedType'),this.set('allowMultipleFiles',!1);const t=this.bindTemplate;this.template=new i.a({tag:'input',attributes:{class:['ck-hidden'],type:'file',tabindex:'-1',accept:t.to('acceptedType'),multiple:t.to('allowMultipleFiles')},on:{change:t.to(()=>{this.element&&this.element.files&&this.element.files.length&&this.fire('done',this.element.files),this.element.value=''})}})}open(){this.element.click()}}},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 14.994C2 16.102 2.895 17 3.994 17h12.012A2 2 0 0 0 18 14.994V5.006A2.001 2.001 0 0 0 16.006 3H3.994A2 2 0 0 0 2 5.006v9.988zm1-9.992C3 4.45 3.45 4 4.007 4h11.986A1.01 1.01 0 0 1 17 5.002v9.996C17 15.55 16.55 16 15.993 16H4.007A1.01 1.01 0 0 1 3 14.998V5.002zm1.024 10H16v-3.096l-2.89-4.263-3.096 5.257-3.003-2.103L4 13.96l.024 1.043zM6.406 6A1.4 1.4 0 0 0 5 7.393a1.4 1.4 0 0 0 1.406 1.393 1.4 1.4 0 0 0 1.407-1.393A1.4 1.4 0 0 0 6.406 6z" fill="#454545" fill-rule="evenodd"/></svg>'},function(e,t,a){'use strict';function n(){const e=new c.a('div',{class:'ck-progress-bar'});return e.setCustomProperty(f,!0),e}function o(e){for(const t of e.getChildren())if(t.getCustomProperty(f))return t}var i=a(2),r=a(71),s=a(76),l=a(516),d=a.n(l),c=a(94),m=a(275),u=a(517),p=a.n(u);class g extends i.a{static get requires(){return[m.a]}constructor(e){super(e),this.placeholder='data:image/svg+xml;utf8,'+encodeURIComponent(d.a)}init(){const e=this.editor;e.editing.modelToView.on('addAttribute:uploadStatus:image',(...e)=>this.uploadStatusChange(...e)),e.editing.modelToView.on('changeAttribute:uploadStatus:image',(...e)=>this.uploadStatusChange(...e))}uploadStatusChange(e,t,a){const i=this.editor,l=t.item,d=l.getAttribute('uploadId');if(a.consume(t.item,Object(r.b)(e.name))&&d){const e=i.plugins.get(s.a),a=this.placeholder,r=t.attributeNewValue,c=i.editing.mapper.toViewElement(l);if('reading'==r){c.addClass('ck-appear','ck-infinite-progress','ck-image-upload-placeholder');const e=c.getChild(0);return void e.setAttribute('src',a)}if('uploading'==r){const t=e.loaders.get(d);if(t){const e=n();c.removeClass('ck-infinite-progress','ck-image-upload-placeholder'),c.appendChildren(e),t.on('change:uploadedPercent',(t,a,n)=>{e.setStyle('width',n+'%'),i.editing.view.render()})}return}const m=o(c);m?m.remove():c.removeClass('ck-infinite-progress'),c.removeClass('ck-appear','ck-image-upload-placeholder')}}}t.a=g;const f=Symbol('progress-bar')},function(e){e.exports='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><g fill="none" fill-rule="evenodd"><rect width="700" height="250" fill="#F7F7F7" rx="4"/><text fill="#5F6F77" font-family="Arial,sans-serif" font-size="24"><tspan x="247.9" y="135">Uploading image\u2026</tspan></text></g></svg>\n'},function(e,t,a){var n=a(518);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'figure.image{position:relative;overflow:hidden}figure.image.ck-appear{animation:fadeIn .7s}figure.image.ck-infinite-progress:before{content:"";width:30px;height:2px;position:absolute;top:0;right:0;background:rgba(0,0,0,.1);animation-name:readingProgressAnimation;animation-duration:1.5s;animation-iteration-count:infinite;transition-timing-function:linear}figure.image.ck-image-upload-placeholder>img{width:100%}figure.image .ck-progress-bar{height:2px;width:0;position:absolute;top:0;left:0;background:#6ab5f9;transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes readingProgressAnimation{0%{width:30px;right:0}50%{width:45px}to{right:100%}}',''])},function(e,t,a){'use strict';function n(e,t){return Array.prototype.concat(...e.map((e)=>[e,t]))}var o=a(115),i=a(521),r=a(2),s=a(523),l=a(524),d=a(113),c=a(6),m=a(530),u=a.n(m);class p extends r.a{static get requires(){return[o.a,i.a]}static get pluginName(){return'Heading'}init(){const e=this.editor,a=new d.a,o=this._getLocalizedOptions(),i=[],r=e.t,t=r('Choose heading'),m=r('Heading');for(const t of o){const n=e.commands.get(t.modelElement),o=new s.a({commandName:t.modelElement,label:t.title,class:t.class});o.bind('isActive').to(n,'value'),a.add(o),i.push(n)}const u=new s.a({withText:!0,items:a,tooltip:m});u.bind('isEnabled').to(...n(i,'isEnabled'),(...e)=>e.some((e)=>e)),u.bind('label').to(...n(i,'value'),(...e)=>{const a=e.findIndex((e)=>e);return o[a]?o[a].title:t}),e.ui.componentFactory.add('headings',(t)=>{const a=Object(l.a)(u,t);return c.a.extend(a.template,{attributes:{class:['ck-heading-dropdown']}}),this.listenTo(a,'execute',(t)=>{e.execute(t.source.commandName),e.editing.view.focus()}),a})}_getLocalizedOptions(){const e=this.editor,a=e.t,t={Paragraph:a('Paragraph'),"Heading 1":a('Heading 1'),"Heading 2":a('Heading 2'),"Heading 3":a('Heading 3')};return e.config.get('heading.options').map((e)=>{const a=t[e.title];return a&&a!=e.title&&(e=Object.assign({},e,{title:a})),e})}}t.a=p},function(e,t,a){'use strict';function n(e,t){return t.check({name:'paragraph',inside:i.a.createBefore(e)})}var o=a(11),i=a(1),r=a(63);class s extends o.a{refresh(){const e=this.editor.document,t=Object(r.a)(e.selection.getSelectedBlocks());this.value=!!t&&t.is('paragraph'),this.isEnabled=!!t&&n(t,e.schema)}execute(e={}){const t=this.editor.document;t.enqueueChanges(()=>{const a=e.batch||t.batch(),o=(e.selection||t.selection).getSelectedBlocks();for(const e of o)!e.is('paragraph')&&n(e,t.schema)&&a.rename(e,'paragraph')})}}t.a=s},function(e,t,a){'use strict';var n=a(2),o=a(51),i=a(43),r=a(115),s=a(522);const l='paragraph';class d extends n.a{constructor(e){super(e),e.config.define('heading',{options:[{modelElement:'paragraph',title:'Paragraph',class:'ck-heading_paragraph'},{modelElement:'heading1',viewElement:'h2',title:'Heading 1',class:'ck-heading_heading1'},{modelElement:'heading2',viewElement:'h3',title:'Heading 2',class:'ck-heading_heading2'},{modelElement:'heading3',viewElement:'h4',title:'Heading 3',class:'ck-heading_heading3'}]})}static get requires(){return[r.a]}init(){const e=this.editor,t=e.data,a=e.editing,n=e.config.get('heading.options');for(const r of n)r.modelElement!==l&&(e.document.schema.registerItem(r.modelElement,'$block'),Object(o.a)().for(t.modelToView,a.modelToView).fromElement(r.modelElement).toElement(r.viewElement),Object(i.a)().for(t.viewToModel).fromElement(r.viewElement).toElement(r.modelElement),e.commands.add(r.modelElement,new s.a(e,r.modelElement)))}afterInit(){const e=this.editor,t=e.commands.get('enter'),a=e.config.get('heading.options');t&&this.listenTo(t,'afterExecute',(t,n)=>{const o=e.document.selection.getFirstPosition().parent,i=n.batch,r=a.some((e)=>o.is(e.modelElement));r&&!o.is(l)&&0===o.childCount&&i.rename(o,l)})}}t.a=d},function(e,t,a){'use strict';function n(e,t,a){return a.check({name:t,inside:i.a.createBefore(e)})}var o=a(11),i=a(1),r=a(63);class s extends o.a{constructor(e,t){super(e),this.modelElement=t}refresh(){const e=Object(r.a)(this.editor.document.selection.getSelectedBlocks());this.value=!!e&&e.is(this.modelElement),this.isEnabled=!!e&&n(e,this.modelElement,this.editor.document.schema)}execute(e={}){const t=this.editor,a=t.document;a.enqueueChanges(()=>{const t=e.batch||a.batch(),o=Array.from(a.selection.getSelectedBlocks()).filter((e)=>n(e,this.modelElement,a.schema));for(const e of o)e.is(this.modelElement)||t.rename(e,this.modelElement)})}}t.a=s},function(e,t,a){'use strict';var n=a(45),o=a(4),i=a(12);class r{constructor(e,t){t&&Object(n.a)(this,t),e&&this.set(e)}}t.a=r,Object(o.a)(r,i.a)},function(e,t,a){'use strict';function n(e){e.listenTo(document,'click',(t,{target:a})=>{e.element==a||e.element.contains(a)||(e.isOpen=!1)})}t.a=function(e,t){const a=Object(r.a)(e,t),s=a.listView=new o.a(t);return s.items.bindTo(e.items).using((e)=>{const a=new i.a(t);return a.bind(...Object.keys(e)).to(e),a}),s.items.delegate('execute').to(a),a.panelView.children.add(s),a.on('change:isOpen',(e,t,o)=>{o?n(a):a.stopListening(document)}),a.on('execute',()=>{a.isOpen=!1}),a.keystrokes.set('arrowdown',(e,t)=>{a.isOpen&&(s.focus(),t())}),a.keystrokes.set('arrowup',(e,t)=>{a.isOpen&&(s.focusLast(),t())}),a};var o=a(525),i=a(526),r=a(527)},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(62),r=a(114),s=a(50);class l extends n.a{constructor(){super(),this.items=this.createCollection(),this.focusTracker=new i.a,this.keystrokes=new s.a,this._focusCycler=new r.a({focusables:this.items,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:'arrowup',focusNext:'arrowdown'}}),this.template=new o.a({tag:'ul',attributes:{class:['ck-reset','ck-list']},children:this.items}),this.items.on('add',(e,t)=>{this.focusTracker.add(t.element)}),this.items.on('remove',(e,t)=>{this.focusTracker.remove(t.element)})}init(){this.keystrokes.listenTo(this.element),super.init()}focus(){this._focusCycler.focusFirst()}focusLast(){this._focusCycler.focusLast()}}t.a=l},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(50);class r extends n.a{constructor(){super(),this.set('tabindex',-1),this.keystrokes=new i.a;const e=this.bindTemplate;this.template=new o.a({tag:'li',attributes:{class:['ck-list__item',e.to('class'),e.if('isActive','ck-list__item_active')],style:e.to('style'),tabindex:e.to('tabindex')},children:[{text:e.to('label')}],on:{click:e.to('execute')}})}init(){const e=(e,t)=>{this.fire('execute'),t()};this.keystrokes.listenTo(this.element),this.keystrokes.set('Enter',e),this.keystrokes.set('Space',e)}focus(){this.element.focus()}}t.a=r},function(e,t,a){'use strict';t.a=function(e,t){const a=new n.a(t);a.bind('label','isOn','isEnabled','withText','keystroke','tooltip').to(e);const r=new i.a(t);return new o.a(t,a,r)};var n=a(21),o=a(528),i=a(529)},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(62),r=a(50);class s extends n.a{constructor(e,t,a){super(e),o.a.extend(t.template,{attributes:{class:['ck-dropdown__button']}}),this.buttonView=t,this.panelView=a,this.set('isOpen',!1),this.focusTracker=new i.a,this.keystrokes=new r.a,this.template=new o.a({tag:'div',attributes:{class:['ck-dropdown']},children:[t,a]}),this.listenTo(t,'execute',()=>{this.isOpen=!this.isOpen}),a.bind('isVisible').to(this,'isOpen')}init(){this.keystrokes.listenTo(this.element),this.focusTracker.add(this.element);const e=(e,t)=>{this.isOpen&&(this.buttonView.focus(),this.isOpen=!1,t())};this.keystrokes.set('arrowdown',(e,t)=>{this.buttonView.isEnabled&&!this.isOpen&&(this.isOpen=!0,t())}),this.keystrokes.set('arrowright',(e,t)=>{this.isOpen&&t()}),this.keystrokes.set('arrowleft',e),this.keystrokes.set('esc',e),super.init()}focus(){this.buttonView.focus()}}t.a=s},function(e,t,a){'use strict';var n=a(7),o=a(6);class i extends n.a{constructor(e){super(e);const t=this.bindTemplate;this.set('isVisible',!1),this.children=this.createCollection(),this.template=new o.a({tag:'div',attributes:{class:['ck-reset','ck-dropdown__panel',t.if('isVisible','ck-dropdown__panel-visible')]},children:this.children,on:{selectstart:t.to((e)=>e.preventDefault())}})}}t.a=i},function(e,t,a){var n=a(531);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.ck-heading_heading1{font-size:1.5em}.ck-heading_heading2{font-size:1.3em}.ck-heading_heading3{font-size:1.1em}[class*=ck-heading_]{line-height:21.6px;padding:9.6px}[class*=ck-heading_heading]{font-weight:700}.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}',''])},function(e,t,a){'use strict';var n=a(2),o=a(533),i=a(538),r=a.n(i);class s extends n.a{static get requires(){return[o.a]}static get pluginName(){return'ImageCaption'}}t.a=s},function(e,t,a){'use strict';function n(e,t,a,n){if('insert'===t){const e=new l.a({boundaries:a.range,ignoreElementEnd:!0});for(const t of e){const e=t.item;'elementStart'==t.type&&Object(h.a)(e)&&!Object(b.b)(e)&&n.document.enqueueChanges(()=>{Object(b.b)(e)||n.insert(p.a.createAt(e,'end'),new d.a('caption'))})}}}function o(e,t=!0){return(a,n,o,r)=>{const s=n.item;if((s.childCount||t)&&Object(h.a)(s.parent)){if(!o.consume(n.item,'insert'))return;const t=r.mapper.toViewElement(n.range.start.parent),a=e instanceof m.a?e.clone(!0):e();s.childCount||a.addClass('ck-hidden'),i(a,n.item,t,r.mapper)}}}function i(e,t,a,n){const o=g.a.createAt(a,'end');u.a.insert(o,e),n.bindElements(t,e)}function r(e){const t=e.getAncestors({includeSelf:!0}),a=t.find((e)=>'caption'==e.name);return a&&a.parent&&'image'==a.parent.name?a:null}var s=a(2),l=a(54),d=a(5),c=a(47),m=a(27),u=a(93),p=a(1),g=a(22),f=a(43),h=a(36),b=a(534);class _ extends s.a{init(){const e=this.editor,a=e.document,i=e.editing.view,r=a.schema,s=e.data,l=e.editing,d=e.t;this._createCaption=Object(b.a)(i,d('Enter image caption')),r.registerItem('caption','$block'),r.allow({name:'$inline',inside:'caption'}),r.allow({name:'caption',inside:'image'}),r.limits.add('caption'),a.on('change',n),Object(f.a)().for(s.viewToModel).from(b.c).toElement('caption'),s.modelToView.on('insert:caption',o(new c.a('figcaption'),!1)),l.modelToView.on('insert:caption',o(this._createCaption)),l.modelToView.on('insert',(e,t)=>this._fixCaptionVisibility(t.item),{priority:'high'}),l.modelToView.on('remove',(e,t)=>this._fixCaptionVisibility(t.sourcePosition.parent),{priority:'high'}),this.listenTo(i,'render',()=>this._updateCaptionVisibility(),{priority:'high'})}_updateCaptionVisibility(){const e=this.editor.editing.mapper;let t;this._lastSelectedCaption&&!this._lastSelectedCaption.childCount&&this._lastSelectedCaption.addClass('ck-hidden');const a=this.editor.document.selection,n=a.getSelectedElement();if(n&&n.is('image')){const a=Object(b.b)(n);t=e.toViewElement(a)}const o=a.getFirstPosition(),i=r(o.parent);i&&(t=e.toViewElement(i)),t&&(t.removeClass('ck-hidden'),this._lastSelectedCaption=t)}_fixCaptionVisibility(e){const t=r(e),a=this.editor.editing.mapper;if(t){const e=a.toViewElement(t);e&&(t.childCount?e.removeClass('ck-hidden'):e.addClass('ck-hidden'))}}}t.a=_},function(e,t,a){'use strict';t.a=function(e,t){return()=>{const a=new o.a('figcaption');return a.document=e,a.setCustomProperty(s,!0),Object(i.a)(a,t),Object(r.e)(a)}},t.b=function(e){for(const t of e.getChildren())if(t instanceof n.a&&'caption'==t.name)return t;return null},t.c=function(e){const t=e.parent;return'figcaption'==e.name&&t&&'figure'==t.name&&t.hasClass('image')?{name:!0}:null};var n=a(5),o=a(91),i=a(535),r=a(156);const s=Symbol('imageCaption')},function(e,t,a){'use strict';function n(e){const t=e.document;e.removeClass('ck-placeholder'),e.removeAttribute('data-placeholder'),u.has(t)&&u.get(t).delete(e)}function o(e){const t=u.get(e);for(const[a,n]of t)i(a,n)}function i(e,t){const a=e.document;if(a){const n=a.selection,o=n.anchor;if(t&&!t())return void e.removeClass('ck-placeholder');const i=!Array.from(e.getChildren()).some((e)=>!e.is('uiElement'));return!a.isFocused&&i?void e.addClass('ck-placeholder'):void(i&&o&&o.parent!==e?e.addClass('ck-placeholder'):e.removeClass('ck-placeholder'))}}t.a=function(e,t,a){const r=e.document;if(!r)throw new l.b('view-placeholder-element-is-detached: Provided element is not placed in document.');n(e),u.has(r)||(u.set(r,new Map),m.listenTo(r,'render',()=>o(r),{priority:'high'})),e.setAttribute('data-placeholder',t),u.get(r).set(e,a),i(e,a)};var r=a(45),s=a(8),l=a(0),d=a(536),c=a.n(d);const m={};Object(r.a)(m,s.c);const u=new WeakMap},function(e,t,a){var n=a(537);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.ck-placeholder:before{content:attr(data-placeholder);cursor:text;color:#c2c2c2;pointer-events:none}',''])},function(e,t,a){var n=a(539);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.ck-editor__editable .image>figcaption{color:#333;background-color:#f7f7f7;padding:.8em;font-size:.75em;outline-offset:-1px}',''])},function(e,t,a){'use strict';var n=a(2),o=a(541),i=a(21);class r extends n.a{static get requires(){return[o.a]}static get pluginName(){return'ImageStyle'}init(){const e=this.editor,t=e.plugins.get(o.a).imageStyles;for(const e of t)this._createButton(e)}_createButton(e){const t=this.editor,a=t.commands.get(e.name);t.ui.componentFactory.add(e.name,(n)=>{const o=new i.a(n);return o.set({label:e.title,icon:e.icon,tooltip:!0}),o.bind('isEnabled').to(a,'isEnabled'),o.bind('isOn').to(a,'value'),this.listenTo(o,'execute',()=>t.execute(e.name)),o})}}t.a=r},function(e,t,a){'use strict';function n(e){const t=b.defaultStyles,a=b.defaultIcons;if('string'==typeof e)t[e]?e=Object.assign({},t[e]):(l.a.warn('image-style-not-found: There is no such image style of given name.',{name:e}),e={name:e});else if(t[e.name]){const a=t[e.name],n=Object.assign({},e);for(const t in a)e.hasOwnProperty(t)||(n[t]=a[t]);e=n}return'string'==typeof e.icon&&a[e.icon]&&(e.icon=a[e.icon]),e}var o=a(2),i=a(542),r=a(267),s=a(543),l=a(16),d=a(544),c=a.n(d),m=a(545),u=a.n(m),p=a(546),g=a.n(p),f=a(547),h=a.n(f);class b extends o.a{static get requires(){return[r.a]}static get pluginName(){return'ImageStyleEngine'}init(){const e=this.editor,t=e.document,a=t.schema,n=e.data,o=e.editing;e.config.define('image.styles',['imageStyleFull','imageStyleSide']);const r=this.imageStyles;a.allow({name:'image',attributes:'imageStyle',inside:'$root'});const l=Object(s.a)(r);o.modelToView.on('addAttribute:imageStyle:image',l),n.modelToView.on('addAttribute:imageStyle:image',l),o.modelToView.on('changeAttribute:imageStyle:image',l),n.modelToView.on('changeAttribute:imageStyle:image',l),o.modelToView.on('removeAttribute:imageStyle:image',l),n.modelToView.on('removeAttribute:imageStyle:image',l),n.viewToModel.on('element:figure',Object(s.b)(r),{priority:'low'});for(const t of r)e.commands.add(t.name,new i.a(e,t))}get imageStyles(){if(this._cachedImageStyles)return this._cachedImageStyles;const e=[],t=this.editor,a=this.localizedDefaultStylesTitles,o=t.config.get('image.styles');for(let t of o)t=n(t),a[t.title]&&(t.title=a[t.title]),e.push(t);return this._cachedImageStyles=e}get localizedDefaultStylesTitles(){const e=this.editor.t;return{"Full size image":e('Full size image'),"Side image":e('Side image'),"Left aligned image":e('Left aligned image'),"Centered image":e('Centered image'),"Right aligned image":e('Right aligned image')}}}t.a=b,b.defaultStyles={imageStyleFull:{name:'imageStyleFull',title:'Full size image',icon:c.a,isDefault:!0},imageStyleSide:{name:'imageStyleSide',title:'Side image',icon:h.a,className:'image-style-side'},imageStyleAlignLeft:{name:'imageStyleAlignLeft',title:'Left aligned image',icon:u.a,className:'image-style-align-left'},imageStyleAlignCenter:{name:'imageStyleAlignCenter',title:'Centered image',icon:g.a,className:'image-style-align-center'},imageStyleAlignRight:{name:'imageStyleAlignRight',title:'Right aligned image',icon:h.a,className:'image-style-align-right'}},b.defaultIcons={full:c.a,left:u.a,right:h.a,center:g.a}},function(e,t,a){'use strict';var n=a(11),o=a(36);class i extends n.a{constructor(e,t){super(e),this.style=t}refresh(){const e=this.editor.document.selection.getSelectedElement();this.isEnabled=Object(o.a)(e),this.value=!!e&&(this.style.isDefault?!e.hasAttribute('imageStyle'):e.getAttribute('imageStyle')==this.style.name)}execute(e={}){if(this.value)return;const t=this.editor.document,a=t.selection.getSelectedElement();t.enqueueChanges(()=>{const n=e.batch||t.batch();n.setAttribute(a,'imageStyle',this.style.name)})}}t.a=i},function(e,t,a){'use strict';function n(e,t,a,n){const o=t.input,i=t.output;if(a.test(o,{class:e.className})&&Object(s.a)(i)){const r=[...i.getAttributeKeys(),'imageStyle'];n.schema.check({name:'image',inside:t.context,attributes:r})&&(a.consume(o,{class:e.className}),i.setAttribute('imageStyle',e.name))}}function o(e,t){for(const a of t)if(a.name===e)return a}function i(e,t,a){return t&&('changeAttribute'==e||'removeAttribute'==e)&&(a.removeClass(t.className),!0)}function r(e,t,a){return t&&('addAttribute'==e||'changeAttribute'==e)&&(a.addClass(t.className),!0)}t.a=function(e){return(t,a,n,s)=>{const l=t.name.split(':')[0],d=l+':imageStyle';if(n.test(a.item,d)){const t=o(a.attributeNewValue,e),c=o(a.attributeOldValue,e),m=s.mapper.toViewElement(a.item),u=i(l,c,m),p=r(l,t,m);(u||p)&&n.consume(a.item,d)}}},t.b=function(e){const t=e.filter((e)=>!e.isDefault);return(e,a,o,i)=>{for(const r of t)n(r,a,o,i)}};var s=a(36)},function(e){e.exports='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h16v1H2v-1zm15-2H3V6h14v8zm-1-7H4v6h12V7zM2 3h16v1H2V3z"/></svg>'},function(e){e.exports='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 15h16v1H2v-1zm11-3h5v1h-5v-1zm-2 1H2V6h9v7zm-1-6H3v5h7V7zm3 2h5v1h-5V9zm0-3h5v1h-5V6zM2 3h16v1H2V3z"/></svg>'},function(e){e.exports='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M2 15h16v1H2v-1zm13-2H5V6h10v7zm-1-6H6v5h8V7zM2 3h16v1H2V3z" fill-rule="nonzero"/></svg>'},function(e){e.exports='<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 16H2v-1h16v1zM6.978 13H2v-1h4.978v1zM18 6v7H9V6h9zm-1 6V7h-7v5h7zM6.978 10H2V9h4.978v1zm0-3H2V6h4.978v1zM18 4H2V3h16v1z"/></svg>'},function(e,t,a){'use strict';var n=a(6),o=a(2),i=a(262),r=a(157),s=a(36),l=a(273);class d extends o.a{static get requires(){return[r.a]}static get pluginName(){return'ImageToolbar'}afterInit(){const e=this.editor,t=e.config.get('image.toolbar');t&&t.length&&(this._balloon=this.editor.plugins.get('ContextualBalloon'),this._toolbar=new i.a,n.a.extend(this._toolbar.template,{attributes:{class:'ck-editor-toolbar'}}),this._toolbar.fillFromConfig(t,e.ui.componentFactory),this.listenTo(e.editing.view,'render',()=>{this._checkIsVisible()},{priority:'low'}),this.listenTo(e.ui.focusTracker,'change:isFocused',()=>{this._checkIsVisible()},{priority:'low'}))}_checkIsVisible(){const e=this.editor;e.ui.focusTracker.isFocused?Object(s.b)(e.editing.view.selection)?this._showToolbar():this._hideToolbar():this._hideToolbar()}_showToolbar(){const e=this.editor;this._isVisible?Object(l.b)(e):!this._balloon.hasView(this._toolbar)&&this._balloon.add({view:this._toolbar,position:Object(l.a)(e),balloonClassName:'ck-toolbar-container ck-editor-toolbar-container'})}_hideToolbar(){this._isVisible&&this._balloon.remove(this._toolbar)}get _isVisible(){return this._balloon.visibleView==this._toolbar}}t.a=d},function(e,t,a){'use strict';function n(e){return e.getAncestors().find((e)=>e instanceof l.a)}var o=a(2),i=a(550),r=a(38),s=a(551),l=a(277),d=a(157),c=a(268),m=a(21),u=a(554),p=a(555),g=a.n(p),f=a(556),h=a.n(f);const b='Ctrl+K';class _ extends o.a{static get requires(){return[s.a,d.a]}static get pluginName(){return'Link'}init(){const e=this.editor;e.editing.view.addObserver(i.a),this.formView=this._createForm(),this._balloon=e.plugins.get(d.a),this._createToolbarLinkButton(),this._attachActions()}_createForm(){const e=this.editor,t=new u.a(e.locale),a=e.commands.get('link'),n=e.commands.get('unlink');return t.urlInputView.bind('value').to(a,'value'),t.urlInputView.bind('isReadOnly').to(a,'isEnabled',(e)=>!e),t.saveButtonView.bind('isEnabled').to(a),t.unlinkButtonView.bind('isEnabled').to(n),this.listenTo(t,'submit',()=>{e.execute('link',t.urlInputView.inputView.element.value),this._hidePanel(!0)}),this.listenTo(t,'unlink',()=>{e.execute('unlink'),this._hidePanel(!0)}),this.listenTo(t,'cancel',()=>this._hidePanel(!0)),t.keystrokes.set('Esc',(e,t)=>{this._hidePanel(!0),t()}),t}_createToolbarLinkButton(){const e=this.editor,a=e.commands.get('link'),n=e.t;e.keystrokes.set(b,(e,t)=>{t(),a.isEnabled&&this._showPanel(!0)}),e.ui.componentFactory.add('link',(e)=>{const t=new m.a(e);return t.isEnabled=!0,t.label=n('Link'),t.icon=g.a,t.keystroke=b,t.tooltip=!0,t.bind('isEnabled').to(a,'isEnabled'),this.listenTo(t,'execute',()=>this._showPanel(!0)),t})}_attachActions(){const e=this.editor.editing.view;this.listenTo(e,'click',()=>{const e=this._getSelectedLinkElement();e&&this._showPanel()}),this.editor.keystrokes.set('Tab',(e,t)=>{this._balloon.visibleView!==this.formView||this.formView.focusTracker.isFocused||(this.formView.focus(),t())},{priority:'high'}),this.editor.keystrokes.set('Esc',(e,t)=>{this._balloon.visibleView===this.formView&&(this._hidePanel(),t())}),Object(c.a)({emitter:this.formView,activator:()=>this._balloon.hasView(this.formView),contextElements:[this._balloon.view.element],callback:()=>this._hidePanel()})}_showPanel(e){const t=this.editor,a=t.commands.get('link'),n=t.commands.get('unlink'),o=t.editing,i=o.view,r=i.selection.isCollapsed,s=this._getSelectedLinkElement();this.formView.unlinkButtonView.isVisible=n.isEnabled,this.formView.urlInputView.inputView.element.value=a.value||'',this.listenTo(i,'render',()=>{const e=this._getSelectedLinkElement(),t=i.selection.isCollapsed;r&&!t||s!==e?this._hidePanel(!0):this._balloon.updatePosition(this._getBalloonPositionData())}),this._balloon.hasView(this.formView)?e&&this._balloon.visibleView===this.formView&&this.formView.urlInputView.select():(this._balloon.add({view:this.formView,position:this._getBalloonPositionData()}),e&&this.formView.urlInputView.select())}_hidePanel(e){this.stopListening(this.editor.editing.view,'render');this._balloon.hasView(this.formView)&&(e&&this.editor.editing.view.focus(),this.stopListening(this.editor.editing.view,'render'),this._balloon.remove(this.formView))}_getBalloonPositionData(){const e=this.editor.editing.view,t=this._getSelectedLinkElement(),a=t?e.domConverter.mapViewToDom(t):e.domConverter.viewRangeToDom(e.selection.getFirstRange());return{target:a}}_getSelectedLinkElement(){const e=this.editor.editing.view.selection;if(e.isCollapsed)return n(e.getFirstPosition());else{const t=e.getFirstRange().getTrimmed(),a=n(t.start),o=n(t.end);return a&&a==o?r.a.createIn(a).getTrimmed().isEqual(t)?a:null:null}}}t.a=_},function(e,t,a){'use strict';var n=a(75);class o extends n.a{constructor(e){super(e),this.domEventType='click'}onDomEvent(e){this.fire(e.type,e)}}t.a=o},function(e,t,a){'use strict';var n=a(2),o=a(51),i=a(43),r=a(277),s=a(552),l=a(553);class d extends n.a{init(){const e=this.editor,t=e.data,a=e.editing;e.document.schema.allow({name:'$inline',attributes:'linkHref',inside:'$block'}),e.document.schema.allow({name:'$inline',attributes:'linkHref',inside:'$clipboardHolder'}),Object(o.a)().for(t.modelToView,a.modelToView).fromAttribute('linkHref').toElement((e)=>{const t=new r.a('a',{href:e});return t.priority=5,t}),Object(i.a)().for(t.viewToModel).from({name:'a',attribute:{href:/.?/}}).toAttribute((e)=>({key:'linkHref',value:e.getAttribute('href')})),e.commands.add('link',new s.a(e)),e.commands.add('unlink',new l.a(e))}}t.a=d},function(e,t,a){'use strict';var n=a(11),o=a(26),i=a(3),r=a(278);class s extends n.a{refresh(){const e=this.editor.document;this.value=e.selection.getAttribute('linkHref'),this.isEnabled=e.schema.checkAttributeInSelection(e.selection,'linkHref')}execute(e){const t=this.editor.document,a=t.selection;t.enqueueChanges(()=>{const n=t.batch();if(a.isCollapsed){const t=a.getFirstPosition();if(a.hasAttribute('linkHref')){const t=Object(r.a)(a.getFirstPosition(),a.getAttribute('linkHref'));n.setAttribute(t,'linkHref',e),a.setRanges([t])}else{const r=new o.a(e,{linkHref:e});n.insert(t,r),a.setRanges([i.a.createOn(r)])}}else{const o=t.schema.getValidRanges(a.getRanges(),'linkHref');for(const t of o)n.setAttribute(t,'linkHref',e)}})}}t.a=s},function(e,t,a){'use strict';var n=a(11),o=a(278);class i extends n.a{refresh(){this.isEnabled=this.editor.document.selection.hasAttribute('linkHref')}execute(){const e=this.editor.document,t=e.selection;e.enqueueChanges(()=>{const a=t.isCollapsed?[Object(o.a)(t.getFirstPosition(),t.getAttribute('linkHref'))]:t.getRanges(),n=e.batch();for(const e of a)n.removeAttribute(e,'linkHref')})}}t.a=i},function(e,t,a){'use strict';var n=a(7),o=a(6),i=a(112),r=a(21),s=a(269),l=a(270),d=a(271),c=a(62),m=a(114),u=a(50);class p extends n.a{constructor(e){super(e);const a=e.t;this.focusTracker=new c.a,this.keystrokes=new u.a,this.urlInputView=this._createUrlInput(),this.saveButtonView=this._createButton(a('Save')),this.saveButtonView.type='submit',this.cancelButtonView=this._createButton(a('Cancel'),'cancel'),this.unlinkButtonView=this._createButton(a('Unlink'),'unlink'),this._focusables=new i.a,this._focusCycler=new m.a({focusables:this._focusables,focusTracker:this.focusTracker,keystrokeHandler:this.keystrokes,actions:{focusPrevious:'shift + tab',focusNext:'tab'}}),o.a.extend(this.saveButtonView.template,{attributes:{class:['ck-button-action']}}),this.template=new o.a({tag:'form',attributes:{class:['ck-link-form'],tabindex:'-1'},children:[this.urlInputView,{tag:'div',attributes:{class:['ck-link-form__actions']},children:[this.saveButtonView,this.cancelButtonView,this.unlinkButtonView]}]}),Object(d.a)({view:this});const t=[this.urlInputView,this.saveButtonView,this.cancelButtonView,this.unlinkButtonView];t.forEach((e)=>{this._focusables.add(e),this.focusTracker.add(e.element)})}init(){return this.keystrokes.listenTo(this.element),super.init()}focus(){this._focusCycler.focusFirst()}_createUrlInput(){const e=this.locale.t,t=new s.a(this.locale,l.a);return t.label=e('Link URL'),t.inputView.placeholder='https://example.com',t}_createButton(e,t){const a=new r.a(this.locale);return a.label=e,a.withText=!0,t&&a.delegate('execute').to(this,t),a}}t.a=p},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="#222" fill-rule="evenodd"><path d="M14.2 10.956l1.227-1.227a3.995 3.995 0 0 0-.002-5.654 4 4 0 0 0-5.654-.002L7.698 6.145a3.995 3.995 0 0 0 .003 5.654c.39.39.84.682 1.32.878l-.305-.307.638-.638a2.99 2.99 0 0 1-.946-.64 2.995 2.995 0 0 1-.003-4.24l2.073-2.072a3 3 0 0 1 4.242 4.242l-1.226 1.227.707.707z"/><path d="M10.166 7.405c.41.192.795.457 1.133.796a3.995 3.995 0 0 1 .003 5.654l-2.073 2.072a4 4 0 0 1-5.654-.002 3.995 3.995 0 0 1-.002-5.654l1.362-1.363.707.707-1.362 1.363a3 3 0 0 0 4.243 4.243l2.072-2.073a2.995 2.995 0 0 0-.003-4.24 2.987 2.987 0 0 0-1.196-.733l.77-.77z"/></g></svg>'},function(e,t,a){var n=a(557);'string'==typeof n&&(n=[[e.i,n,'']]);var o={},i;o.transform=i;a(32)(n,o);n.locals&&(e.exports=n.locals),!1},function(e,t,a){t=e.exports=a(31)(void 0),t.push([e.i,'.ck-link-form{padding:1.2em;overflow:hidden}.ck-link-form:focus{outline:none}.ck-link-form .ck-input-text{width:100%}.ck-link-form .ck-label{margin-bottom:.2em}.ck-link-form__actions{clear:both;padding-top:1.2em}.ck-link-form__actions .ck-button{float:right}.ck-link-form__actions .ck-button+.ck-button{margin-right:.64em}.ck-link-form__actions .ck-button:last-child{float:left;margin-right:2.56em}',''])},function(e,t,a){'use strict';var n=a(559),o=a(564),i=a.n(o),r=a(565),s=a.n(r),l=a(2),d=a(21);class c extends l.a{static get requires(){return[n.a]}static get pluginName(){return'List'}init(){const e=this.editor.t;this._addButton('numberedList',e('Numbered List'),i.a),this._addButton('bulletedList',e('Bulleted List'),s.a),this.listenTo(this.editor.editing.view,'enter',(e,t)=>{const a=this.editor.document,n=a.selection.getLastPosition().parent;a.selection.isCollapsed&&'listItem'==n.name&&n.isEmpty&&(this.editor.execute('outdentList'),t.preventDefault(),e.stop())});const t=(e)=>(t,a)=>{const n=this.editor.commands.get(e);n.isEnabled&&(this.editor.execute(e),a())};this.editor.keystrokes.set('Tab',t('indentList')),this.editor.keystrokes.set('Shift+Tab',t('outdentList'))}_addButton(e,t,a){const n=this.editor,o=n.commands.get(e);n.ui.componentFactory.add(e,(i)=>{const r=new d.a(i);return r.set({label:t,icon:a,tooltip:!0}),r.bind('isOn','isEnabled').to(o,'value','isEnabled'),this.listenTo(r,'execute',()=>n.execute(e)),r})}}t.a=c},function(e,t,a){'use strict';function n(e){let t=1;for(const a of e.getChildren())if('ul'==a.name||'ol'==a.name)for(const e of a.getChildren())t+=n(e);return t}var o=a(560),i=a(561),r=a(2),s=a(115),l=a(562);class d extends r.a{static get requires(){return[s.a]}init(){const e=this.editor,t=e.document.schema;t.registerItem('listItem','$block'),t.allow({name:'listItem',inside:'$root',attributes:['type','indent']}),t.requireAttributes('listItem',['type','indent']);const a=e.data,r=e.editing;this.editor.document.on('change',Object(l.c)(this.editor.document),{priority:'high'}),this.editor.document.on('change',(e,t,a)=>{if('move'==t)for(const e of a.range.getItems())e.is('listItem')&&r.mapper.unbindModelElement(e)},{priority:'high'}),r.mapper.registerViewToModelLength('li',n),a.mapper.registerViewToModelLength('li',n),r.mapper.on('modelToViewPosition',l.e),r.mapper.on('viewToModelPosition',l.m),a.mapper.on('modelToViewPosition',l.e),r.modelToView.on('insert',l.k,{priority:'high'}),r.modelToView.on('insert:listItem',l.h),a.modelToView.on('insert',l.k,{priority:'high'}),a.modelToView.on('insert:listItem',l.h),r.modelToView.on('changeAttribute:type:listItem',l.g),a.modelToView.on('changeAttribute:type:listItem',l.g),r.modelToView.on('remove:listItem',l.j),r.modelToView.on('remove',l.i,{priority:'low'}),a.modelToView.on('remove:listItem',l.j),a.modelToView.on('remove',l.i,{priority:'low'}),r.modelToView.on('changeAttribute:indent:listItem',l.f),a.modelToView.on('changeAttribute:indent:listItem',l.f),a.viewToModel.on('element:ul',l.a,{priority:'high'}),a.viewToModel.on('element:ol',l.a,{priority:'high'}),a.viewToModel.on('element:li',l.b,{priority:'high'}),a.viewToModel.on('element:li',l.l),a.on('insertContent',l.d,{priority:'high'}),e.commands.add('numberedList',new o.a(e,'numbered')),e.commands.add('bulletedList',new o.a(e,'bulleted')),e.commands.add('indentList',new i.a(e,'forward')),e.commands.add('outdentList',new i.a(e,'backward'))}}t.a=d},function(t,a,n){'use strict';function o(e,t,a){const n=t?e[0]:e[e.length-1];if(n.is('listItem'))for(let o=n[t?'previousSibling':'nextSibling'],i=n.getAttribute('indent');o&&o.is('listItem')&&o.getAttribute('indent')>=a;)i>o.getAttribute('indent')&&(i=o.getAttribute('indent')),o.getAttribute('indent')==i&&e[t?'unshift':'push'](o),o=o[t?'previousSibling':'nextSibling']}function i(e,t){return t.check({name:'listItem',attributes:['type','indent'],inside:s.a.createBefore(e)})}var r=n(11),s=n(1),l=n(63);class d extends r.a{constructor(e,t){super(e),this.type='bulleted'==t?'bulleted':'numbered'}refresh(){this.value=this._getValue(),this.isEnabled=this._checkEnabled()}execute(t={}){const a=this.editor.document,n=Array.from(a.selection.getSelectedBlocks()).filter((e)=>i(e,a.schema)),r=!0===this.value;a.enqueueChanges(()=>{const i=t.batch||a.batch();if(r){let t=n[n.length-1].nextSibling,a=e,o=[];for(;t&&'listItem'==t.name&&0!==t.getAttribute('indent');){const e=t.getAttribute('indent');e<a&&(a=e);const n=e-a;o.push({element:t,indent:n}),t=t.nextSibling}o=o.reverse();for(const e of o)i.setAttribute(e.element,'indent',e.indent)}if(!r){let t=e;for(const e of n)e.is('listItem')&&e.getAttribute('indent')<t&&(t=e.getAttribute('indent'));t=0===t?1:t,o(n,!0,t),o(n,!1,t)}for(const e of n.reverse())r&&'listItem'==e.name?i.rename(e,'paragraph'):r||'listItem'==e.name?r||'listItem'!=e.name||e.getAttribute('type')==this.type||i.setAttribute(e,'type',this.type):i.setAttribute(e,'type',this.type).setAttribute(e,'indent',0).rename(e,'listItem')})}_getValue(){const e=Object(l.a)(this.editor.document.selection.getSelectedBlocks());return!!e&&e.is('listItem')&&e.getAttribute('type')==this.type}_checkEnabled(){if(this.value)return!0;const e=this.editor.document.selection,t=this.editor.document.schema,a=Object(l.a)(e.getSelectedBlocks());return!!a&&i(a,t)}}a.a=d},function(e,t,a){'use strict';function n(e,t){const a=o(e,!1);if(a)return void t.setAttribute(e,'type',a.getAttribute('type'));const n=o(e,!0);n&&t.setAttribute(e,'type',n.getAttribute('type'))}function o(e,t){for(let a=e[t?'nextSibling':'previousSibling'];a&&a.is('listItem')&&a.getAttribute('indent')>=e.getAttribute('indent');){if(a.getAttribute('indent')==e.getAttribute('indent'))return a;a=a[t?'nextSibling':'previousSibling']}return null}var i=a(11),r=a(63);class s extends i.a{constructor(e,t){super(e),this._indentBy='forward'==t?1:-1}refresh(){this.isEnabled=this._checkEnabled()}execute(){const e=this.editor.document,t=e.batch();let a=Array.from(e.selection.getSelectedBlocks());e.enqueueChanges(()=>{const e=a[a.length-1];for(let t=e.nextSibling;t&&'listItem'==t.name&&t.getAttribute('indent')>e.getAttribute('indent');)a.push(t),t=t.nextSibling;0>this._indentBy&&(a=a.reverse());for(const e of a){const a=e.getAttribute('indent')+this._indentBy;0>a?t.rename(e,'paragraph'):t.setAttribute(e,'indent',a)}0>this._indentBy&&(a=a.reverse());for(const e of a)n(e,t)})}_checkEnabled(){const e=Object(r.a)(this.editor.document.selection.getSelectedBlocks());if(!e||!e.is('listItem'))return!1;if(0<this._indentBy){const t=e.getAttribute('indent'),a=e.getAttribute('type');for(let n=e.previousSibling;n&&n.is('listItem')&&n.getAttribute('indent')>=t;){if(n.getAttribute('indent')==t)return n.getAttribute('type')==a;n=n.previousSibling}return!1}return!0}}t.a=s},function(e,t,a){'use strict';function n(e,t,a){let n=e.nodeAfter;n&&'listItem'==n.name&&t.enqueueChanges(()=>{const e=n.previousSibling,t=e&&e.is('listItem')?e.getAttribute('indent')+1:0;let o=n.getAttribute('indent')-t;const i=[];for(;n&&'listItem'==n.name&&n.getAttribute('indent')>t;){o>n.getAttribute('indent')&&(o=n.getAttribute('indent'));const e=n.getAttribute('indent')-o;i.push({item:n,indent:e}),n=n.nextSibling}if(0<i.length)for(const e of i.reverse())a.setAttribute(e.item,'indent',e.indent)})}function o(e,t,a,n){let o=e[t?'nodeBefore':'nodeAfter'];o&&o.is('listItem')&&0!==o.getAttribute('indent')&&a.enqueueChanges(()=>{const e=c(o,!t);if(e&&e!=o)for(const a=e.getAttribute('indent'),i=e.getAttribute('type');o&&o.is('listItem')&&o.getAttribute('indent')>=a;)o.getAttribute('type')!=i&&o.getAttribute('indent')==a&&n.setAttribute(o,'type',i),o=o[t?'previousSibling':'nextSibling']})}function i(e,t){const a='numbered'==e.getAttribute('type')?'ol':'ul',n=new u.a,o=new b.a(a,null);return o.appendChildren(n),t.bindElements(e,n),n}function r(e,t){const a=t.getNext?'nextSibling':'previousSibling',n=t.getNext?'nodeAfter':'nodeBefore',o=!!t.checkAllSiblings,i=!!t.sameIndent,r=!!t.biggerIndent,s=!!t.smallerIndent,l=!!t.isMapped,d=e instanceof g.a?e.getAttribute('indent'):t.indent;for(let c=e instanceof g.a?e[a]:e[n];c&&'listItem'==c.name;){const e=c.getAttribute('indent');if(i&&d==e||r&&d<e||s&&d>e){if(!l||t.mapper.toViewElement(c))return c;c=c[a];continue}if(!o)return null;c=c[a]}return null}function s(e,t){return e&&t&&('ul'==e.name||'ol'==e.name)&&e.name==t.name?w.a.mergeContainers(_.a.createAfter(e)):null}function l(e,t,a,n){const o=t.parent;let i=r(e,{sameIndent:!0,smallerIndent:!0,checkAllSiblings:!0}),l;if(i&&i.getAttribute('indent')==e.getAttribute('indent')){const e=a.toViewElement(i);l=w.a.breakContainer(_.a.createAfter(e))}else i=e.previousSibling,l=i&&'listItem'==i.name?i.getAttribute('indent')<e.getAttribute('indent')?a.toViewPosition(f.a.createAt(i,'end')):n.parent.is('ul')||n.parent.is('ol')?w.a.breakContainer(n):n:a.toViewPosition(f.a.createBefore(e));l=m(l),w.a.insert(l,o);const d=r(e,{biggerIndent:!0,getNext:!0,isMapped:!0,mapper:a});if(d){const e=a.toViewElement(d);w.a.breakContainer(_.a.createBefore(e));const n=_.a.createBefore(e.parent),o=c(d,!1),i=a.toViewElement(o),r=w.a.breakContainer(_.a.createAfter(i)),s=new k.a(n,r),l=_.a.createAt(t,'end');w.a.move(s,l)}s(o,o.nextSibling),s(o.previousSibling,o)}function d(e,t,a,n,o){const i=r(t,{sameIndent:!0,smallerIndent:!0,checkAllSiblings:!0,indent:e}),l=i?i.getAttribute('indent'):null;let d;if(!i)d=a;else if(l==e){const e=o.toViewElement(i).parent;d=_.a.createAfter(e)}else{const e=f.a.createAt(i,'end');d=o.toViewPosition(e)}d=m(d);for(const i of[...n.getChildren()])(i.is('ul')||i.is('ol'))&&(d=w.a.move(k.a.createOn(i),d).end,s(i,i.nextSibling),s(i.previousSibling,i))}function c(e,t){const a=e.getAttribute('indent'),n=t?'previousSibling':'nextSibling';let o=e;for(;e[n]&&e[n].is('listItem')&&e[n].getAttribute('indent')>=a;)e=e[n],e.getAttribute('indent')==a&&(o=e);return o}function m(e){return e.getLastMatchingPosition((e)=>e.item.is('uiElement'))}t.h=function(e,t,a,n){if(a.test(t.item,'insert')&&a.test(t.item,'addAttribute:type')&&a.test(t.item,'addAttribute:indent')){a.consume(t.item,'insert'),a.consume(t.item,'addAttribute:type'),a.consume(t.item,'addAttribute:indent');const e=t.item,o=i(e,n.mapper),r=n.mapper.toViewPosition(f.a.createBefore(e));l(e,o,n.mapper,r)}},t.g=function(e,t,a,n){if(!a.consume(t.item,'changeAttribute:type'))return;const o=n.mapper.toViewElement(t.item);w.a.breakContainer(_.a.createBefore(o)),w.a.breakContainer(_.a.createAfter(o));let i=o.parent;const r='numbered'==t.attributeNewValue?'ol':'ul';i=w.a.rename(i,r),s(i,i.nextSibling),s(i.previousSibling,i)},t.j=function(e,t,a,n){if(!a.consume(t.item,'remove'))return;let o=n.mapper.toViewPosition(t.sourcePosition);o=o.getLastMatchingPosition((e)=>!e.item.is('li'));const i=o.nodeAfter;w.a.breakContainer(_.a.createBefore(i)),w.a.breakContainer(_.a.createAfter(i));const r=i.parent,l=r.previousSibling,c=k.a.createOn(r);w.a.remove(c),l&&l.nextSibling&&s(l,l.nextSibling),d(t.item.getAttribute('indent')+1,t.sourcePosition,c.start,i,n.mapper),'$graveyard'==t.item.root.rootName&&n.mapper.unbindModelElement(t.item)},t.f=function(e,t,a,n){if(!a.consume(t.item,'changeAttribute:indent'))return;const o=n.mapper.toViewElement(t.item);w.a.breakContainer(_.a.createBefore(o)),w.a.breakContainer(_.a.createAfter(o));const i=o.parent,r=i.previousSibling,c=k.a.createOn(i);w.a.remove(c);let m;r&&r.nextSibling&&(m=s(r,r.nextSibling)),m||(m=c.start),d(t.attributeOldValue+1,t.range.start,c.start,o,n.mapper),l(t.item,o,n.mapper,m)},t.k=function(e,t,a,n){if('listItem'!=t.item.name){let e=n.mapper.toViewPosition(t.range.start);const a=[];for(;('ul'==e.parent.name||'ol'==e.parent.name)&&(e=w.a.breakContainer(e),'li'==e.parent.name);){const t=e,n=_.a.createAt(e.parent,'end');if(!t.isEqual(n)){const e=w.a.remove(new k.a(t,n));a.push(e)}e=_.a.createAfter(e.parent)}if(0<a.length){for(let t=0;t<a.length;t++){const n=e.nodeBefore,o=w.a.insert(e,a[t]);if(e=o.end,0<t){const t=s(n,n.nextSibling);t&&t.parent==n&&e.offset--}}s(e.nodeBefore,e.nodeAfter)}}},t.i=function(e,t,a,n){if(!t.item.is('listItem')){const e=n.mapper.toViewPosition(t.sourcePosition),a=e.nodeBefore,o=e.nodeAfter;s(a,o)}},t.l=function(e,t,a,n){if(a.consume(t.input,{name:!0})){const e=new g.a('listItem');t.indent=t.indent?t.indent:0,e.setAttribute('indent',t.indent);const o=t.input.parent&&'ol'==t.input.parent.name?'numbered':'bulleted';e.setAttribute('type',o),t.context.push(e),t.indent++;const i=new p.a;i.appendChildren(e);for(const o of t.input.getChildren()){const r=n.convertItem(o,a,t);'ul'==o.name||'ol'==o.name?i.appendChildren(Array.from(r.getChildren())):h.a.insert(f.a.createAt(e,'end'),r)}t.indent--,t.context.pop(),t.output=i}},t.a=function(e,t,a){if(a.test(t.input,{name:!0})){const e=Array.from(t.input.getChildren());for(const t of e)t.is('li')||t.remove()}},t.b=function(e,t,a){if(a.test(t.input,{name:!0})){if(0===t.input.childCount)return;const e=[...t.input.getChildren()];let a=!1,n=!0;for(const t of e)!a||t.is('ul')||t.is('ol')||t.remove(),t.is('text')?(n&&(t.data=t.data.replace(/^\s+/,'')),(!t.nextSibling||t.nextSibling.is('ul')||t.nextSibling.is('ol'))&&(t.data=t.data.replace(/\s+$/,''))):(t.is('ul')||t.is('ol'))&&(a=!0),n=!1}},t.e=function(e,t){const a=t.modelPosition.nodeBefore;if(a&&a.is('listItem')){const e=t.mapper.toViewElement(a),n=e.getAncestors().find((e)=>e.is('ul')||e.is('ol')),o=new y.a({startPosition:_.a.createAt(e,0)});for(const e of o)if('elementStart'==e.type&&e.item.is('li')){t.viewPosition=e.previousPosition;break}else if('elementEnd'==e.type&&e.item==n){t.viewPosition=e.nextPosition;break}}},t.m=function(e,t){const a=t.viewPosition,n=a.parent,o=t.mapper;if('ul'==n.name||'ol'==n.name){if(!a.isAtEnd){const e=o.toModelElement(a.nodeAfter);t.modelPosition=f.a.createBefore(e)}else{const e=o.toModelElement(a.nodeBefore),n=o.getModelLength(a.nodeBefore);t.modelPosition=f.a.createBefore(e).getShiftedBy(n)}e.stop()}else if('li'==n.name&&a.nodeBefore&&('ul'==a.nodeBefore.name||'ol'==a.nodeBefore.name)){const i=o.toModelElement(n);let r=1,s=a.nodeBefore;for(;s&&(s.is('ul')||s.is('ol'));)r+=o.getModelLength(s),s=s.previousSibling;t.modelPosition=f.a.createBefore(i).getShiftedBy(r),e.stop()}},t.c=function(e){return(t,a,i,r)=>{if('transparent'!=r.type)if('remove'==a){const t=i.range.end.offset-i.range.start.offset,a=i.sourcePosition._getTransformedByInsertion(i.range.start,t,!0);n(a,e,r),o(a,!1,e,r)}else if('move'==a){const t=i.range.end.offset-i.range.start.offset,a=i.sourcePosition._getTransformedByInsertion(i.range.start,t,!0);n(a,e,r),o(a,!1,e,r),n(i.range.start,e,r),o(i.range.start,!1,e,r),n(i.range.end,e,r),o(i.range.end,!0,e,r)}else if('rename'==a&&'listItem'==i.oldName&&'listItem'!=i.newName){const t=i.element;e.enqueueChanges(()=>{r.removeAttribute(t,'indent').removeAttribute(t,'type')});const a=f.a.createAfter(i.element);n(a,e,r)}else'insert'==a&&(n(i.range.start,e,r),o(i.range.start,!1,e,r),n(i.range.end,e,r),o(i.range.end,!0,e,r))}},t.d=function(e,[t,a]){let n=t.is('documentFragment')?t.getChild(0):t;if(n&&n.is('listItem')){const e=a.getFirstPosition();let t=null;if(e.parent.is('listItem')?t=e.parent:e.nodeBefore&&e.nodeBefore.is('listItem')&&(t=e.nodeBefore),t){const e=t.getAttribute('indent');if(0<e)for(;n&&n.is('listItem');)n.setAttribute('indent',n.getAttribute('indent')+e),n=n.nextSibling}}};var u=a(563),p=a(39),g=a(5),f=a(1),h=a(23),b=a(47),_=a(22),k=a(38),y=a(68),w=a(93)},function(e,t,a){'use strict';function n(){const e=!this.isEmpty&&('ul'==this.getChild(0).name||'ol'==this.getChild(0).name);return this.isEmpty||e?0:null}var o=a(47);class i extends o.a{constructor(e,t){super('li',e,t),this.getFillerOffset=n}}t.a=i},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 17h10v-1H7v1zM6 4v1h13V4H6zm1 6v1h11v-1H7zM2 2.5c0 .277.223.5.5.5H3v3.5a.499.499 0 1 0 1 0v-4c0-.277-.223-.5-.5-.5h-1c-.277 0-.5.223-.5.5zM2.5 8a.499.499 0 1 0 0 1H4v1H2.5c-.277 0-.5.223-.5.5v2c0 .277.223.5.5.5h2a.499.499 0 1 0 0-1H3v-1h1.5a.46.46 0 0 0 .188-.031.45.45 0 0 0 .28-.281A.461.461 0 0 0 5 10.5v-2a.46.46 0 0 0-.031-.187.45.45 0 0 0-.282-.282.463.463 0 0 0-.125-.03H2.5V8zm2.352 10.853a.493.493 0 0 0 .148-.35v-4.005A.493.493 0 0 0 4.505 14h-2.01a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H4v1H2.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H4v1H2.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5h2.01a.49.49 0 0 0 .351-.146z" fill="#454545" fill-rule="evenodd"/></svg>'},function(e){e.exports='<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6 16v1h10v-1H6zM6 4v1h12V4H6zm0 6v1h11v-1H6zM1 4.5C1 3.672 1.666 3 2.5 3 3.328 3 4 3.666 4 4.5 4 5.328 3.334 6 2.5 6 1.672 6 1 5.334 1 4.5zm0 6C1 9.672 1.666 9 2.5 9c.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5zm0 6c0-.828.666-1.5 1.5-1.5.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5z" fill="#454545" fill-rule="evenodd"/></svg>'}])['default']});
//# sourceMappingURL=ckeditor.js.map

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_qoob__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sortablejs__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sortablejs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sortablejs__);



var bootstrap = function bootstrap() {
	var sortableContainers = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.find('.js-sortable');

	__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.each(sortableContainers, function (sortableContainer) {
		__WEBPACK_IMPORTED_MODULE_1_sortablejs___default.a.create(sortableContainer, {
			animation: 250,
			handle: ".js-sortable-tile",
			draggable: ".js-sortable-item",
			onUpdate: function onUpdate(event) {
				var sortableInput = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.children(sortableContainer, '.js-sortable-input');
				if (sortableInput.length >= 1) {
					var promises = [];
					window.laramin.loading = true;
					__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.each(sortableInput, function (sortableInput, index) {
						var promise = axios.post(sortableInput.form.action, {
							_method: 'PATCH',
							order: index + 1
						});
						promises.push(promise);
					});
					Promise.all(promises).then(function () {
						window.laramin.loading = false;
					});
				}
			}
		});
	});
};

/* harmony default export */ __webpack_exports__["a"] = (bootstrap);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**!
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */

(function sortableModule(factory) {
	"use strict";

	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else if (typeof module != "undefined" && typeof module.exports != "undefined") {
		module.exports = factory();
	}
	else {
		/* jshint sub:true */
		window["Sortable"] = factory();
	}
})(function sortableFactory() {
	"use strict";

	if (typeof window == "undefined" || !window.document) {
		return function sortableError() {
			throw new Error("Sortable.js requires a window with a document");
		};
	}

	var dragEl,
		parentEl,
		ghostEl,
		cloneEl,
		rootEl,
		nextEl,
		lastDownEl,

		scrollEl,
		scrollParentEl,
		scrollCustomFn,

		lastEl,
		lastCSS,
		lastParentCSS,

		oldIndex,
		newIndex,

		activeGroup,
		putSortable,

		autoScroll = {},

		tapEvt,
		touchEvt,

		moved,

		/** @const */
		R_SPACE = /\s+/g,
		R_FLOAT = /left|right|inline/,

		expando = 'Sortable' + (new Date).getTime(),

		win = window,
		document = win.document,
		parseInt = win.parseInt,

		$ = win.jQuery || win.Zepto,
		Polymer = win.Polymer,

		captureMode = false,

		supportDraggable = !!('draggable' in document.createElement('div')),
		supportCssPointerEvents = (function (el) {
			// false when IE11
			if (!!navigator.userAgent.match(/Trident.*rv[ :]?11\./)) {
				return false;
			}
			el = document.createElement('x');
			el.style.cssText = 'pointer-events:auto';
			return el.style.pointerEvents === 'auto';
		})(),

		_silent = false,

		abs = Math.abs,
		min = Math.min,

		savedInputChecked = [],
		touchDragOverListeners = [],

		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
			// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
			if (rootEl && options.scroll) {
				var _this = rootEl[expando],
					el,
					rect,
					sens = options.scrollSensitivity,
					speed = options.scrollSpeed,

					x = evt.clientX,
					y = evt.clientY,

					winWidth = window.innerWidth,
					winHeight = window.innerHeight,

					vx,
					vy,

					scrollOffsetX,
					scrollOffsetY
				;

				// Delect scrollEl
				if (scrollParentEl !== rootEl) {
					scrollEl = options.scroll;
					scrollParentEl = rootEl;
					scrollCustomFn = options.scrollFn;

					if (scrollEl === true) {
						scrollEl = rootEl;

						do {
							if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||
								(scrollEl.offsetHeight < scrollEl.scrollHeight)
							) {
								break;
							}
							/* jshint boss:true */
						} while (scrollEl = scrollEl.parentNode);
					}
				}

				if (scrollEl) {
					el = scrollEl;
					rect = scrollEl.getBoundingClientRect();
					vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
					vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
				}


				if (!(vx || vy)) {
					vx = (winWidth - x <= sens) - (x <= sens);
					vy = (winHeight - y <= sens) - (y <= sens);

					/* jshint expr:true */
					(vx || vy) && (el = win);
				}


				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
					autoScroll.el = el;
					autoScroll.vx = vx;
					autoScroll.vy = vy;

					clearInterval(autoScroll.pid);

					if (el) {
						autoScroll.pid = setInterval(function () {
							scrollOffsetY = vy ? vy * speed : 0;
							scrollOffsetX = vx ? vx * speed : 0;

							if ('function' === typeof(scrollCustomFn)) {
								return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);
							}

							if (el === win) {
								win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
							} else {
								el.scrollTop += scrollOffsetY;
								el.scrollLeft += scrollOffsetX;
							}
						}, 24);
					}
				}
			}
		}, 30),

		_prepareGroup = function (options) {
			function toFn(value, pull) {
				if (value === void 0 || value === true) {
					value = group.name;
				}

				if (typeof value === 'function') {
					return value;
				} else {
					return function (to, from) {
						var fromGroup = from.options.group.name;

						return pull
							? value
							: value && (value.join
								? value.indexOf(fromGroup) > -1
								: (fromGroup == value)
							);
					};
				}
			}

			var group = {};
			var originalGroup = options.group;

			if (!originalGroup || typeof originalGroup != 'object') {
				originalGroup = {name: originalGroup};
			}

			group.name = originalGroup.name;
			group.checkPull = toFn(originalGroup.pull, true);
			group.checkPut = toFn(originalGroup.put);
			group.revertClone = originalGroup.revertClone;

			options.group = group;
		}
	;


	/**
	 * @class  Sortable
	 * @param  {HTMLElement}  el
	 * @param  {Object}       [options]
	 */
	function Sortable(el, options) {
		if (!(el && el.nodeType && el.nodeType === 1)) {
			throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
		}

		this.el = el; // root element
		this.options = options = _extend({}, options);


		// Export instance
		el[expando] = this;

		// Default options
		var defaults = {
			group: Math.random(),
			sort: true,
			disabled: false,
			store: null,
			handle: null,
			scroll: true,
			scrollSensitivity: 30,
			scrollSpeed: 10,
			draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
			ghostClass: 'sortable-ghost',
			chosenClass: 'sortable-chosen',
			dragClass: 'sortable-drag',
			ignore: 'a, img',
			filter: null,
			preventOnFilter: true,
			animation: 0,
			setData: function (dataTransfer, dragEl) {
				dataTransfer.setData('Text', dragEl.textContent);
			},
			dropBubble: false,
			dragoverBubble: false,
			dataIdAttr: 'data-id',
			delay: 0,
			forceFallback: false,
			fallbackClass: 'sortable-fallback',
			fallbackOnBody: false,
			fallbackTolerance: 0,
			fallbackOffset: {x: 0, y: 0}
		};


		// Set default options
		for (var name in defaults) {
			!(name in options) && (options[name] = defaults[name]);
		}

		_prepareGroup(options);

		// Bind all private methods
		for (var fn in this) {
			if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
				this[fn] = this[fn].bind(this);
			}
		}

		// Setup drag mode
		this.nativeDraggable = options.forceFallback ? false : supportDraggable;

		// Bind events
		_on(el, 'mousedown', this._onTapStart);
		_on(el, 'touchstart', this._onTapStart);
		_on(el, 'pointerdown', this._onTapStart);

		if (this.nativeDraggable) {
			_on(el, 'dragover', this);
			_on(el, 'dragenter', this);
		}

		touchDragOverListeners.push(this._onDragOver);

		// Restore sorting
		options.store && this.sort(options.store.get(this));
	}


	Sortable.prototype = /** @lends Sortable.prototype */ {
		constructor: Sortable,

		_onTapStart: function (/** Event|TouchEvent */evt) {
			var _this = this,
				el = this.el,
				options = this.options,
				preventOnFilter = options.preventOnFilter,
				type = evt.type,
				touch = evt.touches && evt.touches[0],
				target = (touch || evt).target,
				originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0]) || target,
				filter = options.filter,
				startIndex;

			_saveInputCheckedState(el);


			// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
			if (dragEl) {
				return;
			}

			if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
				return; // only left button or enabled
			}


			target = _closest(target, options.draggable, el);

			if (!target) {
				return;
			}

			if (lastDownEl === target) {
				// Ignoring duplicate `down`
				return;
			}

			// Get the index of the dragged element within its parent
			startIndex = _index(target, options.draggable);

			// Check filter
			if (typeof filter === 'function') {
				if (filter.call(this, evt, target, this)) {
					_dispatchEvent(_this, originalTarget, 'filter', target, el, startIndex);
					preventOnFilter && evt.preventDefault();
					return; // cancel dnd
				}
			}
			else if (filter) {
				filter = filter.split(',').some(function (criteria) {
					criteria = _closest(originalTarget, criteria.trim(), el);

					if (criteria) {
						_dispatchEvent(_this, criteria, 'filter', target, el, startIndex);
						return true;
					}
				});

				if (filter) {
					preventOnFilter && evt.preventDefault();
					return; // cancel dnd
				}
			}

			if (options.handle && !_closest(originalTarget, options.handle, el)) {
				return;
			}

			// Prepare `dragstart`
			this._prepareDragStart(evt, touch, target, startIndex);
		},

		_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
			var _this = this,
				el = _this.el,
				options = _this.options,
				ownerDocument = el.ownerDocument,
				dragStartFn;

			if (target && !dragEl && (target.parentNode === el)) {
				tapEvt = evt;

				rootEl = el;
				dragEl = target;
				parentEl = dragEl.parentNode;
				nextEl = dragEl.nextSibling;
				lastDownEl = target;
				activeGroup = options.group;
				oldIndex = startIndex;

				this._lastX = (touch || evt).clientX;
				this._lastY = (touch || evt).clientY;

				dragEl.style['will-change'] = 'transform';

				dragStartFn = function () {
					// Delayed drag has been triggered
					// we can re-enable the events: touchmove/mousemove
					_this._disableDelayedDrag();

					// Make the element draggable
					dragEl.draggable = _this.nativeDraggable;

					// Chosen item
					_toggleClass(dragEl, options.chosenClass, true);

					// Bind the events: dragstart/dragend
					_this._triggerDragStart(evt, touch);

					// Drag start event
					_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, oldIndex);
				};

				// Disable "draggable"
				options.ignore.split(',').forEach(function (criteria) {
					_find(dragEl, criteria.trim(), _disableDraggable);
				});

				_on(ownerDocument, 'mouseup', _this._onDrop);
				_on(ownerDocument, 'touchend', _this._onDrop);
				_on(ownerDocument, 'touchcancel', _this._onDrop);
				_on(ownerDocument, 'pointercancel', _this._onDrop);
				_on(ownerDocument, 'selectstart', _this);

				if (options.delay) {
					// If the user moves the pointer or let go the click or touch
					// before the delay has been reached:
					// disable the delayed drag
					_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
					_on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchmove', _this._disableDelayedDrag);
					_on(ownerDocument, 'pointermove', _this._disableDelayedDrag);

					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
				} else {
					dragStartFn();
				}


			}
		},

		_disableDelayedDrag: function () {
			var ownerDocument = this.el.ownerDocument;

			clearTimeout(this._dragStartTimer);
			_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
			_off(ownerDocument, 'touchend', this._disableDelayedDrag);
			_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
			_off(ownerDocument, 'mousemove', this._disableDelayedDrag);
			_off(ownerDocument, 'touchmove', this._disableDelayedDrag);
			_off(ownerDocument, 'pointermove', this._disableDelayedDrag);
		},

		_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
			touch = touch || (evt.pointerType == 'touch' ? evt : null);

			if (touch) {
				// Touch device support
				tapEvt = {
					target: dragEl,
					clientX: touch.clientX,
					clientY: touch.clientY
				};

				this._onDragStart(tapEvt, 'touch');
			}
			else if (!this.nativeDraggable) {
				this._onDragStart(tapEvt, true);
			}
			else {
				_on(dragEl, 'dragend', this);
				_on(rootEl, 'dragstart', this._onDragStart);
			}

			try {
				if (document.selection) {
					// Timeout neccessary for IE9
					setTimeout(function () {
						document.selection.empty();
					});
				} else {
					window.getSelection().removeAllRanges();
				}
			} catch (err) {
			}
		},

		_dragStarted: function () {
			if (rootEl && dragEl) {
				var options = this.options;

				// Apply effect
				_toggleClass(dragEl, options.ghostClass, true);
				_toggleClass(dragEl, options.dragClass, false);

				Sortable.active = this;

				// Drag start event
				_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
			} else {
				this._nulling();
			}
		},

		_emulateDragOver: function () {
			if (touchEvt) {
				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
					return;
				}

				this._lastX = touchEvt.clientX;
				this._lastY = touchEvt.clientY;

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', 'none');
				}

				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
					parent = target,
					i = touchDragOverListeners.length;

				if (parent) {
					do {
						if (parent[expando]) {
							while (i--) {
								touchDragOverListeners[i]({
									clientX: touchEvt.clientX,
									clientY: touchEvt.clientY,
									target: target,
									rootEl: parent
								});
							}

							break;
						}

						target = parent; // store last element
					}
					/* jshint boss:true */
					while (parent = parent.parentNode);
				}

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', '');
				}
			}
		},


		_onTouchMove: function (/**TouchEvent*/evt) {
			if (tapEvt) {
				var	options = this.options,
					fallbackTolerance = options.fallbackTolerance,
					fallbackOffset = options.fallbackOffset,
					touch = evt.touches ? evt.touches[0] : evt,
					dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,
					dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,
					translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

				// only set the status to dragging, when we are actually dragging
				if (!Sortable.active) {
					if (fallbackTolerance &&
						min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
					) {
						return;
					}

					this._dragStarted();
				}

				// as well as creating the ghost element on the document body
				this._appendGhost();

				moved = true;
				touchEvt = touch;

				_css(ghostEl, 'webkitTransform', translate3d);
				_css(ghostEl, 'mozTransform', translate3d);
				_css(ghostEl, 'msTransform', translate3d);
				_css(ghostEl, 'transform', translate3d);

				evt.preventDefault();
			}
		},

		_appendGhost: function () {
			if (!ghostEl) {
				var rect = dragEl.getBoundingClientRect(),
					css = _css(dragEl),
					options = this.options,
					ghostRect;

				ghostEl = dragEl.cloneNode(true);

				_toggleClass(ghostEl, options.ghostClass, false);
				_toggleClass(ghostEl, options.fallbackClass, true);
				_toggleClass(ghostEl, options.dragClass, true);

				_css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
				_css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
				_css(ghostEl, 'width', rect.width);
				_css(ghostEl, 'height', rect.height);
				_css(ghostEl, 'opacity', '0.8');
				_css(ghostEl, 'position', 'fixed');
				_css(ghostEl, 'zIndex', '100000');
				_css(ghostEl, 'pointerEvents', 'none');

				options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);

				// Fixing dimensions.
				ghostRect = ghostEl.getBoundingClientRect();
				_css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
				_css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
			}
		},

		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {
			var dataTransfer = evt.dataTransfer,
				options = this.options;

			this._offUpEvents();

			if (activeGroup.checkPull(this, this, dragEl, evt)) {
				cloneEl = _clone(dragEl);

				cloneEl.draggable = false;
				cloneEl.style['will-change'] = '';

				_css(cloneEl, 'display', 'none');
				_toggleClass(cloneEl, this.options.chosenClass, false);

				rootEl.insertBefore(cloneEl, dragEl);
				_dispatchEvent(this, rootEl, 'clone', dragEl);
			}

			_toggleClass(dragEl, options.dragClass, true);

			if (useFallback) {
				if (useFallback === 'touch') {
					// Bind touch events
					_on(document, 'touchmove', this._onTouchMove);
					_on(document, 'touchend', this._onDrop);
					_on(document, 'touchcancel', this._onDrop);
					_on(document, 'pointermove', this._onTouchMove);
					_on(document, 'pointerup', this._onDrop);
				} else {
					// Old brwoser
					_on(document, 'mousemove', this._onTouchMove);
					_on(document, 'mouseup', this._onDrop);
				}

				this._loopId = setInterval(this._emulateDragOver, 50);
			}
			else {
				if (dataTransfer) {
					dataTransfer.effectAllowed = 'move';
					options.setData && options.setData.call(this, dataTransfer, dragEl);
				}

				_on(document, 'drop', this);
				setTimeout(this._dragStarted, 0);
			}
		},

		_onDragOver: function (/**Event*/evt) {
			var el = this.el,
				target,
				dragRect,
				targetRect,
				revert,
				options = this.options,
				group = options.group,
				activeSortable = Sortable.active,
				isOwner = (activeGroup === group),
				isMovingBetweenSortable = false,
				canSort = options.sort;

			if (evt.preventDefault !== void 0) {
				evt.preventDefault();
				!options.dragoverBubble && evt.stopPropagation();
			}

			if (dragEl.animated) {
				return;
			}

			moved = true;

			if (activeSortable && !options.disabled &&
				(isOwner
					? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
					: (
						putSortable === this ||
						(
							(activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
							group.checkPut(this, activeSortable, dragEl, evt)
						)
					)
				) &&
				(evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback
			) {
				// Smart auto-scrolling
				_autoScroll(evt, options, this.el);

				if (_silent) {
					return;
				}

				target = _closest(evt.target, options.draggable, el);
				dragRect = dragEl.getBoundingClientRect();

				if (putSortable !== this) {
					putSortable = this;
					isMovingBetweenSortable = true;
				}

				if (revert) {
					_cloneHide(activeSortable, true);
					parentEl = rootEl; // actualization

					if (cloneEl || nextEl) {
						rootEl.insertBefore(dragEl, cloneEl || nextEl);
					}
					else if (!canSort) {
						rootEl.appendChild(dragEl);
					}

					return;
				}


				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
					(el === evt.target) && (_ghostIsLast(el, evt))
				) {
					//assign target only if condition is true
					if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
						target = el.lastElementChild;
					}

					if (target) {
						if (target.animated) {
							return;
						}

						targetRect = target.getBoundingClientRect();
					}

					_cloneHide(activeSortable, isOwner);

					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {
						if (!dragEl.contains(el)) {
							el.appendChild(dragEl);
							parentEl = el; // actualization
						}

						this._animate(dragRect, dragEl);
						target && this._animate(targetRect, target);
					}
				}
				else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {
					if (lastEl !== target) {
						lastEl = target;
						lastCSS = _css(target);
						lastParentCSS = _css(target.parentNode);
					}

					targetRect = target.getBoundingClientRect();

					var width = targetRect.right - targetRect.left,
						height = targetRect.bottom - targetRect.top,
						floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)
							|| (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),
						isWide = (target.offsetWidth > dragEl.offsetWidth),
						isLong = (target.offsetHeight > dragEl.offsetHeight),
						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
						nextSibling = target.nextElementSibling,
						after = false
					;

					if (floating) {
						var elTop = dragEl.offsetTop,
							tgTop = target.offsetTop;

						if (elTop === tgTop) {
							after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
						}
						else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {
							after = (evt.clientY - targetRect.top) / height > 0.5;
						} else {
							after = tgTop > elTop;
						}
						} else if (!isMovingBetweenSortable) {
						after = (nextSibling !== dragEl) && !isLong || halfway && isLong;
					}

					var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

					if (moveVector !== false) {
						if (moveVector === 1 || moveVector === -1) {
							after = (moveVector === 1);
						}

						_silent = true;
						setTimeout(_unsilent, 30);

						_cloneHide(activeSortable, isOwner);

						if (!dragEl.contains(el)) {
							if (after && !nextSibling) {
								el.appendChild(dragEl);
							} else {
								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
							}
						}

						parentEl = dragEl.parentNode; // actualization

						this._animate(dragRect, dragEl);
						this._animate(targetRect, target);
					}
				}
			}
		},

		_animate: function (prevRect, target) {
			var ms = this.options.animation;

			if (ms) {
				var currentRect = target.getBoundingClientRect();

				if (prevRect.nodeType === 1) {
					prevRect = prevRect.getBoundingClientRect();
				}

				_css(target, 'transition', 'none');
				_css(target, 'transform', 'translate3d('
					+ (prevRect.left - currentRect.left) + 'px,'
					+ (prevRect.top - currentRect.top) + 'px,0)'
				);

				target.offsetWidth; // repaint

				_css(target, 'transition', 'all ' + ms + 'ms');
				_css(target, 'transform', 'translate3d(0,0,0)');

				clearTimeout(target.animated);
				target.animated = setTimeout(function () {
					_css(target, 'transition', '');
					_css(target, 'transform', '');
					target.animated = false;
				}, ms);
			}
		},

		_offUpEvents: function () {
			var ownerDocument = this.el.ownerDocument;

			_off(document, 'touchmove', this._onTouchMove);
			_off(document, 'pointermove', this._onTouchMove);
			_off(ownerDocument, 'mouseup', this._onDrop);
			_off(ownerDocument, 'touchend', this._onDrop);
			_off(ownerDocument, 'pointerup', this._onDrop);
			_off(ownerDocument, 'touchcancel', this._onDrop);
			_off(ownerDocument, 'pointercancel', this._onDrop);
			_off(ownerDocument, 'selectstart', this);
		},

		_onDrop: function (/**Event*/evt) {
			var el = this.el,
				options = this.options;

			clearInterval(this._loopId);
			clearInterval(autoScroll.pid);
			clearTimeout(this._dragStartTimer);

			// Unbind events
			_off(document, 'mousemove', this._onTouchMove);

			if (this.nativeDraggable) {
				_off(document, 'drop', this);
				_off(el, 'dragstart', this._onDragStart);
			}

			this._offUpEvents();

			if (evt) {
				if (moved) {
					evt.preventDefault();
					!options.dropBubble && evt.stopPropagation();
				}

				ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

				if (rootEl === parentEl || Sortable.active.lastPullMode !== 'clone') {
					// Remove clone
					cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
				}

				if (dragEl) {
					if (this.nativeDraggable) {
						_off(dragEl, 'dragend', this);
					}

					_disableDraggable(dragEl);
					dragEl.style['will-change'] = '';

					// Remove class's
					_toggleClass(dragEl, this.options.ghostClass, false);
					_toggleClass(dragEl, this.options.chosenClass, false);

					// Drag stop event
					_dispatchEvent(this, rootEl, 'unchoose', dragEl, rootEl, oldIndex);

					if (rootEl !== parentEl) {
						newIndex = _index(dragEl, options.draggable);

						if (newIndex >= 0) {
							// Add event
							_dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);

							// Remove event
							_dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);

							// drag from one list and drop into another
							_dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
						}
					}
					else {
						if (dragEl.nextSibling !== nextEl) {
							// Get the index of the dragged element within its parent
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// drag & drop within the same list
								_dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
								_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							}
						}
					}

					if (Sortable.active) {
						/* jshint eqnull:true */
						if (newIndex == null || newIndex === -1) {
							newIndex = oldIndex;
						}

						_dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);

						// Save sorting
						this.save();
					}
				}

			}

			this._nulling();
		},

		_nulling: function() {
			rootEl =
			dragEl =
			parentEl =
			ghostEl =
			nextEl =
			cloneEl =
			lastDownEl =

			scrollEl =
			scrollParentEl =

			tapEvt =
			touchEvt =

			moved =
			newIndex =

			lastEl =
			lastCSS =

			putSortable =
			activeGroup =
			Sortable.active = null;

			savedInputChecked.forEach(function (el) {
				el.checked = true;
			});
			savedInputChecked.length = 0;
		},

		handleEvent: function (/**Event*/evt) {
			switch (evt.type) {
				case 'drop':
				case 'dragend':
					this._onDrop(evt);
					break;

				case 'dragover':
				case 'dragenter':
					if (dragEl) {
						this._onDragOver(evt);
						_globalDragOver(evt);
					}
					break;

				case 'selectstart':
					evt.preventDefault();
					break;
			}
		},


		/**
		 * Serializes the item into an array of string.
		 * @returns {String[]}
		 */
		toArray: function () {
			var order = [],
				el,
				children = this.el.children,
				i = 0,
				n = children.length,
				options = this.options;

			for (; i < n; i++) {
				el = children[i];
				if (_closest(el, options.draggable, this.el)) {
					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
				}
			}

			return order;
		},


		/**
		 * Sorts the elements according to the array.
		 * @param  {String[]}  order  order of the items
		 */
		sort: function (order) {
			var items = {}, rootEl = this.el;

			this.toArray().forEach(function (id, i) {
				var el = rootEl.children[i];

				if (_closest(el, this.options.draggable, rootEl)) {
					items[id] = el;
				}
			}, this);

			order.forEach(function (id) {
				if (items[id]) {
					rootEl.removeChild(items[id]);
					rootEl.appendChild(items[id]);
				}
			});
		},


		/**
		 * Save the current sorting
		 */
		save: function () {
			var store = this.options.store;
			store && store.set(this);
		},


		/**
		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
		 * @param   {HTMLElement}  el
		 * @param   {String}       [selector]  default: `options.draggable`
		 * @returns {HTMLElement|null}
		 */
		closest: function (el, selector) {
			return _closest(el, selector || this.options.draggable, this.el);
		},


		/**
		 * Set/get option
		 * @param   {string} name
		 * @param   {*}      [value]
		 * @returns {*}
		 */
		option: function (name, value) {
			var options = this.options;

			if (value === void 0) {
				return options[name];
			} else {
				options[name] = value;

				if (name === 'group') {
					_prepareGroup(options);
				}
			}
		},


		/**
		 * Destroy
		 */
		destroy: function () {
			var el = this.el;

			el[expando] = null;

			_off(el, 'mousedown', this._onTapStart);
			_off(el, 'touchstart', this._onTapStart);
			_off(el, 'pointerdown', this._onTapStart);

			if (this.nativeDraggable) {
				_off(el, 'dragover', this);
				_off(el, 'dragenter', this);
			}

			// Remove draggable attributes
			Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
				el.removeAttribute('draggable');
			});

			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

			this._onDrop();

			this.el = el = null;
		}
	};


	function _cloneHide(sortable, state) {
		if (sortable.lastPullMode !== 'clone') {
			state = true;
		}

		if (cloneEl && (cloneEl.state !== state)) {
			_css(cloneEl, 'display', state ? 'none' : '');

			if (!state) {
				if (cloneEl.state) {
					if (sortable.options.group.revertClone) {
						rootEl.insertBefore(cloneEl, nextEl);
						sortable._animate(dragEl, cloneEl);
					} else {
						rootEl.insertBefore(cloneEl, dragEl);
					}
				}
			}

			cloneEl.state = state;
		}
	}


	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
		if (el) {
			ctx = ctx || document;

			do {
				if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
					return el;
				}
				/* jshint boss:true */
			} while (el = _getParentOrHost(el));
		}

		return null;
	}


	function _getParentOrHost(el) {
		var parent = el.host;

		return (parent && parent.nodeType) ? parent : el.parentNode;
	}


	function _globalDragOver(/**Event*/evt) {
		if (evt.dataTransfer) {
			evt.dataTransfer.dropEffect = 'move';
		}
		evt.preventDefault();
	}


	function _on(el, event, fn) {
		el.addEventListener(event, fn, captureMode);
	}


	function _off(el, event, fn) {
		el.removeEventListener(event, fn, captureMode);
	}


	function _toggleClass(el, name, state) {
		if (el) {
			if (el.classList) {
				el.classList[state ? 'add' : 'remove'](name);
			}
			else {
				var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
				el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
			}
		}
	}


	function _css(el, prop, val) {
		var style = el && el.style;

		if (style) {
			if (val === void 0) {
				if (document.defaultView && document.defaultView.getComputedStyle) {
					val = document.defaultView.getComputedStyle(el, '');
				}
				else if (el.currentStyle) {
					val = el.currentStyle;
				}

				return prop === void 0 ? val : val[prop];
			}
			else {
				if (!(prop in style)) {
					prop = '-webkit-' + prop;
				}

				style[prop] = val + (typeof val === 'string' ? '' : 'px');
			}
		}
	}


	function _find(ctx, tagName, iterator) {
		if (ctx) {
			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

			if (iterator) {
				for (; i < n; i++) {
					iterator(list[i], i);
				}
			}

			return list;
		}

		return [];
	}



	function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
		sortable = (sortable || rootEl[expando]);

		var evt = document.createEvent('Event'),
			options = sortable.options,
			onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);

		evt.initEvent(name, true, true);

		evt.to = rootEl;
		evt.from = fromEl || rootEl;
		evt.item = targetEl || rootEl;
		evt.clone = cloneEl;

		evt.oldIndex = startIndex;
		evt.newIndex = newIndex;

		rootEl.dispatchEvent(evt);

		if (options[onName]) {
			options[onName].call(sortable, evt);
		}
	}


	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
		var evt,
			sortable = fromEl[expando],
			onMoveFn = sortable.options.onMove,
			retVal;

		evt = document.createEvent('Event');
		evt.initEvent('move', true, true);

		evt.to = toEl;
		evt.from = fromEl;
		evt.dragged = dragEl;
		evt.draggedRect = dragRect;
		evt.related = targetEl || toEl;
		evt.relatedRect = targetRect || toEl.getBoundingClientRect();
		evt.willInsertAfter = willInsertAfter;

		fromEl.dispatchEvent(evt);

		if (onMoveFn) {
			retVal = onMoveFn.call(sortable, evt, originalEvt);
		}

		return retVal;
	}


	function _disableDraggable(el) {
		el.draggable = false;
	}


	function _unsilent() {
		_silent = false;
	}


	/** @returns {HTMLElement|false} */
	function _ghostIsLast(el, evt) {
		var lastEl = el.lastElementChild,
			rect = lastEl.getBoundingClientRect();

		// 5  min delta
		// abs   ,      
		return (evt.clientY - (rect.top + rect.height) > 5) ||
			(evt.clientX - (rect.left + rect.width) > 5);
	}


	/**
	 * Generate id
	 * @param   {HTMLElement} el
	 * @returns {String}
	 * @private
	 */
	function _generateId(el) {
		var str = el.tagName + el.className + el.src + el.href + el.textContent,
			i = str.length,
			sum = 0;

		while (i--) {
			sum += str.charCodeAt(i);
		}

		return sum.toString(36);
	}

	/**
	 * Returns the index of an element within its parent for a selected set of
	 * elements
	 * @param  {HTMLElement} el
	 * @param  {selector} selector
	 * @return {number}
	 */
	function _index(el, selector) {
		var index = 0;

		if (!el || !el.parentNode) {
			return -1;
		}

		while (el && (el = el.previousElementSibling)) {
			if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {
				index++;
			}
		}

		return index;
	}

	function _matches(/**HTMLElement*/el, /**String*/selector) {
		if (el) {
			selector = selector.split('.');

			var tag = selector.shift().toUpperCase(),
				re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');

			return (
				(tag === '' || el.nodeName.toUpperCase() == tag) &&
				(!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)
			);
		}

		return false;
	}

	function _throttle(callback, ms) {
		var args, _this;

		return function () {
			if (args === void 0) {
				args = arguments;
				_this = this;

				setTimeout(function () {
					if (args.length === 1) {
						callback.call(_this, args[0]);
					} else {
						callback.apply(_this, args);
					}

					args = void 0;
				}, ms);
			}
		};
	}

	function _extend(dst, src) {
		if (dst && src) {
			for (var key in src) {
				if (src.hasOwnProperty(key)) {
					dst[key] = src[key];
				}
			}
		}

		return dst;
	}

	function _clone(el) {
		return $
			? $(el).clone(true)[0]
			: (Polymer && Polymer.dom
				? Polymer.dom(el).cloneNode(true)
				: el.cloneNode(true)
			);
	}

	function _saveInputCheckedState(root) {
		var inputs = root.getElementsByTagName('input');
		var idx = inputs.length;

		while (idx--) {
			var el = inputs[idx];
			el.checked && savedInputChecked.push(el);
		}
	}

	// Fixed #973: 
	_on(document, 'touchmove', function (evt) {
		if (Sortable.active) {
			evt.preventDefault();
		}
	});

	try {
		window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
			get: function () {
				captureMode = {
					capture: false,
					passive: false
				};
			}
		}));
	} catch (err) {}

	// Export utils
	Sortable.utils = {
		on: _on,
		off: _off,
		css: _css,
		find: _find,
		is: function (el, selector) {
			return !!_closest(el, selector, el);
		},
		extend: _extend,
		throttle: _throttle,
		closest: _closest,
		toggleClass: _toggleClass,
		clone: _clone,
		index: _index
	};


	/**
	 * Create sortable instance
	 * @param {HTMLElement}  el
	 * @param {Object}      [options]
	 */
	Sortable.create = function (el, options) {
		return new Sortable(el, options);
	};


	// Export
	Sortable.version = '1.6.1';
	return Sortable;
});


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_qoob__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_cropperjs__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_cropperjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_cropperjs__);



var bootstrap = function bootstrap() {
	var croppers = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.find('.js-crop');
	if (croppers.length <= 0) return;

	__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.each(croppers, function (crops) {
		var attributes = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.head(__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.data(crops, 'cropper'));
		if (attributes) {
			var image = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.head(__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.children(crops, 'img'));
			var upload = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.head(__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.children(crops, '.js-crop-upload'));
			var input = __WEBPACK_IMPORTED_MODULE_0_qoob___default.a.head(__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.children(crops, '.js-crop-dimentions'));
			var MIN_WIDTH = JSON.parse(attributes).min_width;
			var MIN_HEIGHT = JSON.parse(attributes).min_height;

			var cropper = '',
			    enabled = false;

			__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.on(upload, 'change', function (event) {
				event.preventDefault();
				render(this);
			});

			var updateInput = function updateInput() {
				input.value = JSON.stringify(cropper.getData());
			};

			var enableCropper = function enableCropper(src) {
				enabled = true;
				image.src = src;

				cropper = new __WEBPACK_IMPORTED_MODULE_1_cropperjs___default.a(image, {
					aspectRatio: 12 / 5,
					width: image.width, // resize the cropped area
					height: image.height,
					checkCrossOrigin: false,
					viewMode: 0,
					zoomable: false,
					movable: false,
					rotatable: false,
					scalable: false,
					ready: function ready() {
						var cropper = this.cropper;
						var containerData = cropper.getContainerData();
						var cropBoxData = cropper.getCropBoxData();
						var aspectRatio = cropBoxData.width / cropBoxData.height;
						var newCropBoxWidth;
						var data = cropper.getData();
						data.width = MIN_WIDTH;
						data.height = MIN_HEIGHT;
						cropper.setData(data);
						updateInput();
					},
					cropmove: function cropmove(e) {
						var cropper = this.cropper;
						var data = cropper.getData();
						if (data.width < MIN_WIDTH || data.height < MIN_HEIGHT) {
							data.width = MIN_WIDTH;
							data.height = MIN_HEIGHT;
							cropper.setData(data);
						} else {
							updateInput();
						}
					}
				});
			};

			var render = function render(input) {
				if (input.files && input.files[0]) {
					var reader = new FileReader();
					reader.onload = function (event) {
						var file_input = event.target;
						var image = new Image();
						image.src = event.target.result;
						image.onload = function () {
							if (image.width < MIN_WIDTH || image.height < MIN_HEIGHT) {
								var message = 'Error, File needs to be above ' + MIN_WIDTH + 'x' + MIN_HEIGHT;
								file_input.value = '';

								upload.nextElementSibling.querySelector('span').innerHTML = message;
								laramin.messages.push({ type: 'error', message: message });
							} else {
								if (!enabled) {
									enableCropper(image.src);
								}
								cropper.replace(image.src);
							}
						};
					};
					reader.readAsDataURL(input.files[0]);
				}
			};
		}
	});
};

/* harmony default export */ __webpack_exports__["a"] = (bootstrap);

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Cropper.js v1.1.3
 * https://github.com/fengyuanchen/cropperjs
 *
 * Copyright (c) 2015-2017 Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2017-10-21T09:27:36.848Z
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Cropper = factory());
}(this, (function () { 'use strict';

var WINDOW = typeof window !== 'undefined' ? window : {};
var NAMESPACE = 'cropper';

// Actions
var ACTION_ALL = 'all';
var ACTION_CROP = 'crop';
var ACTION_MOVE = 'move';
var ACTION_ZOOM = 'zoom';
var ACTION_EAST = 'e';
var ACTION_WEST = 'w';
var ACTION_SOUTH = 's';
var ACTION_NORTH = 'n';
var ACTION_NORTH_EAST = 'ne';
var ACTION_NORTH_WEST = 'nw';
var ACTION_SOUTH_EAST = 'se';
var ACTION_SOUTH_WEST = 'sw';

// Classes
var CLASS_CROP = NAMESPACE + '-crop';
var CLASS_DISABLED = NAMESPACE + '-disabled';
var CLASS_HIDDEN = NAMESPACE + '-hidden';
var CLASS_HIDE = NAMESPACE + '-hide';
var CLASS_INVISIBLE = NAMESPACE + '-invisible';
var CLASS_MODAL = NAMESPACE + '-modal';
var CLASS_MOVE = NAMESPACE + '-move';

// Data keys
var DATA_ACTION = 'action';
var DATA_PREVIEW = 'preview';

// Drag modes
var DRAG_MODE_CROP = 'crop';
var DRAG_MODE_MOVE = 'move';
var DRAG_MODE_NONE = 'none';

// Events
var EVENT_CROP = 'crop';
var EVENT_CROP_END = 'cropend';
var EVENT_CROP_MOVE = 'cropmove';
var EVENT_CROP_START = 'cropstart';
var EVENT_DBLCLICK = 'dblclick';
var EVENT_ERROR = 'error';
var EVENT_LOAD = 'load';
var EVENT_POINTER_DOWN = WINDOW.PointerEvent ? 'pointerdown' : 'touchstart mousedown';
var EVENT_POINTER_MOVE = WINDOW.PointerEvent ? 'pointermove' : 'touchmove mousemove';
var EVENT_POINTER_UP = WINDOW.PointerEvent ? ' pointerup pointercancel' : 'touchend touchcancel mouseup';
var EVENT_READY = 'ready';
var EVENT_RESIZE = 'resize';
var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';
var EVENT_ZOOM = 'zoom';

// RegExps
var REGEXP_ACTIONS = /^(e|w|s|n|se|sw|ne|nw|all|crop|move|zoom)$/;
var REGEXP_DATA_URL = /^data:/;
var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
var REGEXP_TAG_NAME = /^(img|canvas)$/i;

var DEFAULTS = {
  // Define the view mode of the cropper
  viewMode: 0, // 0, 1, 2, 3

  // Define the dragging mode of the cropper
  dragMode: DRAG_MODE_CROP, // 'crop', 'move' or 'none'

  // Define the aspect ratio of the crop box
  aspectRatio: NaN,

  // An object with the previous cropping result data
  data: null,

  // A selector for adding extra containers to preview
  preview: '',

  // Re-render the cropper when resize the window
  responsive: true,

  // Restore the cropped area after resize the window
  restore: true,

  // Check if the current image is a cross-origin image
  checkCrossOrigin: true,

  // Check the current image's Exif Orientation information
  checkOrientation: true,

  // Show the black modal
  modal: true,

  // Show the dashed lines for guiding
  guides: true,

  // Show the center indicator for guiding
  center: true,

  // Show the white modal to highlight the crop box
  highlight: true,

  // Show the grid background
  background: true,

  // Enable to crop the image automatically when initialize
  autoCrop: true,

  // Define the percentage of automatic cropping area when initializes
  autoCropArea: 0.8,

  // Enable to move the image
  movable: true,

  // Enable to rotate the image
  rotatable: true,

  // Enable to scale the image
  scalable: true,

  // Enable to zoom the image
  zoomable: true,

  // Enable to zoom the image by dragging touch
  zoomOnTouch: true,

  // Enable to zoom the image by wheeling mouse
  zoomOnWheel: true,

  // Define zoom ratio when zoom the image by wheeling mouse
  wheelZoomRatio: 0.1,

  // Enable to move the crop box
  cropBoxMovable: true,

  // Enable to resize the crop box
  cropBoxResizable: true,

  // Toggle drag mode between "crop" and "move" when click twice on the cropper
  toggleDragModeOnDblclick: true,

  // Size limitation
  minCanvasWidth: 0,
  minCanvasHeight: 0,
  minCropBoxWidth: 0,
  minCropBoxHeight: 0,
  minContainerWidth: 200,
  minContainerHeight: 100,

  // Shortcuts of events
  ready: null,
  cropstart: null,
  cropmove: null,
  cropend: null,
  crop: null,
  zoom: null
};

var TEMPLATE = '<div class="cropper-container">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-action="e"></span>' + '<span class="cropper-line line-n" data-action="n"></span>' + '<span class="cropper-line line-w" data-action="w"></span>' + '<span class="cropper-line line-s" data-action="s"></span>' + '<span class="cropper-point point-e" data-action="e"></span>' + '<span class="cropper-point point-n" data-action="n"></span>' + '<span class="cropper-point point-w" data-action="w"></span>' + '<span class="cropper-point point-s" data-action="s"></span>' + '<span class="cropper-point point-ne" data-action="ne"></span>' + '<span class="cropper-point point-nw" data-action="nw"></span>' + '<span class="cropper-point point-sw" data-action="sw"></span>' + '<span class="cropper-point point-se" data-action="se"></span>' + '</div>' + '</div>';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Check if the given value is not a number.
 */
var isNaN = Number.isNaN || WINDOW.isNaN;

/**
 * Check if the given value is a number.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a number, else `false`.
 */
function isNumber(value) {
  return typeof value === 'number' && !isNaN(value);
}

/**
 * Check if the given value is undefined.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
 */
function isUndefined(value) {
  return typeof value === 'undefined';
}

/**
 * Check if the given value is an object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is an object, else `false`.
 */
function isObject(value) {
  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Check if the given value is a plain object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
 */

function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }

  try {
    var _constructor = value.constructor;
    var prototype = _constructor.prototype;


    return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
  } catch (e) {
    return false;
  }
}

/**
 * Check if the given value is a function.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a function, else `false`.
 */
function isFunction(value) {
  return typeof value === 'function';
}

/**
 * Iterate the given data.
 * @param {*} data - The data to iterate.
 * @param {Function} callback - The process function for each element.
 * @returns {*} The original data.
 */
function each(data, callback) {
  if (data && isFunction(callback)) {
    if (Array.isArray(data) || isNumber(data.length) /* array-like */) {
        var length = data.length;

        var i = void 0;

        for (i = 0; i < length; i += 1) {
          if (callback.call(data, data[i], i, data) === false) {
            break;
          }
        }
      } else if (isObject(data)) {
      Object.keys(data).forEach(function (key) {
        callback.call(data, data[key], key, data);
      });
    }
  }

  return data;
}

/**
 * Extend the given object.
 * @param {*} obj - The object to be extended.
 * @param {*} args - The rest objects which will be merged to the first object.
 * @returns {Object} The extended object.
 */
function extend(obj) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (isObject(obj) && args.length > 0) {
    if (Object.assign) {
      return Object.assign.apply(Object, [obj].concat(args));
    }

    args.forEach(function (arg) {
      if (isObject(arg)) {
        Object.keys(arg).forEach(function (key) {
          obj[key] = arg[key];
        });
      }
    });
  }

  return obj;
}

/**
 * Takes a function and returns a new one that will always have a particular context.
 * @param {Function} fn - The target function.
 * @param {Object} context - The new context for the function.
 * @returns {boolean} The new function.
 */
function proxy(fn, context) {
  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  return function () {
    for (var _len3 = arguments.length, args2 = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args2[_key3] = arguments[_key3];
    }

    return fn.apply(context, args.concat(args2));
  };
}

var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/i;

/**
 * Normalize decimal number.
 * Check out {@link http://0.30000000000000004.com/ }
 * @param {number} value - The value to normalize.
 * @param {number} [times=100000000000] - The times for normalizing.
 * @returns {number} Returns the normalized number.
 */
function normalizeDecimalNumber(value) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;

  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
}

var REGEXP_SUFFIX = /^(width|height|left|top|marginLeft|marginTop)$/;

/**
 * Apply styles to the given element.
 * @param {Element} element - The target element.
 * @param {Object} styles - The styles for applying.
 */
function setStyle(element, styles) {
  var style = element.style;


  each(styles, function (value, property) {
    if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
      value += 'px';
    }

    style[property] = value;
  });
}

/**
 * Check if the given element has a special class.
 * @param {Element} element - The element to check.
 * @param {string} value - The class to search.
 * @returns {boolean} Returns `true` if the special class was found.
 */
function hasClass(element, value) {
  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
}

/**
 * Add classes to the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be added.
 */
function addClass(element, value) {
  if (!value) {
    return;
  }

  if (isNumber(element.length)) {
    each(element, function (elem) {
      addClass(elem, value);
    });
    return;
  }

  if (element.classList) {
    element.classList.add(value);
    return;
  }

  var className = element.className.trim();

  if (!className) {
    element.className = value;
  } else if (className.indexOf(value) < 0) {
    element.className = className + ' ' + value;
  }
}

/**
 * Remove classes from the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be removed.
 */
function removeClass(element, value) {
  if (!value) {
    return;
  }

  if (isNumber(element.length)) {
    each(element, function (elem) {
      removeClass(elem, value);
    });
    return;
  }

  if (element.classList) {
    element.classList.remove(value);
    return;
  }

  if (element.className.indexOf(value) >= 0) {
    element.className = element.className.replace(value, '');
  }
}

/**
 * Add or remove classes from the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be toggled.
 * @param {boolean} added - Add only.
 */
function toggleClass(element, value, added) {
  if (!value) {
    return;
  }

  if (isNumber(element.length)) {
    each(element, function (elem) {
      toggleClass(elem, value, added);
    });
    return;
  }

  // IE10-11 doesn't support the second parameter of `classList.toggle`
  if (added) {
    addClass(element, value);
  } else {
    removeClass(element, value);
  }
}

var REGEXP_HYPHENATE = /([a-z\d])([A-Z])/g;

/**
 * Hyphenate the given value.
 * @param {string} value - The value to hyphenate.
 * @returns {string} The hyphenated value.
 */
function hyphenate(value) {
  return value.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();
}

/**
 * Get data from the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to get.
 * @returns {string} The data value.
 */
function getData(element, name) {
  if (isObject(element[name])) {
    return element[name];
  } else if (element.dataset) {
    return element.dataset[name];
  }

  return element.getAttribute('data-' + hyphenate(name));
}

/**
 * Set data to the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to set.
 * @param {string} data - The data value.
 */
function setData(element, name, data) {
  if (isObject(data)) {
    element[name] = data;
  } else if (element.dataset) {
    element.dataset[name] = data;
  } else {
    element.setAttribute('data-' + hyphenate(name), data);
  }
}

/**
 * Remove data from the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to remove.
 */
function removeData(element, name) {
  if (isObject(element[name])) {
    delete element[name];
  } else if (element.dataset) {
    // #128 Safari not allows to delete dataset property
    try {
      delete element.dataset[name];
    } catch (e) {
      element.dataset[name] = null;
    }
  } else {
    element.removeAttribute('data-' + hyphenate(name));
  }
}

var REGEXP_SPACES = /\s+/;

/**
 * Remove event listener from the given element.
 * @param {Element} element - The target element.
 * @param {string} type - The event type(s) to remove,
 * @param {Function} listener - The event listener to remove.
 * @param {Object} options - The event options.
 */
function removeListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!isFunction(listener)) {
    return;
  }

  var types = type.trim().split(REGEXP_SPACES);

  if (types.length > 1) {
    each(types, function (t) {
      removeListener(element, t, listener);
    });
    return;
  }

  if (isFunction(listener.onceListener)) {
    listener = listener.onceListener;
    delete listener.onceListener;
  }

  if (element.removeEventListener) {
    element.removeEventListener(type, listener, options);
  } else if (element.detachEvent) {
    element.detachEvent('on' + type, listener);
  }
}

/**
 * Add event listener to the given element.
 * @param {Element} element - The target element.
 * @param {string} type - The event type(s) to add,
 * @param {Function} listener - The event listener to add.
 * @param {Object} options - The event options.
 */
function addListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!isFunction(listener)) {
    return;
  }

  var types = type.trim().split(REGEXP_SPACES);

  if (types.length > 1) {
    each(types, function (t) {
      addListener(element, t, listener);
    });
    return;
  }

  if (options.once) {
    var originalListener = listener;
    var onceListener = function onceListener() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      removeListener(element, type, onceListener);
      return originalListener.apply(element, args);
    };
    originalListener.onceListener = onceListener;
    listener = onceListener;
  }

  if (element.addEventListener) {
    element.addEventListener(type, listener, options);
  } else if (element.attachEvent) {
    element.attachEvent('on' + type, listener);
  }
}

/**
 * Dispatch event on the given element.
 * @param {Element} element - The target element.
 * @param {string} type - The event type(s) to dispatch,
 * @param {Object} data - The additional event data.
 * @returns {boolean} Indicate if the event is default prevented or not.
 */
function dispatchEvent(element, type, data) {
  if (element.dispatchEvent) {
    var event = void 0;

    // Event and CustomEvent on IE9-11 are global objects, not constructors
    if (isFunction(Event) && isFunction(CustomEvent)) {
      if (isUndefined(data)) {
        event = new Event(type, {
          bubbles: true,
          cancelable: true
        });
      } else {
        event = new CustomEvent(type, {
          detail: data,
          bubbles: true,
          cancelable: true
        });
      }
    } else if (isUndefined(data)) {
      event = document.createEvent('Event');
      event.initEvent(type, true, true);
    } else {
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(type, true, true, data);
    }

    // IE9+
    return element.dispatchEvent(event);
  } else if (element.fireEvent) {
    // IE6-10 (native events only)
    return element.fireEvent('on' + type);
  }

  return true;
}

/**
 * Get the offset base on the document.
 * @param {Element} element - The target element.
 * @returns {Object} The offset data.
 */
function getOffset(element) {
  var doc = document.documentElement;
  var box = element.getBoundingClientRect();

  return {
    left: box.left + ((window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0)),
    top: box.top + ((window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0))
  };
}

/**
 * Empty an element.
 * @param {Element} element - The element to empty.
 */
function empty(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}

var location = WINDOW.location;

var REGEXP_ORIGINS = /^(https?:)\/\/([^:/?#]+):?(\d*)/i;

/**
 * Check if the given URL is a cross origin URL.
 * @param {string} url - The target URL.
 * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
 */
function isCrossOriginURL(url) {
  var parts = url.match(REGEXP_ORIGINS);

  return parts && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
}

/**
 * Add timestamp to the given URL.
 * @param {string} url - The target URL.
 * @returns {string} The result URL.
 */
function addTimestamp(url) {
  var timestamp = 'timestamp=' + new Date().getTime();

  return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
}

/**
 * Get transforms base on the given object.
 * @param {Object} obj - The target object.
 * @returns {string} A string contains transform values.
 */
function getTransforms(_ref) {
  var rotate = _ref.rotate,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      translateX = _ref.translateX,
      translateY = _ref.translateY;

  var values = [];

  if (isNumber(translateX) && translateX !== 0) {
    values.push('translateX(' + translateX + 'px)');
  }

  if (isNumber(translateY) && translateY !== 0) {
    values.push('translateY(' + translateY + 'px)');
  }

  // Rotate should come first before scale to match orientation transform
  if (isNumber(rotate) && rotate !== 0) {
    values.push('rotate(' + rotate + 'deg)');
  }

  if (isNumber(scaleX) && scaleX !== 1) {
    values.push('scaleX(' + scaleX + ')');
  }

  if (isNumber(scaleY) && scaleY !== 1) {
    values.push('scaleY(' + scaleY + ')');
  }

  var transform = values.length ? values.join(' ') : 'none';

  return {
    WebkitTransform: transform,
    msTransform: transform,
    transform: transform
  };
}

var navigator = WINDOW.navigator;

var IS_SAFARI_OR_UIWEBVIEW = navigator && /(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i.test(navigator.userAgent);

/**
 * Get an image's natural sizes.
 * @param {string} image - The target image.
 * @param {Function} callback - The callback function.
 */
function getImageNaturalSizes(image, callback) {
  // Modern browsers (except Safari)
  if (image.naturalWidth && !IS_SAFARI_OR_UIWEBVIEW) {
    callback(image.naturalWidth, image.naturalHeight);
    return;
  }

  var newImage = document.createElement('img');

  newImage.onload = function () {
    callback(newImage.width, newImage.height);
  };

  newImage.src = image.src;
}

/**
 * Get the max ratio of a group of pointers.
 * @param {string} pointers - The target pointers.
 * @returns {number} The result ratio.
 */
function getMaxZoomRatio(pointers) {
  var pointers2 = extend({}, pointers);
  var ratios = [];

  each(pointers, function (pointer, pointerId) {
    delete pointers2[pointerId];

    each(pointers2, function (pointer2) {
      var x1 = Math.abs(pointer.startX - pointer2.startX);
      var y1 = Math.abs(pointer.startY - pointer2.startY);
      var x2 = Math.abs(pointer.endX - pointer2.endX);
      var y2 = Math.abs(pointer.endY - pointer2.endY);
      var z1 = Math.sqrt(x1 * x1 + y1 * y1);
      var z2 = Math.sqrt(x2 * x2 + y2 * y2);
      var ratio = (z2 - z1) / z1;

      ratios.push(ratio);
    });
  });

  ratios.sort(function (a, b) {
    return Math.abs(a) < Math.abs(b);
  });

  return ratios[0];
}

/**
 * Get a pointer from an event object.
 * @param {Object} event - The target event object.
 * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
 * @returns {Object} The result pointer contains start and/or end point coordinates.
 */
function getPointer(_ref2, endOnly) {
  var pageX = _ref2.pageX,
      pageY = _ref2.pageY;

  var end = {
    endX: pageX,
    endY: pageY
  };

  if (endOnly) {
    return end;
  }

  return extend({
    startX: pageX,
    startY: pageY
  }, end);
}

/**
 * Get the center point coordinate of a group of pointers.
 * @param {Object} pointers - The target pointers.
 * @returns {Object} The center point coordinate.
 */
function getPointersCenter(pointers) {
  var pageX = 0;
  var pageY = 0;
  var count = 0;

  each(pointers, function (_ref3) {
    var startX = _ref3.startX,
        startY = _ref3.startY;

    pageX += startX;
    pageY += startY;
    count += 1;
  });

  pageX /= count;
  pageY /= count;

  return {
    pageX: pageX,
    pageY: pageY
  };
}

/**
 * Check if the given value is a finite number.
 */
var isFinite = Number.isFinite || WINDOW.isFinite;

/**
 * Get the max sizes in a rectangle under the given aspect ratio.
 * @param {Object} data - The original sizes.
 * @returns {Object} The result sizes.
 */
function getContainSizes(_ref4) {
  var aspectRatio = _ref4.aspectRatio,
      height = _ref4.height,
      width = _ref4.width;

  var isValidNumber = function isValidNumber(value) {
    return isFinite(value) && value > 0;
  };

  if (isValidNumber(width) && isValidNumber(height)) {
    if (height * aspectRatio > width) {
      height = width / aspectRatio;
    } else {
      width = height * aspectRatio;
    }
  } else if (isValidNumber(width)) {
    height = width / aspectRatio;
  } else if (isValidNumber(height)) {
    width = height * aspectRatio;
  }

  return {
    width: width,
    height: height
  };
}

/**
 * Get the new sizes of a rectangle after rotated.
 * @param {Object} data - The original sizes.
 * @returns {Object} The result sizes.
 */
function getRotatedSizes(_ref5) {
  var width = _ref5.width,
      height = _ref5.height,
      degree = _ref5.degree;

  degree = Math.abs(degree);

  if (degree % 180 === 90) {
    return {
      width: height,
      height: width
    };
  }

  var arc = degree % 90 * Math.PI / 180;
  var sinArc = Math.sin(arc);
  var cosArc = Math.cos(arc);

  return {
    width: width * cosArc + height * sinArc,
    height: width * sinArc + height * cosArc
  };
}

/**
 * Get a canvas which drew the given image.
 * @param {HTMLImageElement} image - The image for drawing.
 * @param {Object} imageData - The image data.
 * @param {Object} canvasData - The canvas data.
 * @param {Object} options - The options.
 * @returns {HTMLCanvasElement} The result canvas.
 */
function getSourceCanvas(image, _ref6, _ref7, _ref8) {
  var imageNaturalWidth = _ref6.naturalWidth,
      imageNaturalHeight = _ref6.naturalHeight,
      _ref6$rotate = _ref6.rotate,
      rotate = _ref6$rotate === undefined ? 0 : _ref6$rotate,
      _ref6$scaleX = _ref6.scaleX,
      scaleX = _ref6$scaleX === undefined ? 1 : _ref6$scaleX,
      _ref6$scaleY = _ref6.scaleY,
      scaleY = _ref6$scaleY === undefined ? 1 : _ref6$scaleY;
  var aspectRatio = _ref7.aspectRatio,
      naturalWidth = _ref7.naturalWidth,
      naturalHeight = _ref7.naturalHeight;
  var _ref8$fillColor = _ref8.fillColor,
      fillColor = _ref8$fillColor === undefined ? 'transparent' : _ref8$fillColor,
      _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
      imageSmoothingEnabled = _ref8$imageSmoothingE === undefined ? true : _ref8$imageSmoothingE,
      _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
      imageSmoothingQuality = _ref8$imageSmoothingQ === undefined ? 'low' : _ref8$imageSmoothingQ,
      _ref8$maxWidth = _ref8.maxWidth,
      maxWidth = _ref8$maxWidth === undefined ? Infinity : _ref8$maxWidth,
      _ref8$maxHeight = _ref8.maxHeight,
      maxHeight = _ref8$maxHeight === undefined ? Infinity : _ref8$maxHeight,
      _ref8$minWidth = _ref8.minWidth,
      minWidth = _ref8$minWidth === undefined ? 0 : _ref8$minWidth,
      _ref8$minHeight = _ref8.minHeight,
      minHeight = _ref8$minHeight === undefined ? 0 : _ref8$minHeight;

  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');
  var maxSizes = getContainSizes({
    aspectRatio: aspectRatio,
    width: maxWidth,
    height: maxHeight
  });
  var minSizes = getContainSizes({
    aspectRatio: aspectRatio,
    width: minWidth,
    height: minHeight
  });
  var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
  var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));
  var params = [-imageNaturalWidth / 2, -imageNaturalHeight / 2, imageNaturalWidth, imageNaturalHeight];

  canvas.width = normalizeDecimalNumber(width);
  canvas.height = normalizeDecimalNumber(height);
  context.fillStyle = fillColor;
  context.fillRect(0, 0, width, height);
  context.save();
  context.translate(width / 2, height / 2);
  context.rotate(rotate * Math.PI / 180);
  context.scale(scaleX, scaleY);
  context.imageSmoothingEnabled = imageSmoothingEnabled;
  context.imageSmoothingQuality = imageSmoothingQuality;
  context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {
    return Math.floor(normalizeDecimalNumber(param));
  }))));
  context.restore();
  return canvas;
}

var fromCharCode = String.fromCharCode;

/**
 * Get string from char code in data view.
 * @param {DataView} dataView - The data view for read.
 * @param {number} start - The start index.
 * @param {number} length - The read length.
 * @returns {string} The read result.
 */

function getStringFromCharCode(dataView, start, length) {
  var str = '';
  var i = void 0;

  length += start;

  for (i = start; i < length; i += 1) {
    str += fromCharCode(dataView.getUint8(i));
  }

  return str;
}

var REGEXP_DATA_URL_HEAD = /^data:.*,/;

/**
 * Transform Data URL to array buffer.
 * @param {string} dataURL - The Data URL to transform.
 * @returns {ArrayBuffer} The result array buffer.
 */
function dataURLToArrayBuffer(dataURL) {
  var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
  var binary = atob(base64);
  var arrayBuffer = new ArrayBuffer(binary.length);
  var uint8 = new Uint8Array(arrayBuffer);

  each(uint8, function (value, i) {
    uint8[i] = binary.charCodeAt(i);
  });

  return arrayBuffer;
}

/**
 * Transform array buffer to Data URL.
 * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
 * @param {string} mimeType - The mime type of the Data URL.
 * @returns {string} The result Data URL.
 */
function arrayBufferToDataURL(arrayBuffer, mimeType) {
  var uint8 = new Uint8Array(arrayBuffer);
  var data = '';

  // TypedArray.prototype.forEach is not supported in some browsers.
  each(uint8, function (value) {
    data += fromCharCode(value);
  });

  return 'data:' + mimeType + ';base64,' + btoa(data);
}

/**
 * Get orientation value from given array buffer.
 * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
 * @returns {number} The read orientation value.
 */
function getOrientation(arrayBuffer) {
  var dataView = new DataView(arrayBuffer);
  var orientation = void 0;
  var littleEndian = void 0;
  var app1Start = void 0;
  var ifdStart = void 0;

  // Only handle JPEG image (start by 0xFFD8)
  if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
    var length = dataView.byteLength;
    var offset = 2;

    while (offset < length) {
      if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
        app1Start = offset;
        break;
      }

      offset += 1;
    }
  }

  if (app1Start) {
    var exifIDCode = app1Start + 4;
    var tiffOffset = app1Start + 10;

    if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
      var endianness = dataView.getUint16(tiffOffset);

      littleEndian = endianness === 0x4949;

      if (littleEndian || endianness === 0x4D4D /* bigEndian */) {
          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
            var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

            if (firstIFDOffset >= 0x00000008) {
              ifdStart = tiffOffset + firstIFDOffset;
            }
          }
        }
    }
  }

  if (ifdStart) {
    var _length = dataView.getUint16(ifdStart, littleEndian);
    var _offset = void 0;
    var i = void 0;

    for (i = 0; i < _length; i += 1) {
      _offset = ifdStart + i * 12 + 2;

      if (dataView.getUint16(_offset, littleEndian) === 0x0112 /* Orientation */) {
          // 8 is the offset of the current tag's value
          _offset += 8;

          // Get the original orientation value
          orientation = dataView.getUint16(_offset, littleEndian);

          // Override the orientation with its default value
          dataView.setUint16(_offset, 1, littleEndian);
          break;
        }
    }
  }

  return orientation;
}

/**
 * Parse Exif Orientation value.
 * @param {number} orientation - The orientation to parse.
 * @returns {Object} The parsed result.
 */
function parseOrientation(orientation) {
  var rotate = 0;
  var scaleX = 1;
  var scaleY = 1;

  switch (orientation) {
    // Flip horizontal
    case 2:
      scaleX = -1;
      break;

    // Rotate left 180
    case 3:
      rotate = -180;
      break;

    // Flip vertical
    case 4:
      scaleY = -1;
      break;

    // Flip vertical and rotate right 90
    case 5:
      rotate = 90;
      scaleY = -1;
      break;

    // Rotate right 90
    case 6:
      rotate = 90;
      break;

    // Flip horizontal and rotate right 90
    case 7:
      rotate = 90;
      scaleX = -1;
      break;

    // Rotate left 90
    case 8:
      rotate = -90;
      break;

    default:
  }

  return {
    rotate: rotate,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var render = {
  render: function render() {
    this.initContainer();
    this.initCanvas();
    this.initCropBox();
    this.renderCanvas();

    if (this.cropped) {
      this.renderCropBox();
    }
  },
  initContainer: function initContainer() {
    var element = this.element,
        options = this.options,
        container = this.container,
        cropper = this.cropper;


    addClass(cropper, CLASS_HIDDEN);
    removeClass(element, CLASS_HIDDEN);

    var containerData = {
      width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),
      height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)
    };

    this.containerData = containerData;

    setStyle(cropper, {
      width: containerData.width,
      height: containerData.height
    });

    addClass(element, CLASS_HIDDEN);
    removeClass(cropper, CLASS_HIDDEN);
  },


  // Canvas (image wrapper)
  initCanvas: function initCanvas() {
    var containerData = this.containerData,
        imageData = this.imageData;
    var viewMode = this.options.viewMode;

    var rotated = Math.abs(imageData.rotate) % 180 === 90;
    var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
    var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
    var aspectRatio = naturalWidth / naturalHeight;
    var canvasWidth = containerData.width;
    var canvasHeight = containerData.height;

    if (containerData.height * aspectRatio > containerData.width) {
      if (viewMode === 3) {
        canvasWidth = containerData.height * aspectRatio;
      } else {
        canvasHeight = containerData.width / aspectRatio;
      }
    } else if (viewMode === 3) {
      canvasHeight = containerData.width / aspectRatio;
    } else {
      canvasWidth = containerData.height * aspectRatio;
    }

    var canvasData = {
      aspectRatio: aspectRatio,
      naturalWidth: naturalWidth,
      naturalHeight: naturalHeight,
      width: canvasWidth,
      height: canvasHeight
    };

    canvasData.left = (containerData.width - canvasWidth) / 2;
    canvasData.top = (containerData.height - canvasHeight) / 2;
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;

    this.canvasData = canvasData;
    this.limited = viewMode === 1 || viewMode === 2;
    this.limitCanvas(true, true);
    this.initialImageData = extend({}, imageData);
    this.initialCanvasData = extend({}, canvasData);
  },
  limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
    var options = this.options,
        containerData = this.containerData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var viewMode = options.viewMode;
    var aspectRatio = canvasData.aspectRatio;

    var cropped = this.cropped && cropBoxData;

    if (sizeLimited) {
      var minCanvasWidth = Number(options.minCanvasWidth) || 0;
      var minCanvasHeight = Number(options.minCanvasHeight) || 0;

      if (viewMode > 1) {
        minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
        minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

        if (viewMode === 3) {
          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      } else if (viewMode > 0) {
        if (minCanvasWidth) {
          minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
        } else if (minCanvasHeight) {
          minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
        } else if (cropped) {
          minCanvasWidth = cropBoxData.width;
          minCanvasHeight = cropBoxData.height;

          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      }

      var _getContainSizes = getContainSizes({
        aspectRatio: aspectRatio,
        width: minCanvasWidth,
        height: minCanvasHeight
      });

      minCanvasWidth = _getContainSizes.width;
      minCanvasHeight = _getContainSizes.height;


      canvasData.minWidth = minCanvasWidth;
      canvasData.minHeight = minCanvasHeight;
      canvasData.maxWidth = Infinity;
      canvasData.maxHeight = Infinity;
    }

    if (positionLimited) {
      if (viewMode) {
        var newCanvasLeft = containerData.width - canvasData.width;
        var newCanvasTop = containerData.height - canvasData.height;

        canvasData.minLeft = Math.min(0, newCanvasLeft);
        canvasData.minTop = Math.min(0, newCanvasTop);
        canvasData.maxLeft = Math.max(0, newCanvasLeft);
        canvasData.maxTop = Math.max(0, newCanvasTop);

        if (cropped && this.limited) {
          canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
          canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
          canvasData.maxLeft = cropBoxData.left;
          canvasData.maxTop = cropBoxData.top;

          if (viewMode === 2) {
            if (canvasData.width >= containerData.width) {
              canvasData.minLeft = Math.min(0, newCanvasLeft);
              canvasData.maxLeft = Math.max(0, newCanvasLeft);
            }

            if (canvasData.height >= containerData.height) {
              canvasData.minTop = Math.min(0, newCanvasTop);
              canvasData.maxTop = Math.max(0, newCanvasTop);
            }
          }
        }
      } else {
        canvasData.minLeft = -canvasData.width;
        canvasData.minTop = -canvasData.height;
        canvasData.maxLeft = containerData.width;
        canvasData.maxTop = containerData.height;
      }
    }
  },
  renderCanvas: function renderCanvas(changed, transformed) {
    var canvasData = this.canvasData,
        imageData = this.imageData;


    if (transformed) {
      var _getRotatedSizes = getRotatedSizes({
        width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
        height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
        degree: imageData.rotate || 0
      }),
          naturalWidth = _getRotatedSizes.width,
          naturalHeight = _getRotatedSizes.height;

      var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
      var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);

      canvasData.left -= (width - canvasData.width) / 2;
      canvasData.top -= (height - canvasData.height) / 2;
      canvasData.width = width;
      canvasData.height = height;
      canvasData.aspectRatio = naturalWidth / naturalHeight;
      canvasData.naturalWidth = naturalWidth;
      canvasData.naturalHeight = naturalHeight;
      this.limitCanvas(true, false);
    }

    if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
      canvasData.left = canvasData.oldLeft;
    }

    if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
      canvasData.top = canvasData.oldTop;
    }

    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);

    this.limitCanvas(false, true);

    canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
    canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;

    setStyle(this.canvas, extend({
      width: canvasData.width,
      height: canvasData.height
    }, getTransforms({
      translateX: canvasData.left,
      translateY: canvasData.top
    })));

    this.renderImage(changed);

    if (this.cropped && this.limited) {
      this.limitCropBox(true, true);
    }
  },
  renderImage: function renderImage(changed) {
    var canvasData = this.canvasData,
        imageData = this.imageData;

    var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
    var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);

    extend(imageData, {
      width: width,
      height: height,
      left: (canvasData.width - width) / 2,
      top: (canvasData.height - height) / 2
    });
    setStyle(this.image, extend({
      width: imageData.width,
      height: imageData.height
    }, getTransforms(extend({
      translateX: imageData.left,
      translateY: imageData.top
    }, imageData))));

    if (changed) {
      this.output();
    }
  },
  initCropBox: function initCropBox() {
    var options = this.options,
        canvasData = this.canvasData;
    var aspectRatio = options.aspectRatio;

    var autoCropArea = Number(options.autoCropArea) || 0.8;
    var cropBoxData = {
      width: canvasData.width,
      height: canvasData.height
    };

    if (aspectRatio) {
      if (canvasData.height * aspectRatio > canvasData.width) {
        cropBoxData.height = cropBoxData.width / aspectRatio;
      } else {
        cropBoxData.width = cropBoxData.height * aspectRatio;
      }
    }

    this.cropBoxData = cropBoxData;
    this.limitCropBox(true, true);

    // Initialize auto crop area
    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);

    // The width/height of auto crop area must large than "minWidth/Height"
    cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
    cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
    cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
    cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;

    this.initialCropBoxData = extend({}, cropBoxData);
  },
  limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
    var options = this.options,
        containerData = this.containerData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData,
        limited = this.limited;
    var aspectRatio = options.aspectRatio;


    if (sizeLimited) {
      var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
      var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
      var maxCropBoxWidth = Math.min(containerData.width, limited ? canvasData.width : containerData.width);
      var maxCropBoxHeight = Math.min(containerData.height, limited ? canvasData.height : containerData.height);

      // The min/maxCropBoxWidth/Height must be less than container's width/height
      minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
      minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

      if (aspectRatio) {
        if (minCropBoxWidth && minCropBoxHeight) {
          if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }
        } else if (minCropBoxWidth) {
          minCropBoxHeight = minCropBoxWidth / aspectRatio;
        } else if (minCropBoxHeight) {
          minCropBoxWidth = minCropBoxHeight * aspectRatio;
        }

        if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
          maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
        } else {
          maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
        }
      }

      // The minWidth/Height must be less than maxWidth/Height
      cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
      cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
      cropBoxData.maxWidth = maxCropBoxWidth;
      cropBoxData.maxHeight = maxCropBoxHeight;
    }

    if (positionLimited) {
      if (limited) {
        cropBoxData.minLeft = Math.max(0, canvasData.left);
        cropBoxData.minTop = Math.max(0, canvasData.top);
        cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
        cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
      } else {
        cropBoxData.minLeft = 0;
        cropBoxData.minTop = 0;
        cropBoxData.maxLeft = containerData.width - cropBoxData.width;
        cropBoxData.maxTop = containerData.height - cropBoxData.height;
      }
    }
  },
  renderCropBox: function renderCropBox() {
    var options = this.options,
        containerData = this.containerData,
        cropBoxData = this.cropBoxData;


    if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
      cropBoxData.left = cropBoxData.oldLeft;
    }

    if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
      cropBoxData.top = cropBoxData.oldTop;
    }

    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);

    this.limitCropBox(false, true);

    cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
    cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;

    if (options.movable && options.cropBoxMovable) {
      // Turn to move the canvas when the crop box is equal to the container
      setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
    }

    setStyle(this.cropBox, extend({
      width: cropBoxData.width,
      height: cropBoxData.height
    }, getTransforms({
      translateX: cropBoxData.left,
      translateY: cropBoxData.top
    })));

    if (this.cropped && this.limited) {
      this.limitCanvas(true, true);
    }

    if (!this.disabled) {
      this.output();
    }
  },
  output: function output() {
    this.preview();

    if (this.complete) {
      dispatchEvent(this.element, EVENT_CROP, this.getData());
    }
  }
};

var preview = {
  initPreview: function initPreview() {
    var crossOrigin = this.crossOrigin;
    var preview = this.options.preview;

    var url = crossOrigin ? this.crossOriginUrl : this.url;
    var image = document.createElement('img');

    if (crossOrigin) {
      image.crossOrigin = crossOrigin;
    }

    image.src = url;
    this.viewBox.appendChild(image);
    this.image2 = image;

    if (!preview) {
      return;
    }

    var previews = preview.querySelector ? [preview] : document.querySelectorAll(preview);

    this.previews = previews;

    each(previews, function (element) {
      var img = document.createElement('img');

      // Save the original size for recover
      setData(element, DATA_PREVIEW, {
        width: element.offsetWidth,
        height: element.offsetHeight,
        html: element.innerHTML
      });

      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }

      img.src = url;

      /**
       * Override img element styles
       * Add `display:block` to avoid margin top issue
       * Add `height:auto` to override `height` attribute on IE8
       * (Occur only when margin-top <= -height)
       */
      img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';

      empty(element);
      element.appendChild(img);
    });
  },
  resetPreview: function resetPreview() {
    each(this.previews, function (element) {
      var data = getData(element, DATA_PREVIEW);

      setStyle(element, {
        width: data.width,
        height: data.height
      });

      element.innerHTML = data.html;
      removeData(element, DATA_PREVIEW);
    });
  },
  preview: function preview() {
    var imageData = this.imageData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var cropBoxWidth = cropBoxData.width,
        cropBoxHeight = cropBoxData.height;
    var width = imageData.width,
        height = imageData.height;

    var left = cropBoxData.left - canvasData.left - imageData.left;
    var top = cropBoxData.top - canvasData.top - imageData.top;

    if (!this.cropped || this.disabled) {
      return;
    }

    setStyle(this.image2, extend({
      width: width,
      height: height
    }, getTransforms(extend({
      translateX: -left,
      translateY: -top
    }, imageData))));

    each(this.previews, function (element) {
      var data = getData(element, DATA_PREVIEW);
      var originalWidth = data.width;
      var originalHeight = data.height;
      var newWidth = originalWidth;
      var newHeight = originalHeight;
      var ratio = 1;

      if (cropBoxWidth) {
        ratio = originalWidth / cropBoxWidth;
        newHeight = cropBoxHeight * ratio;
      }

      if (cropBoxHeight && newHeight > originalHeight) {
        ratio = originalHeight / cropBoxHeight;
        newWidth = cropBoxWidth * ratio;
        newHeight = originalHeight;
      }

      setStyle(element, {
        width: newWidth,
        height: newHeight
      });

      setStyle(element.getElementsByTagName('img')[0], extend({
        width: width * ratio,
        height: height * ratio
      }, getTransforms(extend({
        translateX: -left * ratio,
        translateY: -top * ratio
      }, imageData))));
    });
  }
};

var events = {
  bind: function bind() {
    var element = this.element,
        options = this.options,
        cropper = this.cropper;


    if (isFunction(options.cropstart)) {
      addListener(element, EVENT_CROP_START, options.cropstart);
    }

    if (isFunction(options.cropmove)) {
      addListener(element, EVENT_CROP_MOVE, options.cropmove);
    }

    if (isFunction(options.cropend)) {
      addListener(element, EVENT_CROP_END, options.cropend);
    }

    if (isFunction(options.crop)) {
      addListener(element, EVENT_CROP, options.crop);
    }

    if (isFunction(options.zoom)) {
      addListener(element, EVENT_ZOOM, options.zoom);
    }

    addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = proxy(this.cropStart, this));

    if (options.zoomable && options.zoomOnWheel) {
      addListener(cropper, EVENT_WHEEL, this.onWheel = proxy(this.wheel, this));
    }

    if (options.toggleDragModeOnDblclick) {
      addListener(cropper, EVENT_DBLCLICK, this.onDblclick = proxy(this.dblclick, this));
    }

    addListener(document, EVENT_POINTER_MOVE, this.onCropMove = proxy(this.cropMove, this));
    addListener(document, EVENT_POINTER_UP, this.onCropEnd = proxy(this.cropEnd, this));

    if (options.responsive) {
      addListener(window, EVENT_RESIZE, this.onResize = proxy(this.resize, this));
    }
  },
  unbind: function unbind() {
    var element = this.element,
        options = this.options,
        cropper = this.cropper;


    if (isFunction(options.cropstart)) {
      removeListener(element, EVENT_CROP_START, options.cropstart);
    }

    if (isFunction(options.cropmove)) {
      removeListener(element, EVENT_CROP_MOVE, options.cropmove);
    }

    if (isFunction(options.cropend)) {
      removeListener(element, EVENT_CROP_END, options.cropend);
    }

    if (isFunction(options.crop)) {
      removeListener(element, EVENT_CROP, options.crop);
    }

    if (isFunction(options.zoom)) {
      removeListener(element, EVENT_ZOOM, options.zoom);
    }

    removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

    if (options.zoomable && options.zoomOnWheel) {
      removeListener(cropper, EVENT_WHEEL, this.onWheel);
    }

    if (options.toggleDragModeOnDblclick) {
      removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
    }

    removeListener(document, EVENT_POINTER_MOVE, this.onCropMove);
    removeListener(document, EVENT_POINTER_UP, this.onCropEnd);

    if (options.responsive) {
      removeListener(window, EVENT_RESIZE, this.onResize);
    }
  }
};

var handlers = {
  resize: function resize() {
    var options = this.options,
        container = this.container,
        containerData = this.containerData;

    var minContainerWidth = Number(options.minContainerWidth) || 200;
    var minContainerHeight = Number(options.minContainerHeight) || 100;

    if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {
      return;
    }

    var ratio = container.offsetWidth / containerData.width;

    // Resize when width changed or height changed
    if (ratio !== 1 || container.offsetHeight !== containerData.height) {
      var canvasData = void 0;
      var cropBoxData = void 0;

      if (options.restore) {
        canvasData = this.getCanvasData();
        cropBoxData = this.getCropBoxData();
      }

      this.render();

      if (options.restore) {
        this.setCanvasData(each(canvasData, function (n, i) {
          canvasData[i] = n * ratio;
        }));
        this.setCropBoxData(each(cropBoxData, function (n, i) {
          cropBoxData[i] = n * ratio;
        }));
      }
    }
  },
  dblclick: function dblclick() {
    if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
      return;
    }

    this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
  },
  wheel: function wheel(e) {
    var _this = this;

    var ratio = Number(this.options.wheelZoomRatio) || 0.1;
    var delta = 1;

    if (this.disabled) {
      return;
    }

    e.preventDefault();

    // Limit wheel speed to prevent zoom too fast (#21)
    if (this.wheeling) {
      return;
    }

    this.wheeling = true;

    setTimeout(function () {
      _this.wheeling = false;
    }, 50);

    if (e.deltaY) {
      delta = e.deltaY > 0 ? 1 : -1;
    } else if (e.wheelDelta) {
      delta = -e.wheelDelta / 120;
    } else if (e.detail) {
      delta = e.detail > 0 ? 1 : -1;
    }

    this.zoom(-delta * ratio, e);
  },
  cropStart: function cropStart(e) {
    if (this.disabled) {
      return;
    }

    var options = this.options,
        pointers = this.pointers;

    var action = void 0;

    if (e.changedTouches) {
      // Handle touch event
      each(e.changedTouches, function (touch) {
        pointers[touch.identifier] = getPointer(touch);
      });
    } else {
      // Handle mouse event and pointer event
      pointers[e.pointerId || 0] = getPointer(e);
    }

    if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
      action = ACTION_ZOOM;
    } else {
      action = getData(e.target, DATA_ACTION);
    }

    if (!REGEXP_ACTIONS.test(action)) {
      return;
    }

    if (dispatchEvent(this.element, EVENT_CROP_START, {
      originalEvent: e,
      action: action
    }) === false) {
      return;
    }

    e.preventDefault();

    this.action = action;
    this.cropping = false;

    if (action === ACTION_CROP) {
      this.cropping = true;
      addClass(this.dragBox, CLASS_MODAL);
    }
  },
  cropMove: function cropMove(e) {
    var action = this.action;


    if (this.disabled || !action) {
      return;
    }

    var pointers = this.pointers;


    e.preventDefault();

    if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
      originalEvent: e,
      action: action
    }) === false) {
      return;
    }

    if (e.changedTouches) {
      each(e.changedTouches, function (touch) {
        extend(pointers[touch.identifier], getPointer(touch, true));
      });
    } else {
      extend(pointers[e.pointerId || 0], getPointer(e, true));
    }

    this.change(e);
  },
  cropEnd: function cropEnd(e) {
    if (this.disabled) {
      return;
    }

    var action = this.action,
        pointers = this.pointers;


    if (e.changedTouches) {
      each(e.changedTouches, function (touch) {
        delete pointers[touch.identifier];
      });
    } else {
      delete pointers[e.pointerId || 0];
    }

    if (!action) {
      return;
    }

    e.preventDefault();

    if (!Object.keys(pointers).length) {
      this.action = '';
    }

    if (this.cropping) {
      this.cropping = false;
      toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
    }

    dispatchEvent(this.element, EVENT_CROP_END, {
      originalEvent: e,
      action: action
    });
  }
};

var change = {
  change: function change(e) {
    var options = this.options,
        canvasData = this.canvasData,
        containerData = this.containerData,
        cropBoxData = this.cropBoxData,
        pointers = this.pointers;
    var action = this.action;
    var aspectRatio = options.aspectRatio;
    var left = cropBoxData.left,
        top = cropBoxData.top,
        width = cropBoxData.width,
        height = cropBoxData.height;

    var right = left + width;
    var bottom = top + height;
    var minLeft = 0;
    var minTop = 0;
    var maxWidth = containerData.width;
    var maxHeight = containerData.height;
    var renderable = true;
    var offset = void 0;

    // Locking aspect ratio in "free mode" by holding shift key
    if (!aspectRatio && e.shiftKey) {
      aspectRatio = width && height ? width / height : 1;
    }

    if (this.limited) {
      minLeft = cropBoxData.minLeft;
      minTop = cropBoxData.minTop;

      maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
      maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
    }

    var pointer = pointers[Object.keys(pointers)[0]];
    var range = {
      x: pointer.endX - pointer.startX,
      y: pointer.endY - pointer.startY
    };
    var check = function check(side) {
      switch (side) {
        case ACTION_EAST:
          if (right + range.x > maxWidth) {
            range.x = maxWidth - right;
          }

          break;

        case ACTION_WEST:
          if (left + range.x < minLeft) {
            range.x = minLeft - left;
          }

          break;

        case ACTION_NORTH:
          if (top + range.y < minTop) {
            range.y = minTop - top;
          }

          break;

        case ACTION_SOUTH:
          if (bottom + range.y > maxHeight) {
            range.y = maxHeight - bottom;
          }

          break;

        default:
      }
    };

    switch (action) {
      // Move crop box
      case ACTION_ALL:
        left += range.x;
        top += range.y;
        break;

      // Resize crop box
      case ACTION_EAST:
        if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }

        check(ACTION_EAST);
        width += range.x;

        if (aspectRatio) {
          height = width / aspectRatio;
          top -= range.x / aspectRatio / 2;
        }

        if (width < 0) {
          action = ACTION_WEST;
          width = 0;
        }

        break;

      case ACTION_NORTH:
        if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }

        check(ACTION_NORTH);
        height -= range.y;
        top += range.y;

        if (aspectRatio) {
          width = height * aspectRatio;
          left += range.y * aspectRatio / 2;
        }

        if (height < 0) {
          action = ACTION_SOUTH;
          height = 0;
        }

        break;

      case ACTION_WEST:
        if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }

        check(ACTION_WEST);
        width -= range.x;
        left += range.x;

        if (aspectRatio) {
          height = width / aspectRatio;
          top += range.x / aspectRatio / 2;
        }

        if (width < 0) {
          action = ACTION_EAST;
          width = 0;
        }

        break;

      case ACTION_SOUTH:
        if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }

        check(ACTION_SOUTH);
        height += range.y;

        if (aspectRatio) {
          width = height * aspectRatio;
          left -= range.y * aspectRatio / 2;
        }

        if (height < 0) {
          action = ACTION_NORTH;
          height = 0;
        }

        break;

      case ACTION_NORTH_EAST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
        } else {
          check(ACTION_NORTH);
          check(ACTION_EAST);

          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width += range.x;
          }

          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_WEST;
          height = 0;
          width = 0;
        } else if (width < 0) {
          action = ACTION_NORTH_WEST;
          width = 0;
        } else if (height < 0) {
          action = ACTION_SOUTH_EAST;
          height = 0;
        }

        break;

      case ACTION_NORTH_WEST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
          left += range.y * aspectRatio;
        } else {
          check(ACTION_NORTH);
          check(ACTION_WEST);

          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }

          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_EAST;
          height = 0;
          width = 0;
        } else if (width < 0) {
          action = ACTION_NORTH_EAST;
          width = 0;
        } else if (height < 0) {
          action = ACTION_SOUTH_WEST;
          height = 0;
        }

        break;

      case ACTION_SOUTH_WEST:
        if (aspectRatio) {
          if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_WEST);

          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }

          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_NORTH_EAST;
          height = 0;
          width = 0;
        } else if (width < 0) {
          action = ACTION_SOUTH_EAST;
          width = 0;
        } else if (height < 0) {
          action = ACTION_NORTH_WEST;
          height = 0;
        }

        break;

      case ACTION_SOUTH_EAST:
        if (aspectRatio) {
          if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_EAST);

          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width += range.x;
          }

          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_NORTH_WEST;
          height = 0;
          width = 0;
        } else if (width < 0) {
          action = ACTION_SOUTH_WEST;
          width = 0;
        } else if (height < 0) {
          action = ACTION_NORTH_EAST;
          height = 0;
        }

        break;

      // Move canvas
      case ACTION_MOVE:
        this.move(range.x, range.y);
        renderable = false;
        break;

      // Zoom canvas
      case ACTION_ZOOM:
        this.zoom(getMaxZoomRatio(pointers), e);
        renderable = false;
        break;

      // Create crop box
      case ACTION_CROP:
        if (!range.x || !range.y) {
          renderable = false;
          break;
        }

        offset = getOffset(this.cropper);
        left = pointer.startX - offset.left;
        top = pointer.startY - offset.top;
        width = cropBoxData.minWidth;
        height = cropBoxData.minHeight;

        if (range.x > 0) {
          action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
        } else if (range.x < 0) {
          left -= width;
          action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
        }

        if (range.y < 0) {
          top -= height;
        }

        // Show the crop box if is hidden
        if (!this.cropped) {
          removeClass(this.cropBox, CLASS_HIDDEN);
          this.cropped = true;

          if (this.limited) {
            this.limitCropBox(true, true);
          }
        }

        break;

      default:
    }

    if (renderable) {
      cropBoxData.width = width;
      cropBoxData.height = height;
      cropBoxData.left = left;
      cropBoxData.top = top;
      this.action = action;
      this.renderCropBox();
    }

    // Override
    each(pointers, function (p) {
      p.startX = p.endX;
      p.startY = p.endY;
    });
  }
};

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var methods = {
  // Show the crop box manually
  crop: function crop() {
    if (this.ready && !this.disabled) {
      if (!this.cropped) {
        this.cropped = true;
        this.limitCropBox(true, true);

        if (this.options.modal) {
          addClass(this.dragBox, CLASS_MODAL);
        }

        removeClass(this.cropBox, CLASS_HIDDEN);
      }

      this.setCropBoxData(this.initialCropBoxData);
    }

    return this;
  },


  // Reset the image and crop box to their initial states
  reset: function reset() {
    if (this.ready && !this.disabled) {
      this.imageData = extend({}, this.initialImageData);
      this.canvasData = extend({}, this.initialCanvasData);
      this.cropBoxData = extend({}, this.initialCropBoxData);
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    }

    return this;
  },


  // Clear the crop box
  clear: function clear() {
    if (this.cropped && !this.disabled) {
      extend(this.cropBoxData, {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      });

      this.cropped = false;
      this.renderCropBox();
      this.limitCanvas(true, true);

      // Render canvas after crop box rendered
      this.renderCanvas();
      removeClass(this.dragBox, CLASS_MODAL);
      addClass(this.cropBox, CLASS_HIDDEN);
    }

    return this;
  },


  /**
   * Replace the image's src and rebuild the cropper
   * @param {string} url - The new URL.
   * @param {boolean} [onlyColorChanged] - Indicate if the new image only changed color.
   * @returns {Object} this
   */
  replace: function replace(url) {
    var onlyColorChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!this.disabled && url) {
      if (this.isImg) {
        this.element.src = url;
      }

      if (onlyColorChanged) {
        this.url = url;
        this.image.src = url;

        if (this.ready) {
          this.image2.src = url;

          each(this.previews, function (element) {
            element.getElementsByTagName('img')[0].src = url;
          });
        }
      } else {
        if (this.isImg) {
          this.replaced = true;
        }

        // Clear previous data
        this.options.data = null;
        this.load(url);
      }
    }

    return this;
  },


  // Enable (unfreeze) the cropper
  enable: function enable() {
    if (this.ready) {
      this.disabled = false;
      removeClass(this.cropper, CLASS_DISABLED);
    }

    return this;
  },


  // Disable (freeze) the cropper
  disable: function disable() {
    if (this.ready) {
      this.disabled = true;
      addClass(this.cropper, CLASS_DISABLED);
    }

    return this;
  },


  // Destroy the cropper and remove the instance from the image
  destroy: function destroy() {
    var element = this.element,
        image = this.image;


    if (this.loaded) {
      if (this.isImg && this.replaced) {
        element.src = this.originalUrl;
      }

      this.unbuild();
      removeClass(element, CLASS_HIDDEN);
    } else if (this.isImg) {
      removeListener(element, EVENT_LOAD, this.onStart);
    } else if (image) {
      image.parentNode.removeChild(image);
    }

    removeData(element, NAMESPACE);

    return this;
  },


  /**
   * Move the canvas with relative offsets
   * @param {number} offsetX - The relative offset distance on the x-axis.
   * @param {number} offsetY - The relative offset distance on the y-axis.
   * @returns {Object} this
   */
  move: function move(offsetX, offsetY) {
    var _canvasData = this.canvasData,
        left = _canvasData.left,
        top = _canvasData.top;


    return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
  },


  /**
   * Move the canvas to an absolute point
   * @param {number} x - The x-axis coordinate.
   * @param {number} [y=x] - The y-axis coordinate.
   * @returns {Object} this
   */
  moveTo: function moveTo(x) {
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
    var canvasData = this.canvasData;

    var changed = false;

    x = Number(x);
    y = Number(y);

    if (this.ready && !this.disabled && this.options.movable) {
      if (isNumber(x)) {
        canvasData.left = x;
        changed = true;
      }

      if (isNumber(y)) {
        canvasData.top = y;
        changed = true;
      }

      if (changed) {
        this.renderCanvas(true);
      }
    }

    return this;
  },


  /**
   * Zoom the canvas with a relative ratio
   * @param {number} ratio - The target ratio.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Object} this
   */
  zoom: function zoom(ratio, _originalEvent) {
    var canvasData = this.canvasData;


    ratio = Number(ratio);

    if (ratio < 0) {
      ratio = 1 / (1 - ratio);
    } else {
      ratio = 1 + ratio;
    }

    return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, _originalEvent);
  },


  /**
   * Zoom the canvas to an absolute ratio
   * @param {number} ratio - The target ratio.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Object} this
   */
  zoomTo: function zoomTo(ratio, _originalEvent) {
    var options = this.options,
        canvasData = this.canvasData;
    var width = canvasData.width,
        height = canvasData.height,
        naturalWidth = canvasData.naturalWidth,
        naturalHeight = canvasData.naturalHeight;


    ratio = Number(ratio);

    if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
      var newWidth = naturalWidth * ratio;
      var newHeight = naturalHeight * ratio;

      if (dispatchEvent(this.element, EVENT_ZOOM, {
        originalEvent: _originalEvent,
        oldRatio: width / naturalWidth,
        ratio: newWidth / naturalWidth
      }) === false) {
        return this;
      }

      if (_originalEvent) {
        var pointers = this.pointers;

        var offset = getOffset(this.cropper);
        var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
          pageX: _originalEvent.pageX,
          pageY: _originalEvent.pageY
        };

        // Zoom from the triggering point of the event
        canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
        canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
      } else {
        // Zoom from the center of the canvas
        canvasData.left -= (newWidth - width) / 2;
        canvasData.top -= (newHeight - height) / 2;
      }

      canvasData.width = newWidth;
      canvasData.height = newHeight;
      this.renderCanvas(true);
    }

    return this;
  },


  /**
   * Rotate the canvas with a relative degree
   * @param {number} degree - The rotate degree.
   * @returns {Object} this
   */
  rotate: function rotate(degree) {
    return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
  },


  /**
   * Rotate the canvas to an absolute degree
   * @param {number} degree - The rotate degree.
   * @returns {Object} this
   */
  rotateTo: function rotateTo(degree) {
    degree = Number(degree);

    if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
      this.imageData.rotate = degree % 360;
      this.renderCanvas(true, true);
    }

    return this;
  },


  /**
   * Scale the image on the x-axis.
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @returns {Object} this
   */
  scaleX: function scaleX(_scaleX) {
    var scaleY = this.imageData.scaleY;


    return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
  },


  /**
   * Scale the image on the y-axis.
   * @param {number} scaleY - The scale ratio on the y-axis.
   * @returns {Object} this
   */
  scaleY: function scaleY(_scaleY) {
    var scaleX = this.imageData.scaleX;


    return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
  },


  /**
   * Scale the image
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
   * @returns {Object} this
   */
  scale: function scale(scaleX) {
    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
    var imageData = this.imageData;

    var transformed = false;

    scaleX = Number(scaleX);
    scaleY = Number(scaleY);

    if (this.ready && !this.disabled && this.options.scalable) {
      if (isNumber(scaleX)) {
        imageData.scaleX = scaleX;
        transformed = true;
      }

      if (isNumber(scaleY)) {
        imageData.scaleY = scaleY;
        transformed = true;
      }

      if (transformed) {
        this.renderCanvas(true, true);
      }
    }

    return this;
  },


  /**
   * Get the cropped area position and size data (base on the original image)
   * @param {boolean} [rounded=false] - Indicate if round the data values or not.
   * @returns {Object} The result cropped data.
   */
  getData: function getData$$1() {
    var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var options = this.options,
        imageData = this.imageData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;

    var data = void 0;

    if (this.ready && this.cropped) {
      data = {
        x: cropBoxData.left - canvasData.left,
        y: cropBoxData.top - canvasData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };

      var ratio = imageData.width / imageData.naturalWidth;

      each(data, function (n, i) {
        n /= ratio;
        data[i] = rounded ? Math.round(n) : n;
      });
    } else {
      data = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }

    if (options.rotatable) {
      data.rotate = imageData.rotate || 0;
    }

    if (options.scalable) {
      data.scaleX = imageData.scaleX || 1;
      data.scaleY = imageData.scaleY || 1;
    }

    return data;
  },


  /**
   * Set the cropped area position and size with new data
   * @param {Object} data - The new data.
   * @returns {Object} this
   */
  setData: function setData$$1(data) {
    var options = this.options,
        imageData = this.imageData,
        canvasData = this.canvasData;

    var cropBoxData = {};

    if (isFunction(data)) {
      data = data.call(this.element);
    }

    if (this.ready && !this.disabled && isPlainObject(data)) {
      var transformed = false;

      if (options.rotatable) {
        if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
          imageData.rotate = data.rotate;
          transformed = true;
        }
      }

      if (options.scalable) {
        if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
          imageData.scaleX = data.scaleX;
          transformed = true;
        }

        if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
          imageData.scaleY = data.scaleY;
          transformed = true;
        }
      }

      if (transformed) {
        this.renderCanvas(true, true);
      }

      var ratio = imageData.width / imageData.naturalWidth;

      if (isNumber(data.x)) {
        cropBoxData.left = data.x * ratio + canvasData.left;
      }

      if (isNumber(data.y)) {
        cropBoxData.top = data.y * ratio + canvasData.top;
      }

      if (isNumber(data.width)) {
        cropBoxData.width = data.width * ratio;
      }

      if (isNumber(data.height)) {
        cropBoxData.height = data.height * ratio;
      }

      this.setCropBoxData(cropBoxData);
    }

    return this;
  },


  /**
   * Get the container size data.
   * @returns {Object} The result container data.
   */
  getContainerData: function getContainerData() {
    return this.ready ? extend({}, this.containerData) : {};
  },


  /**
   * Get the image position and size data.
   * @returns {Object} The result image data.
   */
  getImageData: function getImageData() {
    return this.loaded ? extend({}, this.imageData) : {};
  },


  /**
   * Get the canvas position and size data.
   * @returns {Object} The result canvas data.
   */
  getCanvasData: function getCanvasData() {
    var canvasData = this.canvasData;

    var data = {};

    if (this.ready) {
      each(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
        data[n] = canvasData[n];
      });
    }

    return data;
  },


  /**
   * Set the canvas position and size with new data.
   * @param {Object} data - The new canvas data.
   * @returns {Object} this
   */
  setCanvasData: function setCanvasData(data) {
    var canvasData = this.canvasData;
    var aspectRatio = canvasData.aspectRatio;


    if (isFunction(data)) {
      data = data.call(this.element);
    }

    if (this.ready && !this.disabled && isPlainObject(data)) {
      if (isNumber(data.left)) {
        canvasData.left = data.left;
      }

      if (isNumber(data.top)) {
        canvasData.top = data.top;
      }

      if (isNumber(data.width)) {
        canvasData.width = data.width;
        canvasData.height = data.width / aspectRatio;
      } else if (isNumber(data.height)) {
        canvasData.height = data.height;
        canvasData.width = data.height * aspectRatio;
      }

      this.renderCanvas(true);
    }

    return this;
  },


  /**
   * Get the crop box position and size data.
   * @returns {Object} The result crop box data.
   */
  getCropBoxData: function getCropBoxData() {
    var cropBoxData = this.cropBoxData;

    var data = void 0;

    if (this.ready && this.cropped) {
      data = {
        left: cropBoxData.left,
        top: cropBoxData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };
    }

    return data || {};
  },


  /**
   * Set the crop box position and size with new data.
   * @param {Object} data - The new crop box data.
   * @returns {Object} this
   */
  setCropBoxData: function setCropBoxData(data) {
    var cropBoxData = this.cropBoxData;
    var aspectRatio = this.options.aspectRatio;

    var widthChanged = void 0;
    var heightChanged = void 0;

    if (isFunction(data)) {
      data = data.call(this.element);
    }

    if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
      if (isNumber(data.left)) {
        cropBoxData.left = data.left;
      }

      if (isNumber(data.top)) {
        cropBoxData.top = data.top;
      }

      if (isNumber(data.width) && data.width !== cropBoxData.width) {
        widthChanged = true;
        cropBoxData.width = data.width;
      }

      if (isNumber(data.height) && data.height !== cropBoxData.height) {
        heightChanged = true;
        cropBoxData.height = data.height;
      }

      if (aspectRatio) {
        if (widthChanged) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else if (heightChanged) {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.renderCropBox();
    }

    return this;
  },


  /**
   * Get a canvas drawn the cropped image.
   * @param {Object} [options={}] - The config options.
   * @returns {HTMLCanvasElement} - The result canvas.
   */
  getCroppedCanvas: function getCroppedCanvas() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!this.ready || !window.HTMLCanvasElement) {
      return null;
    }

    var canvasData = this.canvasData;

    var source = getSourceCanvas(this.image, this.imageData, canvasData, options);

    // Returns the source canvas if it is not cropped.
    if (!this.cropped) {
      return source;
    }

    var _getData = this.getData(),
        x = _getData.x,
        y = _getData.y,
        initialWidth = _getData.width,
        initialHeight = _getData.height;

    var aspectRatio = initialWidth / initialHeight;
    var maxSizes = getContainSizes({
      aspectRatio: aspectRatio,
      width: options.maxWidth || Infinity,
      height: options.maxHeight || Infinity
    });
    var minSizes = getContainSizes({
      aspectRatio: aspectRatio,
      width: options.minWidth || 0,
      height: options.minHeight || 0
    });

    var _getContainSizes = getContainSizes({
      aspectRatio: aspectRatio,
      width: options.width || initialWidth,
      height: options.height || initialHeight
    }),
        width = _getContainSizes.width,
        height = _getContainSizes.height;

    width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
    height = Math.min(maxSizes.height, Math.max(minSizes.height, height));

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);

    context.fillStyle = options.fillColor || 'transparent';
    context.fillRect(0, 0, width, height);

    var _options$imageSmoothi = options.imageSmoothingEnabled,
        imageSmoothingEnabled = _options$imageSmoothi === undefined ? true : _options$imageSmoothi,
        imageSmoothingQuality = options.imageSmoothingQuality;


    context.imageSmoothingEnabled = imageSmoothingEnabled;

    if (imageSmoothingQuality) {
      context.imageSmoothingQuality = imageSmoothingQuality;
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage
    var sourceWidth = source.width;
    var sourceHeight = source.height;

    // Source canvas parameters
    var srcX = x;
    var srcY = y;
    var srcWidth = void 0;
    var srcHeight = void 0;

    // Destination canvas parameters
    var dstX = void 0;
    var dstY = void 0;
    var dstWidth = void 0;
    var dstHeight = void 0;

    if (srcX <= -initialWidth || srcX > sourceWidth) {
      srcX = 0;
      srcWidth = 0;
      dstX = 0;
      dstWidth = 0;
    } else if (srcX <= 0) {
      dstX = -srcX;
      srcX = 0;
      srcWidth = Math.min(sourceWidth, initialWidth + srcX);
      dstWidth = srcWidth;
    } else if (srcX <= sourceWidth) {
      dstX = 0;
      srcWidth = Math.min(initialWidth, sourceWidth - srcX);
      dstWidth = srcWidth;
    }

    if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
      srcY = 0;
      srcHeight = 0;
      dstY = 0;
      dstHeight = 0;
    } else if (srcY <= 0) {
      dstY = -srcY;
      srcY = 0;
      srcHeight = Math.min(sourceHeight, initialHeight + srcY);
      dstHeight = srcHeight;
    } else if (srcY <= sourceHeight) {
      dstY = 0;
      srcHeight = Math.min(initialHeight, sourceHeight - srcY);
      dstHeight = srcHeight;
    }

    // All the numerical parameters should be integer for `drawImage`
    // https://github.com/fengyuanchen/cropper/issues/476
    var params = [srcX, srcY, srcWidth, srcHeight];

    // Avoid "IndexSizeError"
    if (dstWidth > 0 && dstHeight > 0) {
      var scale = width / initialWidth;

      params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
    }

    context.drawImage.apply(context, [source].concat(_toConsumableArray$1(params.map(function (param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));

    return canvas;
  },


  /**
   * Change the aspect ratio of the crop box.
   * @param {number} aspectRatio - The new aspect ratio.
   * @returns {Object} this
   */
  setAspectRatio: function setAspectRatio(aspectRatio) {
    var options = this.options;


    if (!this.disabled && !isUndefined(aspectRatio)) {
      // 0 -> NaN
      options.aspectRatio = Math.max(0, aspectRatio) || NaN;

      if (this.ready) {
        this.initCropBox();

        if (this.cropped) {
          this.renderCropBox();
        }
      }
    }

    return this;
  },


  /**
   * Change the drag mode.
   * @param {string} mode - The new drag mode.
   * @returns {Object} this
   */
  setDragMode: function setDragMode(mode) {
    var options = this.options,
        dragBox = this.dragBox,
        face = this.face;


    if (this.loaded && !this.disabled) {
      var croppable = mode === DRAG_MODE_CROP;
      var movable = options.movable && mode === DRAG_MODE_MOVE;

      mode = croppable || movable ? mode : DRAG_MODE_NONE;

      setData(dragBox, DATA_ACTION, mode);
      toggleClass(dragBox, CLASS_CROP, croppable);
      toggleClass(dragBox, CLASS_MOVE, movable);

      if (!options.cropBoxMovable) {
        // Sync drag mode to crop box when it is not movable
        setData(face, DATA_ACTION, mode);
        toggleClass(face, CLASS_CROP, croppable);
        toggleClass(face, CLASS_MOVE, movable);
      }
    }

    return this;
  }
};

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AnotherCropper = WINDOW.Cropper;

var Cropper = function () {
  /**
   * Create a new Cropper.
   * @param {Element} element - The target element for cropping.
   * @param {Object} [options={}] - The configuration options.
   */
  function Cropper(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Cropper);

    if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
      throw new Error('The first argument is required and must be an <img> or <canvas> element.');
    }

    this.element = element;
    this.options = extend({}, DEFAULTS, isPlainObject(options) && options);
    this.complete = false;
    this.cropped = false;
    this.disabled = false;
    this.isImg = false;
    this.limited = false;
    this.loaded = false;
    this.ready = false;
    this.replaced = false;
    this.wheeling = false;
    this.originalUrl = '';
    this.canvasData = null;
    this.cropBoxData = null;
    this.previews = null;
    this.pointers = {};
    this.init();
  }

  _createClass(Cropper, [{
    key: 'init',
    value: function init() {
      var element = this.element;

      var tagName = element.tagName.toLowerCase();
      var url = void 0;

      if (getData(element, NAMESPACE)) {
        return;
      }

      setData(element, NAMESPACE, this);

      if (tagName === 'img') {
        this.isImg = true;

        // e.g.: "img/picture.jpg"
        url = element.getAttribute('src') || '';
        this.originalUrl = url;

        // Stop when it's a blank image
        if (!url) {
          return;
        }

        // e.g.: "http://example.com/img/picture.jpg"
        url = element.src;
      } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
        url = element.toDataURL();
      }

      this.load(url);
    }
  }, {
    key: 'load',
    value: function load(url) {
      var _this = this;

      if (!url) {
        return;
      }

      this.url = url;
      this.imageData = {};

      var element = this.element,
          options = this.options;


      if (!options.checkOrientation || !window.ArrayBuffer) {
        this.clone();
        return;
      }

      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari
      if (REGEXP_DATA_URL.test(url)) {
        if (REGEXP_DATA_URL_JPEG.test(url)) {
          this.read(dataURLToArrayBuffer(url));
        } else {
          this.clone();
        }

        return;
      }

      var xhr = new XMLHttpRequest();

      xhr.onerror = function () {
        _this.clone();
      };

      xhr.onload = function () {
        _this.read(xhr.response);
      };

      if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
        url = addTimestamp(url);
      }

      xhr.open('get', url);
      xhr.responseType = 'arraybuffer';
      xhr.withCredentials = element.crossOrigin === 'use-credentials';
      xhr.send();
    }
  }, {
    key: 'read',
    value: function read(arrayBuffer) {
      var options = this.options,
          imageData = this.imageData;

      var orientation = getOrientation(arrayBuffer);
      var rotate = 0;
      var scaleX = 1;
      var scaleY = 1;

      if (orientation > 1) {
        this.url = arrayBufferToDataURL(arrayBuffer, 'image/jpeg');

        var _parseOrientation = parseOrientation(orientation);

        rotate = _parseOrientation.rotate;
        scaleX = _parseOrientation.scaleX;
        scaleY = _parseOrientation.scaleY;
      }

      if (options.rotatable) {
        imageData.rotate = rotate;
      }

      if (options.scalable) {
        imageData.scaleX = scaleX;
        imageData.scaleY = scaleY;
      }

      this.clone();
    }
  }, {
    key: 'clone',
    value: function clone() {
      var element = this.element,
          url = this.url;

      var crossOrigin = void 0;
      var crossOriginUrl = void 0;

      if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
        crossOrigin = element.crossOrigin;


        if (crossOrigin) {
          crossOriginUrl = url;
        } else {
          crossOrigin = 'anonymous';

          // Bust cache when there is not a "crossOrigin" property
          crossOriginUrl = addTimestamp(url);
        }
      }

      this.crossOrigin = crossOrigin;
      this.crossOriginUrl = crossOriginUrl;

      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = crossOriginUrl || url;

      var start = proxy(this.start, this);
      var stop = proxy(this.stop, this);

      this.image = image;
      this.onStart = start;
      this.onStop = stop;

      if (this.isImg) {
        if (element.complete) {
          this.start();
        } else {
          addListener(element, EVENT_LOAD, start);
        }
      } else {
        addListener(image, EVENT_LOAD, start);
        addListener(image, EVENT_ERROR, stop);
        addClass(image, CLASS_HIDE);
        element.parentNode.insertBefore(image, element.nextSibling);
      }
    }
  }, {
    key: 'start',
    value: function start(event) {
      var _this2 = this;

      var image = this.isImg ? this.element : this.image;

      if (event) {
        removeListener(image, EVENT_LOAD, this.onStart);
        removeListener(image, EVENT_ERROR, this.onStop);
      }

      getImageNaturalSizes(image, function (naturalWidth, naturalHeight) {
        extend(_this2.imageData, {
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight,
          aspectRatio: naturalWidth / naturalHeight
        });
        _this2.loaded = true;
        _this2.build();
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      var image = this.image;


      removeListener(image, EVENT_LOAD, this.onStart);
      removeListener(image, EVENT_ERROR, this.onStop);
      image.parentNode.removeChild(image);
      this.image = null;
    }
  }, {
    key: 'build',
    value: function build() {
      var _this3 = this;

      if (!this.loaded) {
        return;
      }

      // Unbuild first when replace
      if (this.ready) {
        this.unbuild();
      }

      var element = this.element,
          options = this.options,
          image = this.image;

      // Create cropper elements

      var container = element.parentNode;
      var template = document.createElement('div');

      template.innerHTML = TEMPLATE;

      var cropper = template.querySelector('.' + NAMESPACE + '-container');
      var canvas = cropper.querySelector('.' + NAMESPACE + '-canvas');
      var dragBox = cropper.querySelector('.' + NAMESPACE + '-drag-box');
      var cropBox = cropper.querySelector('.' + NAMESPACE + '-crop-box');
      var face = cropBox.querySelector('.' + NAMESPACE + '-face');

      this.container = container;
      this.cropper = cropper;
      this.canvas = canvas;
      this.dragBox = dragBox;
      this.cropBox = cropBox;
      this.viewBox = cropper.querySelector('.' + NAMESPACE + '-view-box');
      this.face = face;

      canvas.appendChild(image);

      // Hide the original image
      addClass(element, CLASS_HIDDEN);

      // Inserts the cropper after to the current image
      container.insertBefore(cropper, element.nextSibling);

      // Show the image if is hidden
      if (!this.isImg) {
        removeClass(image, CLASS_HIDE);
      }

      this.initPreview();
      this.bind();

      options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
      options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;

      this.cropped = options.autoCrop;

      if (options.autoCrop) {
        if (options.modal) {
          addClass(dragBox, CLASS_MODAL);
        }
      } else {
        addClass(cropBox, CLASS_HIDDEN);
      }

      if (!options.guides) {
        addClass(cropBox.getElementsByClassName(NAMESPACE + '-dashed'), CLASS_HIDDEN);
      }

      if (!options.center) {
        addClass(cropBox.getElementsByClassName(NAMESPACE + '-center'), CLASS_HIDDEN);
      }

      if (options.background) {
        addClass(cropper, NAMESPACE + '-bg');
      }

      if (!options.highlight) {
        addClass(face, CLASS_INVISIBLE);
      }

      if (options.cropBoxMovable) {
        addClass(face, CLASS_MOVE);
        setData(face, DATA_ACTION, ACTION_ALL);
      }

      if (!options.cropBoxResizable) {
        addClass(cropBox.getElementsByClassName(NAMESPACE + '-line'), CLASS_HIDDEN);
        addClass(cropBox.getElementsByClassName(NAMESPACE + '-point'), CLASS_HIDDEN);
      }

      this.setDragMode(options.dragMode);
      this.render();
      this.ready = true;
      this.setData(options.data);

      // Call the "ready" option asynchronously to keep "image.cropper" is defined
      this.completing = setTimeout(function () {
        if (isFunction(options.ready)) {
          addListener(element, EVENT_READY, options.ready, {
            once: true
          });
        }

        dispatchEvent(element, EVENT_READY);
        dispatchEvent(element, EVENT_CROP, _this3.getData());

        _this3.complete = true;
      }, 0);
    }
  }, {
    key: 'unbuild',
    value: function unbuild() {
      if (!this.ready) {
        return;
      }

      if (!this.complete) {
        clearTimeout(this.completing);
      }

      this.ready = false;
      this.complete = false;
      this.initialImageData = null;

      // Clear `initialCanvasData` is necessary when replace
      this.initialCanvasData = null;
      this.initialCropBoxData = null;
      this.containerData = null;
      this.canvasData = null;

      // Clear `cropBoxData` is necessary when replace
      this.cropBoxData = null;
      this.unbind();
      this.resetPreview();
      this.previews = null;
      this.viewBox = null;
      this.cropBox = null;
      this.dragBox = null;
      this.canvas = null;
      this.container = null;
      this.cropper.parentNode.removeChild(this.cropper);
      this.cropper = null;
    }

    /**
     * Get the no conflict cropper class.
     * @returns {Cropper} The cropper class.
     */

  }], [{
    key: 'noConflict',
    value: function noConflict() {
      window.Cropper = AnotherCropper;
      return Cropper;
    }

    /**
     * Change the default options.
     * @param {Object} options - The new default options.
     */

  }, {
    key: 'setDefaults',
    value: function setDefaults(options) {
      extend(DEFAULTS, isPlainObject(options) && options);
    }
  }]);

  return Cropper;
}();

extend(Cropper.prototype, render, preview, events, handlers, change, methods);

return Cropper;

})));


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_default_data__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_default_watch__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_default_methods__ = __webpack_require__(50);





var module = function module() {
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-loader', __webpack_require__(51));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-modal', __webpack_require__(54));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-navigation-burger', __webpack_require__(57));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-sidebar', __webpack_require__(60));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-sidebar-item', __webpack_require__(63));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-tooltip', __webpack_require__(66));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-flash', __webpack_require__(71));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-tags-input', __webpack_require__(74));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-tabs', __webpack_require__(77));
    __WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('laramin-tab', __webpack_require__(80));

    window.laramin = new __WEBPACK_IMPORTED_MODULE_0_vue___default.a({
        el: '#laramin',
        data: __WEBPACK_IMPORTED_MODULE_1__lib_default_data__["a" /* default */],
        watch: __WEBPACK_IMPORTED_MODULE_2__lib_default_watch__["a" /* default */],
        methods: __WEBPACK_IMPORTED_MODULE_3__lib_default_methods__["a" /* default */]
    });
};

/* harmony default export */ __webpack_exports__["a"] = (module);

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.5.2
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */


/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */


var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.functionalOptions = undefined;
  this.functionalScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode, deep) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  if (deep && vnode.children) {
    cloned.children = cloneVNodes(vnode.children);
  }
  return cloned
}

function cloneVNodes (vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "development" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "development" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this) : parentVal
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "development" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn.call(this, parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "development" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      );
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if ("development" !== 'production' && inject) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ("development" !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (true) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ("development" !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', ')) +
      ", got " + (toRawType(value)) + ".",
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

function handleError (err, vm, info) {
  if (vm) {
    var cur = vm;
    while ((cur = cur.$parent)) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) { return }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if (inBrowser && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res
  })
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "development" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "development" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      data && data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "development" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      "development" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ("development" !== 'production' && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if ("development" !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (methods[key] == null) {
        warn(
          "Method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject).filter(function (key) {
          /* istanbul ignore next */
          return Object.getOwnPropertyDescriptor(inject, key).enumerable
        })
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if ("development" !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "development" !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias,
  eventKeyName
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1
    } else {
      return keyCodes !== eventKeyCode
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  // static trees can be rendered once and cached on the contructor options
  // so every instance shares the same cached trees
  var renderFns = this.$options.staticRenderFns;
  var cached = renderFns.cached || (renderFns.cached = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = renderFns[index].call(this._renderProxy, null, this);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "development" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () { return resolveSlots(children, parent); };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.functionalScopeId = options._scopeId;
        vnode.functionalContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.functionalContext = contextVm;
    vnode.functionalOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "development" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ("development" !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        if (slot._rendered) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (true) {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

var uid$1 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$1++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if ("development" !== 'production' &&
    !(this instanceof Vue$3)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (true) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        );
      }
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (true) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            );
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && cached$$1 !== current) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }

      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.5.2';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "development" !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove () {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          inPre++;
        }
        if (
          !inPre &&
          !vnode.ns &&
          !(
            config.ignoredElements.length &&
            config.ignoredElements.some(function (ignore) {
              return isRegExp(ignore)
                ? ignore.test(tag)
                : ignore === tag
            })
          ) &&
          config.isUnknownElement(tag)
        ) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.functionalScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.functionalContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if ("development" !== 'production' && !vnodeToMove) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    if (true) {
      if (!assertNodeMatch(elm, vnode)) {
        return false
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("development" !== 'production' &&
                typeof console !== 'undefined' &&
                !bailed
              ) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("development" !== 'production' &&
                typeof console !== 'undefined' &&
                !bailed
              ) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf('vue-component') === 0 ||
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (true) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE9 || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + "," + args)
  }
}

/*  */

function baseWarn (msg) {
  console.error(("[Vue compiler]: " + msg));
}

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr (el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  modifiers
) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn
) {
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
    "development" !== 'production' && warn &&
    modifiers && modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    );
  }
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers && modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
        "? " + baseValueExpression + ".trim()" +
        ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: ("\"" + value + "\""),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;



function parseModel (val) {
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead."
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (true) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.'
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
      "?_i(" + value + "," + valueBinding + ")>-1" + (
        trueValueBinding === 'true'
          ? (":(" + value + ")")
          : (":_q(" + value + "," + trueValueBinding + ")")
      )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + value + "=$$a.concat([$$v]))}" +
      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
    el,
    value,
    modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler (handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  handler = withMacroTask(handler);
  if (once$$1) { handler = createOnceHandler(handler, event, capture); }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
}

function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isInputChanged (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal)
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim()
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def) {
  if (!def) {
    return
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res
  } else if (typeof def === 'string') {
    return autoCssTransition(def)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ("development" !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ("development" !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if ("development" !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if ("development" !== 'production' &&
    config.productionTip !== false &&
    inBrowser && typeof console !== 'undefined'
  ) {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode (content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\"/>";
  return div.innerHTML.indexOf(encoded) > 0
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});

function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+')
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ("development" !== 'production' && staticClass) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.'
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.'
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!--([\s\S]*?)-->/g, '$1')
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ("development" !== 'production' && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') { delete args[3]; }
        if (args[4] === '') { delete args[4]; }
        if (args[5] === '') { delete args[5]; }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(
          value,
          options.shouldDecodeNewlines
        )
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ("development" !== 'production' &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;



function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre (element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldKeepComment: options.comments,
    start: function start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "development" !== 'production' && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.'
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints (el) {
        if (true) {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              "Cannot use <" + (el.tag) + "> as component root element because it may " +
              'contain multiple nodes.'
            );
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            );
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (true) {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead."
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$1 = 0; i$1 < postTransforms.length; i$1++) {
        postTransforms[i$1](element, options);
      }
    },

    end: function end () {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars (text) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored.")
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment (text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if ("development" !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      "development" !== 'production' && warn$2(
        ("Invalid v-for expression: " + exp)
      );
      return
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if."
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ("development" !== 'production' && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored."
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ("development" !== 'production' && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead."
      );
    }
  } else {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if ("development" !== 'production' && slotScope) {
        warn$2(
          "the \"scope\" attribute for scoped slots have been deprecated and " +
          "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
          "can also be used on plain elements in addition to <template> to " +
          "denote scoped slots.",
          true
        );
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      el.slotScope = slotScope;
    }
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (!el.slotScope) {
        addAttr(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(
              el,
              ("update:" + (camelize(name))),
              genAssignmentCode(value, "$event")
            );
          }
        }
        if (isProp || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if ("development" !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.'
          );
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
      "development" !== 'production' &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead."
      );
    }
    _el = _el.parent;
  }
}

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {
      var typeBinding = getBindingAttr(el, 'type');
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });
      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

function addRawAttr (el, name, value) {
  el.attrsMap[name] = value;
  el.attrsList.push({ name: name, value: value });
}

var model$2 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$2
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative,
  warn
) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    var handler = events[name];
    // #5330: warn click.right, since right clicks do not actually fire click events.
    if ("development" !== 'production' &&
      name === 'click' &&
      handler && handler.modifiers && handler.modifiers.right
    ) {
      warn(
        "Use \"contextmenu\" instead of \"click.right\" since right clicks " +
        "do not actually fire \"click\" events."
      );
    }
    res += "\"" + name + "\":" + (genHandler(name, handler)) + ",";
  }
  return res.slice(0, -1) + '}'
}

function genHandler (
  name,
  handler
) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression
      ? handler.value
      : ("function($event){" + (handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? handler.value + '($event)'
      : isFunctionExpression
        ? ("(" + (handler.value) + ")($event)")
        : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var code = keyCodes[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(code)) + "," +
    "$event.key)"
  )
}

/*  */

function on (el, dir) {
  if ("development" !== 'production' && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
      "development" !== 'production' && state.warn(
        "v-once can only be used inside v-for that is keyed. "
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ("development" !== 'production' &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + (genProps(el.attrs)) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + (genProps(el.props)) + "},";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false, state.warn)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true, state.warn)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ("development" !== 'production' && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  slots,
  state
) {
  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state)
    }).join(',')) + "])")
}

function genScopedSlot (
  key,
  el,
  state
) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state)
  }
  var fn = "function(" + (String(el.slotScope)) + "){" +
    "return " + (el.tag === 'template'
      ? el.if
        ? ((el.if) + "?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  return ("{key:" + key + ",fn:" + fn + "}")
}

function genForScopedSlot (
  key,
  el,
  state
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + (genScopedSlot(key, el, state)) +
    '})'
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      return (altGenElement || genElement)(el$1, state)
    }
    var normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
  }
  return res.slice(0, -1)
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors
}

function checkNode (node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), errors);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), errors);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent (exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
    );
  }
  checkExpression(exp, text, errors);
}

function checkFor (node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier (ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
  }
}

function checkExpression (exp, text, errors) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim())
      );
    } else {
      errors.push(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n"
      );
    }
  }
}

/*  */

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        warn$$1(
          "Error compiling template:\n\n" + template + "\n\n" +
          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
          vm
        );
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (true) {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "development" !== 'production' && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ("development" !== 'production' && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue$3.compile = compileToFunctions;

module.exports = Vue$3;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(45).setImmediate))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(46);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(6)))

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vanilla_lib_form__ = __webpack_require__(11);


/* harmony default export */ __webpack_exports__["a"] = ({
	loading: false,
	messages: [],
	activeModal: null,
	navigationOpen: true,
	deleteItem: false,
	form: new __WEBPACK_IMPORTED_MODULE_0__vanilla_lib_form__["a" /* default */]({
		message: ''
	}),
	deleteForm: new __WEBPACK_IMPORTED_MODULE_0__vanilla_lib_form__["a" /* default */]({
		_method: 'delete'
	})
});

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Errors = function () {
    /**
     * Create a new Errors instance.
     */
    function Errors() {
        _classCallCheck(this, Errors);

        this.errors = {};
    }

    /**
     * Determine if an errors exists for the given field.
     *
     * @param {string} field
     */


    _createClass(Errors, [{
        key: "has",
        value: function has(field) {
            return this.errors.hasOwnProperty(field);
        }

        /**
         * Determine if we have any errors.
         */

    }, {
        key: "any",
        value: function any() {
            return Object.keys(this.errors).length > 0;
        }

        /**
         * Retrieve the error message for a field.
         *
         * @param {string} field
         */

    }, {
        key: "get",
        value: function get(field) {
            if (this.errors[field]) {
                return this.errors[field][0];
            }
        }

        /**
         * Record the new errors.
         *
         * @param {object} errors
         */

    }, {
        key: "record",
        value: function record(errors) {
            this.errors = errors;
        }

        /**
         * Clear one or all error fields.
         *
         * @param {string|null} field
         */

    }, {
        key: "clear",
        value: function clear(field) {
            if (field) {
                delete this.errors[field];

                return;
            }

            this.errors = {};
        }
    }]);

    return Errors;
}();

/* harmony default export */ __webpack_exports__["a"] = (Errors);

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_qoob__);


/* harmony default export */ __webpack_exports__["a"] = ({
	activeModal: function activeModal(val) {
		if (null === this.activeModal) {
			__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.off(window, 'keyup', this.listenForEscape);
		} else {
			__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.on(window, 'keyup', this.listenForEscape);
		}
	}
});

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_qoob___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_qoob__);


/* harmony default export */ __webpack_exports__["a"] = ({
	showModal: function showModal(name) {
		this.$refs[name].show = true;
		this.activeModal = name;
	},
	hideModal: function hideModal() {
		this.$refs[this.activeModal].show = false;
		this.activeModal = null;
	},
	listenForEscape: function listenForEscape(event) {
		if (event.keyCode === 27) this.hideModal();
	},
	toggleNavigation: function toggleNavigation() {
		this.navigationOpen = !this.navigationOpen;
	},
	contactProjectManager: function contactProjectManager() {
		var _this = this;

		this.loading = true;
		this.hideModal();
		this.form.post('/laramin/contact').then(function (response) {
			_this.loading = false;
			_this.messages.push({ type: 'success', message: response.message });
		});
	},
	deleteItemInput: function deleteItemInput(event) {
		this.deleteItem = event.target.value;
	},
	submitDeleteItem: function submitDeleteItem(url, element) {
		var _this2 = this;

		var target = event.target;
		this.loading = true;
		this.hideModal();
		this.deleteForm.delete(url).then(function (response) {
			if (element !== '') {
				__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.remove(__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.head(__WEBPACK_IMPORTED_MODULE_0_qoob___default.a.ancestor(target, element)));
			}
			_this2.loading = false;
			_this2.messages.push({ type: 'success', message: response.message });
		});
	}
});

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(52)
/* template */
var __vue_template__ = __webpack_require__(53)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/Loader.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5ac15840", Component.options)
  } else {
    hotAPI.reload("data-v-5ac15840", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
	props: {
		loading: {
			default: false,
			type: Boolean
		}
	}
});

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "transition",
    {
      attrs: {
        "enter-active-class": "animated fadeIn",
        "leave-active-class": "animated fadeOut"
      }
    },
    [
      _c(
        "div",
        {
          directives: [
            {
              name: "show",
              rawName: "v-show",
              value: _vm.loading,
              expression: "loading"
            }
          ],
          staticClass: "Loader"
        },
        [
          _c("div", { staticClass: "Loader__icon" }, [
            _c("div", { staticClass: "Loader__square Loader__square1" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square2" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square3" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square4" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square5" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square6" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square7" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square8" }),
            _vm._v(" "),
            _c("div", { staticClass: "Loader__square Loader__square9" })
          ])
        ]
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-5ac15840", module.exports)
  }
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(55)
/* template */
var __vue_template__ = __webpack_require__(56)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/Modal.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1a4f9d20", Component.options)
  } else {
    hotAPI.reload("data-v-1a4f9d20", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
    props: {
        animationIn: {
            default: 'bounceInLeft',
            type: String
        },
        animationOut: {
            default: 'bounceOutRight',
            type: String
        }
    },
    data: function data() {
        return {
            show: false
        };
    },

    methods: {
        hideModal: function hideModal() {
            this.$emit('close');
        }
    }
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "Modal" },
    [
      _c(
        "transition",
        {
          attrs: {
            "enter-active-class": "animated fadeIn",
            "leave-active-class": "animated fadeOut"
          }
        },
        [
          _c("div", {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: _vm.show,
                expression: "show"
              }
            ],
            staticClass: "Modal__overlay"
          })
        ]
      ),
      _vm._v(" "),
      _c(
        "transition",
        {
          attrs: {
            "enter-active-class": "animated " + _vm.animationIn,
            "leave-active-class": "animated " + _vm.animationOut
          }
        },
        [
          _c(
            "div",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: _vm.show,
                  expression: "show"
                }
              ],
              staticClass: "Modal__container"
            },
            [
              _c("div", { staticClass: "Modal__content" }, [
                _c("header", { staticClass: "Modal__header" }, [
                  _c(
                    "h6",
                    { staticClass: "Modal__title" },
                    [_vm._t("title")],
                    2
                  ),
                  _vm._v(" "),
                  _c(
                    "button",
                    {
                      staticClass: "Modal__close",
                      on: {
                        click: function($event) {
                          _vm.hideModal()
                        }
                      }
                    },
                    [_c("i", { staticClass: "fa fa-times" })]
                  )
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "Modal__body" }, [
                  _c("div", { staticClass: "Content" }, [_vm._t("body")], 2)
                ]),
                _vm._v(" "),
                _c("footer", { staticClass: "Modal__footer" }, [
                  _c("small", [_vm._t("footer")], 2)
                ])
              ])
            ]
          )
        ]
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-1a4f9d20", module.exports)
  }
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(58)
/* template */
var __vue_template__ = __webpack_require__(59)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/NavigationBurger.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f7212394", Component.options)
  } else {
    hotAPI.reload("data-v-f7212394", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
	data: function data() {
		return {
			open: true
		};
	},

	methods: {
		openNavigation: function openNavigation() {
			this.$emit('toggle-navigation');
			this.open = !this.open;
		}
	}
});

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "button",
    {
      class: ["NavigationToggle", _vm.open ? "NavigationToggle--open" : ""],
      on: {
        click: function($event) {
          $event.preventDefault()
          _vm.openNavigation($event)
        }
      }
    },
    [
      _c("span", { staticClass: "NavigationToggle__burger" }),
      _vm._v(" "),
      _c("span", { staticClass: "NavigationToggle__burger" }),
      _vm._v(" "),
      _c("span", { staticClass: "NavigationToggle__burger" })
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-f7212394", module.exports)
  }
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(61)
/* template */
var __vue_template__ = __webpack_require__(62)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/Sidebar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-466a53df", Component.options)
  } else {
    hotAPI.reload("data-v-466a53df", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vanilla_lib_form__ = __webpack_require__(11);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["default"] = ({
	props: {
		open: {
			default: true,
			type: Boolean
		},
		user: {
			type: Object
		},
		userNavigation: {
			type: Array
		}
	},
	data: function data() {
		return {
			userNav: false
		};
	},

	methods: {
		openUserMenu: function openUserMenu() {
			return this.userNav = !this.userNav;
		},
		logout: function logout() {
			this.$emit('loading');

			var form = new __WEBPACK_IMPORTED_MODULE_0__vanilla_lib_form__["a" /* default */]();
			form.post('/logout').then(function (event) {
				return location.href = '/';
			});
		}
	}
});

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "transition",
    {
      attrs: {
        "enter-active-class": "animated animated--fast slideInLeft",
        "leave-active-class": "animated slideOutLeft"
      }
    },
    [
      _c(
        "aside",
        {
          directives: [
            {
              name: "show",
              rawName: "v-show",
              value: _vm.open,
              expression: "open"
            }
          ],
          staticClass: "Sidebar"
        },
        [
          _c("div", { staticClass: "Sidebar__container" }, [
            _c("section", { staticClass: "Avatar" }, [
              _vm.user.avatar
                ? _c("img", {
                    staticClass: "Avatar__image",
                    attrs: { src: _vm.user.avatar, alt: _vm.user.name }
                  })
                : _c("i", {
                    staticClass: "Avatar__image fa fa-4x fa-user-circle-o"
                  }),
              _vm._v(" "),
              _c(
                "div",
                { staticClass: "Avatar__menu" },
                [
                  _c(
                    "h6",
                    {
                      staticClass: "Avatar__name",
                      on: {
                        click: function($event) {
                          $event.preventDefault()
                          _vm.openUserMenu($event)
                        }
                      }
                    },
                    [
                      _vm._v(_vm._s(_vm.user.name) + "\n\t\t\t\t\t\t"),
                      _c(
                        "span",
                        {
                          class: [
                            "Avatar__button",
                            _vm.userNav ? "Avatar__button--active" : ""
                          ]
                        },
                        [_c("i", { staticClass: "fa fa-angle-down" })]
                      )
                    ]
                  ),
                  _vm._v(" "),
                  _c(
                    "transition",
                    {
                      attrs: {
                        "enter-active-class": "animated flipInX",
                        "leave-active-class": "animated flipOutX"
                      }
                    },
                    [
                      _c(
                        "nav",
                        {
                          directives: [
                            {
                              name: "show",
                              rawName: "v-show",
                              value: _vm.userNav,
                              expression: "userNav"
                            }
                          ],
                          staticClass: "Avatar__navigation"
                        },
                        [
                          _c(
                            "ul",
                            { staticClass: "List List--unstyled" },
                            [
                              _vm._l(_vm.userNavigation, function(item) {
                                return _c("li", { staticClass: "List__item" }, [
                                  _c(
                                    "a",
                                    {
                                      staticClass: "List__item-link",
                                      attrs: { href: item.link }
                                    },
                                    [_vm._v("item.name")]
                                  )
                                ])
                              }),
                              _vm._v(" "),
                              _c("li", { staticClass: "List__item" }, [
                                _c(
                                  "a",
                                  {
                                    staticClass: "List__item-link",
                                    attrs: { href: "#" },
                                    on: {
                                      click: function($event) {
                                        $event.preventDefault()
                                        _vm.logout($event)
                                      }
                                    }
                                  },
                                  [_vm._v("Logout")]
                                )
                              ])
                            ],
                            2
                          )
                        ]
                      )
                    ]
                  )
                ],
                1
              )
            ]),
            _vm._v(" "),
            _c("nav", { staticClass: "Navigation" }, [
              _c(
                "ul",
                { staticClass: "Navigation__list" },
                [_vm._t("default")],
                2
              )
            ])
          ])
        ]
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-466a53df", module.exports)
  }
}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(64)
/* template */
var __vue_template__ = __webpack_require__(65)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/SidebarItem.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0f7c7612", Component.options)
  } else {
    hotAPI.reload("data-v-0f7c7612", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
	props: {
		url: {
			required: true,
			type: String
		},
		icon: {
			type: String
		}
	},
	data: function data() {
		return {
			active: window.location.pathname === this.url || '/' + window.location.pathname.split('/')[1] + '/' + window.location.pathname.split('/')[2] === this.url
		};
	}
});

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "li",
    {
      class: [
        "Navigation__list-item",
        _vm.active ? "Navigation__list-item--active" : ""
      ]
    },
    [
      _c(
        "a",
        { staticClass: "Navigation__list-link", attrs: { href: _vm.url } },
        [
          _vm.icon
            ? _c("i", {
                staticClass: "Navigation__list-icon",
                class: ["fa", _vm.icon]
              })
            : _vm._e(),
          _vm._v(" "),
          _vm._t("default")
        ],
        2
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0f7c7612", module.exports)
  }
}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(67)
/* template */
var __vue_template__ = __webpack_require__(70)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/Tooltip.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-de4925f4", Component.options)
  } else {
    hotAPI.reload("data-v-de4925f4", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tooltip_js__ = __webpack_require__(68);
//
//
//
//



/* harmony default export */ __webpack_exports__["default"] = ({
	props: {
		tooltip: {
			default: 'No tool tip provided.',
			type: String
		},
		trigger: {
			default: 'hover',
			type: String
		},
		animation: {
			default: 'flipInX',
			type: String
		},
		placement: {
			default: 'top',
			type: String
		}
	},
	mounted: function mounted() {
		var message = new __WEBPACK_IMPORTED_MODULE_0_tooltip_js__["a" /* default */](this.$el, {
			title: this.tooltip,
			trigger: this.trigger,
			placement: this.placement,
			template: '<div class="Tooltip__text" role="tooltip"><div class="tooltip__inner"></div></div>'
		});

		if (this.trigger.includes('click')) {
			this.$el.addEventListener('click', function () {
				setTimeout(function () {
					message.hide();
				}, 5000);
			});
		}
	}
});

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_popper_js__ = __webpack_require__(69);
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.1.6
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var DEFAULT_OPTIONS = {
  container: false,
  delay: 0,
  html: false,
  placement: 'top',
  title: '',
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  trigger: 'hover focus',
  offset: 0
};

var Tooltip = function () {
  /**
   * Create a new Tooltip.js instance
   * @class Tooltip
   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
   * @param {Object} options
   * @param {String} options.placement=bottom
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
   *      left(-start, -end)`
   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
   * @param {Number|Object} options.delay=0
   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
   *      If a number is supplied, delay is applied to both hide/show.
   *      Object structure is: `{ show: 500, hide: 100 }`
   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.
   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.
   * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
   *      Base HTML to used when creating the tooltip.
   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
   *      The outermost wrapper element should have the `.tooltip` class.
   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
   * @param {String} [options.trigger='hover focus']
   *      How tooltip is triggered - click, hover, focus, manual.
   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
   * @param {HTMLElement} options.boundariesElement
   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
   *      [offset docs](https://popper.js.org/popper-documentation.html)
   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
   *      [options docs](https://popper.js.org/popper-documentation.html)
   * @return {Object} instance - The generated tooltip instance
   */
  function Tooltip(reference, options) {
    classCallCheck(this, Tooltip);

    _initialiseProps.call(this);

    // apply user options over default ones
    options = _extends({}, DEFAULT_OPTIONS, options);

    reference.jquery && (reference = reference[0]);

    // cache reference and options
    this.reference = reference;
    this.options = options;

    // get events list
    var events = typeof options.trigger === 'string' ? options.trigger.split(' ').filter(function (trigger) {
      return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;
    }) : [];

    // set initial state
    this._isOpen = false;

    // set event listeners
    this._setEventListeners(reference, events, options);
  }

  //
  // Public methods
  //

  /**
   * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
   * Tooltips with zero-length titles are never displayed.
   * @method Tooltip#show
   * @memberof Tooltip
   */


  /**
   * Hides an elements tooltip. This is considered a manual triggering of the tooltip.
   * @method Tooltip#hide
   * @memberof Tooltip
   */


  /**
   * Hides and destroys an elements tooltip.
   * @method Tooltip#dispose
   * @memberof Tooltip
   */


  /**
   * Toggles an elements tooltip. This is considered a manual triggering of the tooltip.
   * @method Tooltip#toggle
   * @memberof Tooltip
   */


  //
  // Defaults
  //


  //
  // Private methods
  //

  createClass(Tooltip, [{
    key: '_create',


    /**
     * Creates a new tooltip node
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} reference
     * @param {String} template
     * @param {String|HTMLElement|TitleFunction} title
     * @param {Boolean} allowHtml
     * @return {HTMLelement} tooltipNode
     */
    value: function _create(reference, template, title, allowHtml) {
      // create tooltip element
      var tooltipGenerator = window.document.createElement('div');
      tooltipGenerator.innerHTML = template.trim();
      var tooltipNode = tooltipGenerator.childNodes[0];

      // add unique ID to our tooltip (needed for accessibility reasons)
      tooltipNode.id = 'tooltip_' + Math.random().toString(36).substr(2, 10);

      // set initial `aria-hidden` state to `false` (it's visible!)
      tooltipNode.setAttribute('aria-hidden', 'false');

      // add title to tooltip
      var titleNode = tooltipGenerator.querySelector(this.innerSelector);
      if (title.nodeType === 1) {
        // if title is a node, append it only if allowHtml is true
        allowHtml && titleNode.appendChild(title);
      } else if (isFunction(title)) {
        // if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value
        var titleText = title.call(reference);
        allowHtml ? titleNode.innerHTML = titleText : titleNode.innerText = titleText;
      } else {
        // if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value
        allowHtml ? titleNode.innerHTML = title : titleNode.innerText = title;
      }

      // return the generated tooltip node
      return tooltipNode;
    }
  }, {
    key: '_show',
    value: function _show(reference, options) {
      // don't show if it's already visible
      if (this._isOpen) {
        return this;
      }
      this._isOpen = true;

      // if the tooltipNode already exists, just show it
      if (this._tooltipNode) {
        this._tooltipNode.style.display = '';
        this._tooltipNode.setAttribute('aria-hidden', 'false');
        this.popperInstance.update();
        return this;
      }

      // get title
      var title = reference.getAttribute('title') || options.title;

      // don't show tooltip if no title is defined
      if (!title) {
        return this;
      }

      // create tooltip node
      var tooltipNode = this._create(reference, options.template, title, options.html);

      // Add `aria-describedby` to our reference element for accessibility reasons
      reference.setAttribute('aria-describedby', tooltipNode.id);

      // append tooltip to container
      var container = this._findContainer(options.container, reference);

      this._append(tooltipNode, container);

      var popperOptions = _extends({}, options.popperOptions, {
        placement: options.placement
      });

      popperOptions.modifiers = _extends({}, popperOptions.modifiers, {
        arrow: {
          element: this.arrowSelector
        }
      });

      if (options.boundariesElement) {
        popperOptions.modifiers.preventOverflow = {
          boundariesElement: options.boundariesElement
        };
      }

      this.popperInstance = new __WEBPACK_IMPORTED_MODULE_0_popper_js__["a" /* default */](reference, tooltipNode, popperOptions);

      this._tooltipNode = tooltipNode;

      return this;
    }
  }, {
    key: '_hide',
    value: function _hide() /*reference, options*/{
      // don't hide if it's already hidden
      if (!this._isOpen) {
        return this;
      }

      this._isOpen = false;

      // hide tooltipNode
      this._tooltipNode.style.display = 'none';
      this._tooltipNode.setAttribute('aria-hidden', 'true');

      return this;
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      var _this = this;

      // remove event listeners first to prevent any unexpected behaviour
      this._events.forEach(function (_ref) {
        var func = _ref.func,
            event = _ref.event;

        _this.reference.removeEventListener(event, func);
      });
      this._events = [];

      if (this._tooltipNode) {
        this._hide();

        // destroy instance
        this.popperInstance.destroy();

        // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element
        if (!this.popperInstance.options.removeOnDestroy) {
          this._tooltipNode.parentNode.removeChild(this._tooltipNode);
          this._tooltipNode = null;
        }
      }
      return this;
    }
  }, {
    key: '_findContainer',
    value: function _findContainer(container, reference) {
      // if container is a query, get the relative element
      if (typeof container === 'string') {
        container = window.document.querySelector(container);
      } else if (container === false) {
        // if container is `false`, set it to reference parent
        container = reference.parentNode;
      }
      return container;
    }

    /**
     * Append tooltip to container
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} tooltip
     * @param {HTMLElement|String|false} container
     */

  }, {
    key: '_append',
    value: function _append(tooltipNode, container) {
      container.appendChild(tooltipNode);
    }
  }, {
    key: '_setEventListeners',
    value: function _setEventListeners(reference, events, options) {
      var _this2 = this;

      var directEvents = [];
      var oppositeEvents = [];

      events.forEach(function (event) {
        switch (event) {
          case 'hover':
            directEvents.push('mouseenter');
            oppositeEvents.push('mouseleave');
            break;
          case 'focus':
            directEvents.push('focus');
            oppositeEvents.push('blur');
            break;
          case 'click':
            directEvents.push('click');
            oppositeEvents.push('click');
            break;
        }
      });

      // schedule show tooltip
      directEvents.forEach(function (event) {
        var func = function func(evt) {
          if (_this2._isOpen === true) {
            return;
          }
          evt.usedByTooltip = true;
          _this2._scheduleShow(reference, options.delay, options, evt);
        };
        _this2._events.push({ event: event, func: func });
        reference.addEventListener(event, func);
      });

      // schedule hide tooltip
      oppositeEvents.forEach(function (event) {
        var func = function func(evt) {
          if (evt.usedByTooltip === true) {
            return;
          }
          _this2._scheduleHide(reference, options.delay, options, evt);
        };
        _this2._events.push({ event: event, func: func });
        reference.addEventListener(event, func);
      });
    }
  }, {
    key: '_scheduleShow',
    value: function _scheduleShow(reference, delay, options /*, evt */) {
      var _this3 = this;

      // defaults to 0
      var computedDelay = delay && delay.show || delay || 0;
      window.setTimeout(function () {
        return _this3._show(reference, options);
      }, computedDelay);
    }
  }, {
    key: '_scheduleHide',
    value: function _scheduleHide(reference, delay, options, evt) {
      var _this4 = this;

      // defaults to 0
      var computedDelay = delay && delay.hide || delay || 0;
      window.setTimeout(function () {
        if (_this4._isOpen === false) {
          return;
        }
        if (!document.body.contains(_this4._tooltipNode)) {
          return;
        }

        // if we are hiding because of a mouseleave, we must check that the new
        // reference isn't the tooltip, because in this case we don't want to hide it
        if (evt.type === 'mouseleave') {
          var isSet = _this4._setTooltipNodeEvent(evt, reference, delay, options);

          // if we set the new event, don't hide the tooltip yet
          // the new event will take care to hide it if necessary
          if (isSet) {
            return;
          }
        }

        _this4._hide(reference, options);
      }, computedDelay);
    }
  }]);
  return Tooltip;
}();

/**
 * Placement function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback PlacementFunction
 * @param {HTMLElement} tooltip - tooltip DOM node.
 * @param {HTMLElement} reference - reference DOM node.
 * @return {String} placement - One of the allowed placement options.
 */

/**
 * Title function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback TitleFunction
 * @return {String} placement - The desired title.
 */


var _initialiseProps = function _initialiseProps() {
  var _this5 = this;

  this.show = function () {
    return _this5._show(_this5.reference, _this5.options);
  };

  this.hide = function () {
    return _this5._hide();
  };

  this.dispose = function () {
    return _this5._dispose();
  };

  this.toggle = function () {
    if (_this5._isOpen) {
      return _this5.hide();
    } else {
      return _this5.show();
    }
  };

  this.arrowSelector = '.tooltip-arrow, .tooltip__arrow';
  this.innerSelector = '.tooltip-inner, .tooltip__inner';
  this._events = [];

  this._setTooltipNodeEvent = function (evt, reference, delay, options) {
    var relatedreference = evt.relatedreference || evt.toElement;

    var callback = function callback(evt2) {
      var relatedreference2 = evt2.relatedreference || evt2.toElement;

      // Remove event listener after call
      _this5._tooltipNode.removeEventListener(evt.type, callback);

      // If the new reference is not the reference element
      if (!reference.contains(relatedreference2)) {
        // Schedule to hide tooltip
        _this5._scheduleHide(reference, options.delay, options, evt2);
      }
    };

    if (_this5._tooltipNode.contains(relatedreference)) {
      // listen to mouseleave on the tooltip element to be able to hide the tooltip
      _this5._tooltipNode.addEventListener(evt.type, callback);
      return true;
    }

    return false;
  };
};

/* harmony default export */ __webpack_exports__["a"] = (Tooltip);
//# sourceMappingURL=tooltip.js.map


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.12.6
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return window.document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element && element.offsetParent;
  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    if (element) {
      return element.ownerDocument.documentElement;
    }

    return window.document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return window.document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];
}

/**
 * Tells if you are running Internet Explorer 10
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean} isIE10
 */
var isIE10 = undefined;

var isIE10$1 = function () {
  if (isIE10 === undefined) {
    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
  }
  return isIE10;
};

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = window.document.body;
  var html = window.document.documentElement;
  var computedStyle = isIE10$1() && window.getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  if (isIE10$1()) {
    try {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } catch (err) {}
  } else {
    rect = element.getBoundingClientRect();
  }

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var isIE10 = isIE10$1();
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = +styles.borderTopWidth.split('px')[0];
  var borderLeftWidth = +styles.borderLeftWidth.split('px')[0];

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = +styles.marginTop.split('px')[0];
    var marginLeft = +styles.marginLeft.split('px')[0];

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = getScroll(html);
  var scrollLeft = getScroll(html, 'left');

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = { top: 0, left: 0 };
  var offsetParent = findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(popper));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var commonOffsetParent = findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length - 1; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof window.document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.left = '';
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    window.cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper.
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // floor sides to avoid blurry text
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.floor(popper.top),
    bottom: Math.floor(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var popperMarginSide = getStyleComputedProperty(data.instance.popper, 'margin' + sideCapitalized).replace('px', '');
  var sideValue = center - getClientRect(data.offsets.popper)[side] - popperMarginSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = {};
  data.offsets.arrow[side] = Math.round(sideValue);
  data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["a"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(4)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("span", { staticClass: "Tooltip" }, [_vm._t("default")], 2)
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-de4925f4", module.exports)
  }
}

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(72)
/* template */
var __vue_template__ = __webpack_require__(73)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/Flash.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2d21cd33", Component.options)
  } else {
    hotAPI.reload("data-v-2d21cd33", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
	data: function data() {
		return {
			show: false
		};
	},

	props: {
		type: {
			type: String,
			default: 'success'
		},
		message: {
			type: String,
			required: true
		},
		animationIn: {
			default: 'bounceInLeft',
			type: String
		},
		animationOut: {
			default: 'bounceOutRight',
			type: String
		}
	},
	mounted: function mounted() {
		setTimeout(function () {
			this.show = true;
		}.bind(this), this.showTime());

		setTimeout(function () {
			this.show = false;
		}.bind(this), 5000);
	},

	methods: {
		showTime: function showTime() {
			var min = Math.ceil(10);
			var max = Math.floor(250);
			return Math.floor(Math.random() * (max - min)) + min;
		}
	}
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "transition",
    {
      attrs: {
        "enter-active-class": "animated " + _vm.animationIn,
        "leave-active-class": "animated " + _vm.animationOut
      }
    },
    [
      _c("div", {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.show,
            expression: "show"
          }
        ],
        class: ["Flash__message", "Flash__message--" + _vm.type],
        domProps: { textContent: _vm._s(_vm.message) }
      })
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2d21cd33", module.exports)
  }
}

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(75)
/* template */
var __vue_template__ = __webpack_require__(76)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/TagsInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-08a63b18", Component.options)
  } else {
    hotAPI.reload("data-v-08a63b18", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ __webpack_exports__["default"] = ({
    props: {
        name: {
            type: String,
            default: ''
        },
        tags: {
            type: Array,
            default: function _default() {
                return [];
            }
        },
        autocomplete: {
            type: Array,
            default: function _default() {
                return [];
            }
        },
        placeholder: {
            type: String,
            default: ''
        },
        onChange: {
            type: Function
        }
    },
    data: function data() {
        return {
            tagsArray: this.tags,
            newTag: '',
            autocompleteSuggestions: [],
            autocompleteIndex: -1
        };
    },

    methods: {
        focus: function focus() {
            this.$refs.tags.focus();
        },
        addTag: function addTag(tag) {
            if (tag && !this.tagsArray.includes(tag)) {
                if (this.autocompleteIndex !== -1) {
                    if (!this.tagsArray.includes(this.autocompleteSuggestions[this.autocompleteIndex])) {
                        this.tagsArray.push(this.autocompleteSuggestions[this.autocompleteIndex]);
                    }
                } else {
                    if (tag.replace(/\s/g, '').length) {
                        this.tagsArray.push(tag);
                    }
                }
                this.emitChanges();
            }
            this.newTag = '';
            this.autocompleteSuggestions = [];
            this.autocompleteIndex = -1;
        },
        remove: function remove(tag) {
            this.tagsArray = this.tagsArray.filter(function (item) {
                return tag !== item;
            });
            this.emitChanges();
        },
        removeLastTag: function removeLastTag() {
            if (this.newTag) {
                return;
            }
            this.tagsArray.pop();
            this.emitChanges();
        },
        emitChanges: function emitChanges() {
            if (this.onChange) {
                this.onChange(JSON.parse(JSON.stringify(this.tagsArray)));
            }
        },
        autocompleteShow: function autocompleteShow() {
            var _this = this;

            if (this.newTag === '') {
                this.autocompleteSuggestions = [];
            } else {
                this.autocomplete.forEach(function (word, index) {
                    if (word.match(_this.newTag) !== null && _this.newTag !== '') {
                        if (!_this.autocompleteSuggestions.includes(word)) {
                            _this.autocompleteSuggestions.push(word);
                        }
                    } else {
                        _this.autocompleteSuggestions.splice(index, 1);
                    }
                });
            }
        },
        autocompleteUp: function autocompleteUp() {
            this.autocompleteIndex <= 1 ? this.autocompleteIndex = 0 : this.autocompleteIndex--;
            this.$refs.li.forEach(function (li) {
                li.classList.remove('active');
            });
            this.$refs.li[this.autocompleteIndex].classList.add('active');
        },
        autocompleteDown: function autocompleteDown() {
            this.autocompleteIndex < this.$refs.li.length - 1 ? this.autocompleteIndex++ : '';
            this.$refs.li.forEach(function (li) {
                li.classList.remove('active');
            });
            this.$refs.li[this.autocompleteIndex].classList.add('active');
        }
    }
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      ref: "tags",
      staticClass: "Tags",
      on: {
        click: function($event) {
          _vm.focus()
        }
      }
    },
    [
      _vm._l(_vm.tagsArray, function(tag, index) {
        return _c("span", { key: index, staticClass: "Tag" }, [
          _c("div", { staticClass: "Tag__name" }, [_vm._v(_vm._s(tag))]),
          _vm._v(" "),
          _c(
            "div",
            {
              staticClass: "Tag__remove",
              on: {
                click: function($event) {
                  $event.preventDefault()
                  $event.stopPropagation()
                  _vm.remove(tag)
                }
              }
            },
            [_c("i", { staticClass: "fa fa-times" })]
          ),
          _vm._v(" "),
          _vm.name
            ? _c("input", {
                attrs: { name: _vm.name, type: "hidden" },
                domProps: { value: tag }
              })
            : _vm._e()
        ])
      }),
      _vm._v(" "),
      _c("div", { staticClass: "Tags__input-wrapper" }, [
        _c("input", {
          directives: [
            {
              name: "model",
              rawName: "v-model",
              value: _vm.newTag,
              expression: "newTag"
            }
          ],
          staticClass: "Tags__input",
          attrs: { placeholder: _vm.placeholder, type: "text" },
          domProps: { value: _vm.newTag },
          on: {
            keydown: [
              function($event) {
                if (
                  !("button" in $event) &&
                  _vm._k($event.keyCode, "delete", [8, 46], $event.key)
                ) {
                  return null
                }
                $event.stopPropagation()
                _vm.removeLastTag()
              },
              function($event) {
                if (
                  !("button" in $event) &&
                  $event.keyCode !== 188 &&
                  _vm._k($event.keyCode, "enter", 13, $event.key) &&
                  _vm._k($event.keyCode, "tab", 9, $event.key)
                ) {
                  return null
                }
                $event.preventDefault()
                $event.stopPropagation()
                _vm.addTag(_vm.newTag)
              },
              function($event) {
                if (
                  !("button" in $event) &&
                  _vm._k($event.keyCode, "up", 38, $event.key)
                ) {
                  return null
                }
                _vm.autocompleteUp()
              },
              function($event) {
                if (
                  !("button" in $event) &&
                  _vm._k($event.keyCode, "down", 40, $event.key)
                ) {
                  return null
                }
                _vm.autocompleteDown()
              }
            ],
            input: [
              function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.newTag = $event.target.value
              },
              function($event) {
                _vm.autocompleteShow()
              }
            ]
          }
        }),
        _vm._v(" "),
        _vm.autocompleteSuggestions.length >= 1
          ? _c(
              "ul",
              { staticClass: "Tags__list" },
              _vm._l(_vm.autocompleteSuggestions, function(suggestion, index) {
                return _c("li", {
                  ref: "li",
                  refInFor: true,
                  staticClass: "Tags__list-item",
                  domProps: { textContent: _vm._s(suggestion) },
                  on: {
                    click: function($event) {
                      _vm.autocompleteIndex = -1
                      _vm.addTag(suggestion)
                    }
                  }
                })
              })
            )
          : _vm._e()
      ])
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-08a63b18", module.exports)
  }
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(78)
/* template */
var __vue_template__ = __webpack_require__(79)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/Tabs.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4231d30b", Component.options)
  } else {
    hotAPI.reload("data-v-4231d30b", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
	data: function data() {
		return {
			tabs: []
		};
	},
	mounted: function mounted() {
		this.tabs = this.$children;
		this.mountTab();
	},

	methods: {
		mountTab: function mountTab() {
			if (window.location.hash) {
				var refs = this.tabs.filter(function (tab) {
					return tab.$refs[window.location.hash];
				});
				if (refs.length >= 1) {
					return refs[0].isActive = true;
				}
			}
			return this.tabs[0].isActive = true;
		},
		selectTab: function selectTab(hash) {
			this.tabs.forEach(function (tab) {
				if (tab.hash === hash) {
					tab.isActive = true;
				} else {
					tab.isActive = false;
				}
			});
		}
	}
});

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "Tabs" }, [
    _c(
      "ul",
      { staticClass: "Tabs__list", attrs: { role: "tablist" } },
      _vm._l(_vm.tabs, function(tab) {
        return _c(
          "li",
          {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: tab.isVisible,
                expression: "tab.isVisible"
              }
            ],
            staticClass: "Tabs__list-item",
            attrs: { role: "presentation" }
          },
          [
            _c("a", {
              class: ["Tabs__list-link", tab.isActive ? "is-active" : ""],
              attrs: {
                "aria-controls": tab.hash,
                "aria-selected": tab.isActive,
                href: tab.hash,
                role: "tab"
              },
              domProps: { innerHTML: _vm._s(tab.header) },
              on: {
                click: function($event) {
                  _vm.selectTab(tab.hash, $event)
                }
              }
            })
          ]
        )
      })
    ),
    _vm._v(" "),
    _c("div", { staticClass: "Tabs__panels" }, [_vm._t("default")], 2)
  ])
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4231d30b", module.exports)
  }
}

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(81)
/* template */
var __vue_template__ = __webpack_require__(82)
/* template functional */
  var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/vue/components/Tab.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5f101dd0", Component.options)
  } else {
    hotAPI.reload("data-v-5f101dd0", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
    props: {
        id: { default: null },
        name: { required: true },
        prefix: { default: '' },
        suffix: { default: '' }
    },
    data: function data() {
        return {
            isActive: false,
            isVisible: true
        };
    },
    computed: {
        header: function header() {
            return this.prefix + this.name + this.suffix;
        },
        hash: function hash() {
            return this.id ? '#' + this.id : '#' + this.name.toLowerCase().replace(/ /g, '-');
        }
    }
});

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "section",
    {
      directives: [
        {
          name: "show",
          rawName: "v-show",
          value: _vm.isActive,
          expression: "isActive"
        }
      ],
      ref: _vm.hash,
      staticClass: "Tabs__panel",
      attrs: { "aria-hidden": !_vm.isActive, id: _vm.hash, role: "tabpanel" }
    },
    [_c("div", { staticClass: "Box Box--padded" }, [_vm._t("default")], 2)]
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-5f101dd0", module.exports)
  }
}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);